!function() {
    function tapEventListener(type, enable, useCapture) {
        enable !== !1 ? tapDoc.addEventListener(type, tapEventListeners[type], useCapture) : tapDoc.removeEventListener(type, tapEventListeners[type]);
    }
    function tapClick(e) {
        var container = tapContainingElement(e.target), ele = tapTargetElement(container);
        if (ionic.tap.requiresNativeClick(ele) || tapPointerMoved) return !1;
        var c = ionic.tap.pointerCoord(e);
        triggerMouseEvent("click", ele, c.x, c.y), tapHandleFocus(ele);
    }
    function triggerMouseEvent(type, ele, x, y) {
        var clickEvent = document.createEvent("MouseEvents");
        clickEvent.initMouseEvent(type, !0, !0, window, 1, 0, 0, x, y, !1, !1, !1, !1, 0, null), 
        clickEvent.isIonicTap = !0, ele.dispatchEvent(clickEvent);
    }
    function tapClickGateKeeper(e) {
        return "submit" == e.target.type && 0 === e.detail ? null : ionic.scroll.isScrolling && ionic.tap.containsOrIsTextInput(e.target) || !e.isIonicTap && !ionic.tap.requiresNativeClick(e.target) ? (e.stopPropagation(), 
        ionic.tap.isLabelWithTextInput(e.target) || e.preventDefault(), !1) : void 0;
    }
    function tapMouseDown(e) {
        return e.isIonicTap || tapIgnoreEvent(e) ? null : tapEnabledTouchEvents ? (e.stopPropagation(), 
        ionic.Platform.isEdge() || ionic.tap.isTextInput(e.target) && tapLastTouchTarget === e.target || isSelectOrOption(e.target.tagName) || ionic.tap.isVideo(e.target) || e.preventDefault(), 
        !1) : (tapPointerMoved = !1, tapPointerStart = ionic.tap.pointerCoord(e), tapEventListener("mousemove"), 
        void ionic.activator.start(e));
    }
    function tapMouseUp(e) {
        return tapEnabledTouchEvents ? (e.stopPropagation(), e.preventDefault(), !1) : tapIgnoreEvent(e) || isSelectOrOption(e.target.tagName) ? !1 : (tapHasPointerMoved(e) || tapClick(e), 
        tapEventListener("mousemove", !1), ionic.activator.end(), void (tapPointerMoved = !1));
    }
    function tapMouseMove(e) {
        return tapHasPointerMoved(e) ? (tapEventListener("mousemove", !1), ionic.activator.end(), 
        tapPointerMoved = !0, !1) : void 0;
    }
    function tapTouchStart(e) {
        if (!tapIgnoreEvent(e) && (tapPointerMoved = !1, tapEnableTouchEvents(), tapPointerStart = ionic.tap.pointerCoord(e), 
        tapEventListener(tapTouchMoveListener), ionic.activator.start(e), ionic.Platform.isIOS() && ionic.tap.isLabelWithTextInput(e.target))) {
            var textInput = tapTargetElement(tapContainingElement(e.target));
            textInput !== tapActiveEle && e.preventDefault();
        }
    }
    function tapTouchEnd(e) {
        tapIgnoreEvent(e) || (tapEnableTouchEvents(), tapHasPointerMoved(e) || (tapClick(e), 
        isSelectOrOption(e.target.tagName) && e.preventDefault()), tapLastTouchTarget = e.target, 
        tapTouchCancel());
    }
    function tapTouchMove(e) {
        return tapHasPointerMoved(e) ? (tapPointerMoved = !0, tapEventListener(tapTouchMoveListener, !1), 
        ionic.activator.end(), !1) : void 0;
    }
    function tapTouchCancel() {
        tapEventListener(tapTouchMoveListener, !1), ionic.activator.end(), tapPointerMoved = !1;
    }
    function tapEnableTouchEvents() {
        tapEnabledTouchEvents = !0, clearTimeout(tapMouseResetTimer), tapMouseResetTimer = setTimeout(function() {
            tapEnabledTouchEvents = !1;
        }, 600);
    }
    function tapIgnoreEvent(e) {
        return e.isTapHandled ? !0 : (e.isTapHandled = !0, ionic.tap.isElementTapDisabled(e.target) ? !0 : ionic.scroll.isScrolling && ionic.tap.containsOrIsTextInput(e.target) ? (e.preventDefault(), 
        !0) : void 0);
    }
    function tapHandleFocus(ele) {
        tapTouchFocusedInput = null;
        var triggerFocusIn = !1;
        "SELECT" == ele.tagName ? (triggerMouseEvent("mousedown", ele, 0, 0), ele.focus && ele.focus(), 
        triggerFocusIn = !0) : tapActiveElement() === ele ? triggerFocusIn = !0 : /^(input|textarea)$/i.test(ele.tagName) || ele.isContentEditable ? (triggerFocusIn = !0, 
        ele.focus && ele.focus(), ele.value = ele.value, tapEnabledTouchEvents && (tapTouchFocusedInput = ele)) : tapFocusOutActive(), 
        triggerFocusIn && (tapActiveElement(ele), ionic.trigger("ionic.focusin", {
            target: ele
        }, !0));
    }
    function tapFocusOutActive() {
        var ele = tapActiveElement();
        ele && (/^(input|textarea|select)$/i.test(ele.tagName) || ele.isContentEditable) && ele.blur(), 
        tapActiveElement(null);
    }
    function tapFocusIn(e) {
        tapEnabledTouchEvents && ionic.tap.isTextInput(tapActiveElement()) && ionic.tap.isTextInput(tapTouchFocusedInput) && tapTouchFocusedInput !== e.target && (tapTouchFocusedInput.focus(), 
        tapTouchFocusedInput = null), ionic.scroll.isScrolling = !1;
    }
    function tapFocusOut() {
        tapActiveElement(null);
    }
    function tapActiveElement(ele) {
        return arguments.length && (tapActiveEle = ele), tapActiveEle || document.activeElement;
    }
    function tapHasPointerMoved(endEvent) {
        if (!endEvent || 1 !== endEvent.target.nodeType || !tapPointerStart || 0 === tapPointerStart.x && 0 === tapPointerStart.y) return !1;
        var endCoordinates = ionic.tap.pointerCoord(endEvent), hasClassList = !(!endEvent.target.classList || !endEvent.target.classList.contains || "function" != typeof endEvent.target.classList.contains), releaseTolerance = hasClassList && endEvent.target.classList.contains("button") ? TAP_RELEASE_BUTTON_TOLERANCE : TAP_RELEASE_TOLERANCE;
        return Math.abs(tapPointerStart.x - endCoordinates.x) > releaseTolerance || Math.abs(tapPointerStart.y - endCoordinates.y) > releaseTolerance;
    }
    function tapContainingElement(ele, allowSelf) {
        for (var climbEle = ele, x = 0; 6 > x && climbEle; x++) {
            if ("LABEL" === climbEle.tagName) return climbEle;
            climbEle = climbEle.parentElement;
        }
        return allowSelf !== !1 ? ele : void 0;
    }
    function tapTargetElement(ele) {
        if (ele && "LABEL" === ele.tagName) {
            if (ele.control) return ele.control;
            if (ele.querySelector) {
                var control = ele.querySelector("input,textarea,select");
                if (control) return control;
            }
        }
        return ele;
    }
    function isSelectOrOption(tagName) {
        return /^(select|option)$/i.test(tagName);
    }
    function keyboardInit() {
        ionic.keyboard.isInitialized || (keyboardHasPlugin() ? (window.addEventListener("native.keyboardshow", debouncedKeyboardNativeShow), 
        window.addEventListener("native.keyboardhide", keyboardFocusOut)) : document.body.addEventListener("focusout", keyboardFocusOut), 
        document.body.addEventListener("ionic.focusin", debouncedKeyboardFocusIn), document.body.addEventListener("focusin", debouncedKeyboardFocusIn), 
        window.navigator.msPointerEnabled ? document.removeEventListener("MSPointerDown", keyboardInit) : document.removeEventListener("touchstart", keyboardInit), 
        ionic.keyboard.isInitialized = !0);
    }
    function keyboardNativeShow(e) {
        clearTimeout(keyboardFocusOutTimer), (!ionic.keyboard.isOpen || ionic.keyboard.isClosing) && (ionic.keyboard.isOpening = !0, 
        ionic.keyboard.isClosing = !1), ionic.keyboard.height = e.keyboardHeight, wasOrientationChange ? keyboardWaitForResize(keyboardUpdateViewportHeight, !0) : keyboardWaitForResize(keyboardShow, !0);
    }
    function keyboardFocusIn(e) {
        return clearTimeout(keyboardFocusOutTimer), e.target && !e.target.readOnly && ionic.tap.isKeyboardElement(e.target) && (scrollView = ionic.DomUtil.getParentWithClass(e.target, SCROLL_CONTAINER_CSS)) ? (keyboardActiveElement = e.target, 
        scrollView.classList.contains("overflow-scroll") || (document.body.scrollTop = 0, 
        scrollView.scrollTop = 0, ionic.requestAnimationFrame(function() {
            document.body.scrollTop = 0, scrollView.scrollTop = 0;
        }), window.navigator.msPointerEnabled ? document.addEventListener("MSPointerMove", keyboardPreventDefault, !1) : document.addEventListener("touchmove", keyboardPreventDefault, !1)), 
        (!ionic.keyboard.isOpen || ionic.keyboard.isClosing) && (ionic.keyboard.isOpening = !0, 
        ionic.keyboard.isClosing = !1), document.addEventListener("keydown", keyboardOnKeyDown, !1), 
        void (ionic.keyboard.isOpen || keyboardHasPlugin() ? ionic.keyboard.isOpen && keyboardShow() : keyboardWaitForResize(keyboardShow, !0))) : (keyboardActiveElement && (lastKeyboardActiveElement = keyboardActiveElement), 
        void (keyboardActiveElement = null));
    }
    function keyboardFocusOut() {
        clearTimeout(keyboardFocusOutTimer), (ionic.keyboard.isOpen || ionic.keyboard.isOpening) && (ionic.keyboard.isClosing = !0, 
        ionic.keyboard.isOpening = !1), keyboardFocusOutTimer = setTimeout(function() {
            ionic.requestAnimationFrame(function() {
                wasOrientationChange ? keyboardWaitForResize(function() {
                    keyboardUpdateViewportHeight(), keyboardHide();
                }, !1) : keyboardWaitForResize(keyboardHide, !1);
            });
        }, 50);
    }
    function keyboardOrientationChange() {
        ionic.keyboard.isLandscape = !ionic.keyboard.isLandscape, ionic.Platform.isIOS() && keyboardUpdateViewportHeight(), 
        ionic.Platform.isAndroid() && (ionic.keyboard.isOpen && keyboardHasPlugin() ? wasOrientationChange = !0 : keyboardWaitForResize(keyboardUpdateViewportHeight, !1));
    }
    function keyboardOnKeyDown(e) {
        ionic.scroll.isScrolling && keyboardPreventDefault(e);
    }
    function keyboardPreventDefault(e) {
        "TEXTAREA" !== e.target.tagName && e.preventDefault();
    }
    function keyboardWaitForResize(callback, isOpening) {
        clearInterval(waitForResizeTimer);
        var maxCount, count = 0, initialHeight = getViewportHeight(), viewportHeight = initialHeight;
        return maxCount = ionic.Platform.isAndroid() && ionic.Platform.version() < 4.4 ? 30 : ionic.Platform.isAndroid() ? 10 : 1, 
        waitForResizeTimer = setInterval(function() {
            viewportHeight = getViewportHeight(), (!(++count < maxCount) || (isPortraitViewportHeight(viewportHeight) || isLandscapeViewportHeight(viewportHeight)) && ionic.keyboard.height) && (keyboardHasPlugin() || (ionic.keyboard.height = Math.abs(initialHeight - window.innerHeight)), 
            ionic.keyboard.isOpen = isOpening, clearInterval(waitForResizeTimer), callback());
        }, 50), maxCount;
    }
    function keyboardHide() {
        clearTimeout(keyboardFocusOutTimer), ionic.keyboard.isOpen = !1, ionic.keyboard.isClosing = !1, 
        (keyboardActiveElement || lastKeyboardActiveElement) && ionic.trigger("resetScrollView", {
            target: keyboardActiveElement || lastKeyboardActiveElement
        }, !0), ionic.requestAnimationFrame(function() {
            document.body.classList.remove(KEYBOARD_OPEN_CSS);
        }), window.navigator.msPointerEnabled ? document.removeEventListener("MSPointerMove", keyboardPreventDefault) : document.removeEventListener("touchmove", keyboardPreventDefault), 
        document.removeEventListener("keydown", keyboardOnKeyDown), ionic.Platform.isAndroid() && (keyboardHasPlugin() && cordova.plugins.Keyboard.close(), 
        keyboardActiveElement && keyboardActiveElement.blur()), keyboardActiveElement = null, 
        lastKeyboardActiveElement = null;
    }
    function keyboardShow() {
        ionic.keyboard.isOpen = !0, ionic.keyboard.isOpening = !1;
        var details = {
            keyboardHeight: keyboardGetHeight(),
            viewportHeight: keyboardCurrentViewportHeight
        };
        if (keyboardActiveElement) {
            details.target = keyboardActiveElement;
            var elementBounds = keyboardActiveElement.getBoundingClientRect();
            details.elementTop = Math.round(elementBounds.top), details.elementBottom = Math.round(elementBounds.bottom), 
            details.windowHeight = details.viewportHeight - details.keyboardHeight, details.isElementUnderKeyboard = details.elementBottom > details.windowHeight, 
            ionic.trigger("scrollChildIntoView", details, !0);
        }
        return setTimeout(function() {
            document.body.classList.add(KEYBOARD_OPEN_CSS);
        }, 400), details;
    }
    function keyboardGetHeight() {
        if (ionic.keyboard.height) return ionic.keyboard.height;
        if (ionic.Platform.isAndroid()) {
            if (ionic.Platform.isFullScreen) return 275;
            var contentHeight = window.innerHeight;
            return keyboardCurrentViewportHeight > contentHeight ? keyboardCurrentViewportHeight - contentHeight : 0;
        }
        return ionic.Platform.isIOS() ? ionic.keyboard.isLandscape ? 206 : ionic.Platform.isWebView() ? 260 : 216 : 275;
    }
    function isPortraitViewportHeight(viewportHeight) {
        return !!(!ionic.keyboard.isLandscape && keyboardPortraitViewportHeight && Math.abs(keyboardPortraitViewportHeight - viewportHeight) < 2);
    }
    function isLandscapeViewportHeight(viewportHeight) {
        return !!(ionic.keyboard.isLandscape && keyboardLandscapeViewportHeight && Math.abs(keyboardLandscapeViewportHeight - viewportHeight) < 2);
    }
    function keyboardUpdateViewportHeight() {
        wasOrientationChange = !1, keyboardCurrentViewportHeight = getViewportHeight(), 
        ionic.keyboard.isLandscape && !keyboardLandscapeViewportHeight ? keyboardLandscapeViewportHeight = keyboardCurrentViewportHeight : ionic.keyboard.isLandscape || keyboardPortraitViewportHeight || (keyboardPortraitViewportHeight = keyboardCurrentViewportHeight), 
        keyboardActiveElement && ionic.trigger("resetScrollView", {
            target: keyboardActiveElement
        }, !0), ionic.keyboard.isOpen && ionic.tap.isTextInput(keyboardActiveElement) && keyboardShow();
    }
    function keyboardInitViewportHeight() {
        var viewportHeight = getViewportHeight();
        viewportHeight / window.innerWidth < 1 && (ionic.keyboard.isLandscape = !0), keyboardCurrentViewportHeight = viewportHeight, 
        ionic.keyboard.isLandscape && !keyboardLandscapeViewportHeight ? keyboardLandscapeViewportHeight = keyboardCurrentViewportHeight : ionic.keyboard.isLandscape || keyboardPortraitViewportHeight || (keyboardPortraitViewportHeight = keyboardCurrentViewportHeight);
    }
    function getViewportHeight() {
        var windowHeight = window.innerHeight;
        return ionic.Platform.isAndroid() && ionic.Platform.isFullScreen || !ionic.keyboard.isOpen && !ionic.keyboard.isOpening || ionic.keyboard.isClosing ? windowHeight : windowHeight + keyboardGetHeight();
    }
    function keyboardHasPlugin() {
        return !!(window.cordova && cordova.plugins && cordova.plugins.Keyboard);
    }
    function viewportLoadTag() {
        var x;
        for (x = 0; x < document.head.children.length; x++) if ("viewport" == document.head.children[x].name) {
            viewportTag = document.head.children[x];
            break;
        }
        if (viewportTag) {
            var keyValue, props = viewportTag.content.toLowerCase().replace(/\s+/g, "").split(",");
            for (x = 0; x < props.length; x++) props[x] && (keyValue = props[x].split("="), 
            viewportProperties[keyValue[0]] = keyValue.length > 1 ? keyValue[1] : "_");
            viewportUpdate();
        }
    }
    function viewportUpdate() {
        var initWidth = viewportProperties.width, initHeight = viewportProperties.height, p = ionic.Platform, version = p.version(), DEVICE_WIDTH = "device-width", DEVICE_HEIGHT = "device-height", orientation = ionic.viewport.orientation();
        delete viewportProperties.height, viewportProperties.width = DEVICE_WIDTH, p.isIPad() ? version > 7 ? delete viewportProperties.width : p.isWebView() ? 90 == orientation ? viewportProperties.height = "0" : 7 == version && (viewportProperties.height = DEVICE_HEIGHT) : 7 > version && (viewportProperties.height = "0") : p.isIOS() && (p.isWebView() ? version > 7 ? delete viewportProperties.width : 7 > version ? initHeight && (viewportProperties.height = "0") : 7 == version && (viewportProperties.height = DEVICE_HEIGHT) : 7 > version && initHeight && (viewportProperties.height = "0")), 
        (initWidth !== viewportProperties.width || initHeight !== viewportProperties.height) && viewportTagUpdate();
    }
    function viewportTagUpdate() {
        var key, props = [];
        for (key in viewportProperties) viewportProperties[key] && props.push(key + ("_" == viewportProperties[key] ? "" : "=" + viewportProperties[key]));
        viewportTag.content = props.join(", ");
    }
    window.ionic = window.ionic || {}, window.ionic.views = {}, window.ionic.version = "1.2.2", 
    function(ionic) {
        ionic.DelegateService = function(methodNames) {
            function trueFn() {
                return !0;
            }
            if (methodNames.indexOf("$getByHandle") > -1) throw new Error("Method '$getByHandle' is implicitly added to each delegate service. Do not list it as a method.");
            return [ "$log", function($log) {
                function DelegateInstance(instances, handle) {
                    this._instances = instances, this.handle = handle;
                }
                function DelegateService() {
                    this._instances = [];
                }
                function instanceMethodCaller(methodName) {
                    return function() {
                        var returnValue, handle = this.handle, args = arguments, foundInstancesCount = 0;
                        return this._instances.forEach(function(instance) {
                            if ((!handle || handle == instance.$$delegateHandle) && instance.$$filterFn(instance)) {
                                foundInstancesCount++;
                                var ret = instance[methodName].apply(instance, args);
                                1 === foundInstancesCount && (returnValue = ret);
                            }
                        }), !foundInstancesCount && handle ? $log.warn('Delegate for handle "' + handle + '" could not find a corresponding element with delegate-handle="' + handle + '"! ' + methodName + "() was not called!\nPossible cause: If you are calling " + methodName + '() immediately, and your element with delegate-handle="' + handle + '" is a child of your controller, then your element may not be compiled yet. Put a $timeout around your call to ' + methodName + "() and try again.") : returnValue;
                    };
                }
                return methodNames.forEach(function(methodName) {
                    DelegateInstance.prototype[methodName] = instanceMethodCaller(methodName);
                }), DelegateService.prototype = DelegateInstance.prototype, DelegateService.prototype._registerInstance = function(instance, handle, filterFn) {
                    var instances = this._instances;
                    return instance.$$delegateHandle = handle, instance.$$filterFn = filterFn || trueFn, 
                    instances.push(instance), function() {
                        var index = instances.indexOf(instance);
                        -1 !== index && instances.splice(index, 1);
                    };
                }, DelegateService.prototype.$getByHandle = function(handle) {
                    return new DelegateInstance(this._instances, handle);
                }, new DelegateService();
            } ];
        };
    }(window.ionic), function(window, document, ionic) {
        function domReady() {
            isDomReady = !0;
            for (var x = 0; x < readyCallbacks.length; x++) ionic.requestAnimationFrame(readyCallbacks[x]);
            readyCallbacks = [], document.removeEventListener("DOMContentLoaded", domReady);
        }
        var readyCallbacks = [], isDomReady = "complete" === document.readyState || "interactive" === document.readyState;
        isDomReady || document.addEventListener("DOMContentLoaded", domReady), window._rAF = function() {
            return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {
                window.setTimeout(callback, 16);
            };
        }();
        var cancelAnimationFrame = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelRequestAnimationFrame;
        ionic.DomUtil = {
            requestAnimationFrame: function(cb) {
                return window._rAF(cb);
            },
            cancelAnimationFrame: function(requestId) {
                cancelAnimationFrame(requestId);
            },
            animationFrameThrottle: function(cb) {
                var args, isQueued, context;
                return function() {
                    args = arguments, context = this, isQueued || (isQueued = !0, ionic.requestAnimationFrame(function() {
                        cb.apply(context, args), isQueued = !1;
                    }));
                };
            },
            contains: function(parentNode, otherNode) {
                for (var current = otherNode; current; ) {
                    if (current === parentNode) return !0;
                    current = current.parentNode;
                }
            },
            getPositionInParent: function(el) {
                return {
                    left: el.offsetLeft,
                    top: el.offsetTop
                };
            },
            getOffsetTop: function(el) {
                var curtop = 0;
                if (el.offsetParent) {
                    do curtop += el.offsetTop, el = el.offsetParent; while (el);
                    return curtop;
                }
            },
            ready: function(cb) {
                isDomReady ? ionic.requestAnimationFrame(cb) : readyCallbacks.push(cb);
            },
            getTextBounds: function(textNode) {
                if (document.createRange) {
                    var range = document.createRange();
                    if (range.selectNodeContents(textNode), range.getBoundingClientRect) {
                        var rect = range.getBoundingClientRect();
                        if (rect) {
                            var sx = window.scrollX, sy = window.scrollY;
                            return {
                                top: rect.top + sy,
                                left: rect.left + sx,
                                right: rect.left + sx + rect.width,
                                bottom: rect.top + sy + rect.height,
                                width: rect.width,
                                height: rect.height
                            };
                        }
                    }
                }
                return null;
            },
            getChildIndex: function(element, type) {
                if (type) for (var c, ch = element.parentNode.children, i = 0, k = 0, j = ch.length; j > i; i++) if (c = ch[i], 
                c.nodeName && c.nodeName.toLowerCase() == type) {
                    if (c == element) return k;
                    k++;
                }
                return Array.prototype.slice.call(element.parentNode.children).indexOf(element);
            },
            swapNodes: function(src, dest) {
                dest.parentNode.insertBefore(src, dest);
            },
            elementIsDescendant: function(el, parent, stopAt) {
                var current = el;
                do {
                    if (current === parent) return !0;
                    current = current.parentNode;
                } while (current && current !== stopAt);
                return !1;
            },
            getParentWithClass: function(e, className, depth) {
                for (depth = depth || 10; e.parentNode && depth--; ) {
                    if (e.parentNode.classList && e.parentNode.classList.contains(className)) return e.parentNode;
                    e = e.parentNode;
                }
                return null;
            },
            getParentOrSelfWithClass: function(e, className, depth) {
                for (depth = depth || 10; e && depth--; ) {
                    if (e.classList && e.classList.contains(className)) return e;
                    e = e.parentNode;
                }
                return null;
            },
            rectContains: function(x, y, x1, y1, x2, y2) {
                return x1 > x || x > x2 ? !1 : y1 > y || y > y2 ? !1 : !0;
            },
            blurAll: function() {
                return document.activeElement && document.activeElement != document.body ? (document.activeElement.blur(), 
                document.activeElement) : null;
            },
            cachedAttr: function(ele, key, value) {
                if (ele = ele && ele.length && ele[0] || ele, ele && ele.setAttribute) {
                    var dataKey = "$attr-" + key;
                    return arguments.length > 2 ? ele[dataKey] !== value && (ele.setAttribute(key, value), 
                    ele[dataKey] = value) : "undefined" == typeof ele[dataKey] && (ele[dataKey] = ele.getAttribute(key)), 
                    ele[dataKey];
                }
            },
            cachedStyles: function(ele, styles) {
                if (ele = ele && ele.length && ele[0] || ele, ele && ele.style) for (var prop in styles) ele["$style-" + prop] !== styles[prop] && (ele.style[prop] = ele["$style-" + prop] = styles[prop]);
            }
        }, ionic.requestAnimationFrame = ionic.DomUtil.requestAnimationFrame, ionic.cancelAnimationFrame = ionic.DomUtil.cancelAnimationFrame, 
        ionic.animationFrameThrottle = ionic.DomUtil.animationFrameThrottle;
    }(window, document, ionic), function(ionic) {
        ionic.CustomEvent = function() {
            if ("function" == typeof window.CustomEvent) return CustomEvent;
            var customEvent = function(event, params) {
                var evt;
                params = params || {
                    bubbles: !1,
                    cancelable: !1,
                    detail: void 0
                };
                try {
                    evt = document.createEvent("CustomEvent"), evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
                } catch (error) {
                    evt = document.createEvent("Event");
                    for (var param in params) evt[param] = params[param];
                    evt.initEvent(event, params.bubbles, params.cancelable);
                }
                return evt;
            };
            return customEvent.prototype = window.Event.prototype, customEvent;
        }(), ionic.EventController = {
            VIRTUALIZED_EVENTS: [ "tap", "swipe", "swiperight", "swipeleft", "drag", "hold", "release" ],
            trigger: function(eventType, data, bubbles, cancelable) {
                var event = new ionic.CustomEvent(eventType, {
                    detail: data,
                    bubbles: !!bubbles,
                    cancelable: !!cancelable
                });
                data && data.target && data.target.dispatchEvent && data.target.dispatchEvent(event) || window.dispatchEvent(event);
            },
            on: function(type, callback, element) {
                for (var e = element || window, i = 0, j = this.VIRTUALIZED_EVENTS.length; j > i; i++) if (type == this.VIRTUALIZED_EVENTS[i]) {
                    var gesture = new ionic.Gesture(element);
                    return gesture.on(type, callback), gesture;
                }
                e.addEventListener(type, callback);
            },
            off: function(type, callback, element) {
                element.removeEventListener(type, callback);
            },
            onGesture: function(type, callback, element, options) {
                var gesture = new ionic.Gesture(element, options);
                return gesture.on(type, callback), gesture;
            },
            offGesture: function(gesture, type, callback) {
                gesture && gesture.off(type, callback);
            },
            handlePopState: function() {}
        }, ionic.on = function() {
            ionic.EventController.on.apply(ionic.EventController, arguments);
        }, ionic.off = function() {
            ionic.EventController.off.apply(ionic.EventController, arguments);
        }, ionic.trigger = ionic.EventController.trigger, ionic.onGesture = function() {
            return ionic.EventController.onGesture.apply(ionic.EventController.onGesture, arguments);
        }, ionic.offGesture = function() {
            return ionic.EventController.offGesture.apply(ionic.EventController.offGesture, arguments);
        };
    }(window.ionic), function(ionic) {
        function setup() {
            if (!ionic.Gestures.READY) {
                ionic.Gestures.event.determineEventTypes();
                for (var name in ionic.Gestures.gestures) ionic.Gestures.gestures.hasOwnProperty(name) && ionic.Gestures.detection.register(ionic.Gestures.gestures[name]);
                ionic.Gestures.event.onTouch(ionic.Gestures.DOCUMENT, ionic.Gestures.EVENT_MOVE, ionic.Gestures.detection.detect), 
                ionic.Gestures.event.onTouch(ionic.Gestures.DOCUMENT, ionic.Gestures.EVENT_END, ionic.Gestures.detection.detect), 
                ionic.Gestures.READY = !0;
            }
        }
        ionic.Gesture = function(element, options) {
            return new ionic.Gestures.Instance(element, options || {});
        }, ionic.Gestures = {}, ionic.Gestures.defaults = {
            stop_browser_behavior: "disable-user-behavior"
        }, ionic.Gestures.HAS_POINTEREVENTS = window.navigator.pointerEnabled || window.navigator.msPointerEnabled, 
        ionic.Gestures.HAS_TOUCHEVENTS = "ontouchstart" in window, ionic.Gestures.MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android|silk/i, 
        ionic.Gestures.NO_MOUSEEVENTS = ionic.Gestures.HAS_TOUCHEVENTS && window.navigator.userAgent.match(ionic.Gestures.MOBILE_REGEX), 
        ionic.Gestures.EVENT_TYPES = {}, ionic.Gestures.DIRECTION_DOWN = "down", ionic.Gestures.DIRECTION_LEFT = "left", 
        ionic.Gestures.DIRECTION_UP = "up", ionic.Gestures.DIRECTION_RIGHT = "right", ionic.Gestures.POINTER_MOUSE = "mouse", 
        ionic.Gestures.POINTER_TOUCH = "touch", ionic.Gestures.POINTER_PEN = "pen", ionic.Gestures.EVENT_START = "start", 
        ionic.Gestures.EVENT_MOVE = "move", ionic.Gestures.EVENT_END = "end", ionic.Gestures.DOCUMENT = window.document, 
        ionic.Gestures.plugins = {}, ionic.Gestures.READY = !1, ionic.Gestures.Instance = function(element, options) {
            var self = this;
            return null === element ? this : (setup(), this.element = element, this.enabled = !0, 
            this.options = ionic.Gestures.utils.extend(ionic.Gestures.utils.extend({}, ionic.Gestures.defaults), options || {}), 
            this.options.stop_browser_behavior && ionic.Gestures.utils.stopDefaultBrowserBehavior(this.element, this.options.stop_browser_behavior), 
            ionic.Gestures.event.onTouch(element, ionic.Gestures.EVENT_START, function(ev) {
                self.enabled && ionic.Gestures.detection.startDetect(self, ev);
            }), this);
        }, ionic.Gestures.Instance.prototype = {
            on: function(gesture, handler) {
                for (var gestures = gesture.split(" "), t = 0; t < gestures.length; t++) this.element.addEventListener(gestures[t], handler, !1);
                return this;
            },
            off: function(gesture, handler) {
                for (var gestures = gesture.split(" "), t = 0; t < gestures.length; t++) this.element.removeEventListener(gestures[t], handler, !1);
                return this;
            },
            trigger: function(gesture, eventData) {
                var event = ionic.Gestures.DOCUMENT.createEvent("Event");
                event.initEvent(gesture, !0, !0), event.gesture = eventData;
                var element = this.element;
                return ionic.Gestures.utils.hasParent(eventData.target, element) && (element = eventData.target), 
                element.dispatchEvent(event), this;
            },
            enable: function(state) {
                return this.enabled = state, this;
            }
        };
        var last_move_event = null, enable_detect = !1, touch_triggered = !1;
        ionic.Gestures.event = {
            bindDom: function(element, type, handler) {
                for (var types = type.split(" "), t = 0; t < types.length; t++) element.addEventListener(types[t], handler, !1);
            },
            onTouch: function(element, eventType, handler) {
                var self = this;
                this.bindDom(element, ionic.Gestures.EVENT_TYPES[eventType], function(ev) {
                    var sourceEventType = ev.type.toLowerCase();
                    if (!sourceEventType.match(/mouse/) || !touch_triggered) {
                        sourceEventType.match(/touch/) || sourceEventType.match(/pointerdown/) || sourceEventType.match(/mouse/) && 1 === ev.which ? enable_detect = !0 : sourceEventType.match(/mouse/) && 1 !== ev.which && (enable_detect = !1), 
                        sourceEventType.match(/touch|pointer/) && (touch_triggered = !0);
                        var count_touches = 0;
                        enable_detect && (ionic.Gestures.HAS_POINTEREVENTS && eventType != ionic.Gestures.EVENT_END ? count_touches = ionic.Gestures.PointerEvent.updatePointer(eventType, ev) : sourceEventType.match(/touch/) ? count_touches = ev.touches.length : touch_triggered || (count_touches = sourceEventType.match(/up/) ? 0 : 1), 
                        count_touches > 0 && eventType == ionic.Gestures.EVENT_END ? eventType = ionic.Gestures.EVENT_MOVE : count_touches || (eventType = ionic.Gestures.EVENT_END), 
                        (count_touches || null === last_move_event) && (last_move_event = ev), handler.call(ionic.Gestures.detection, self.collectEventData(element, eventType, self.getTouchList(last_move_event, eventType), ev)), 
                        ionic.Gestures.HAS_POINTEREVENTS && eventType == ionic.Gestures.EVENT_END && (count_touches = ionic.Gestures.PointerEvent.updatePointer(eventType, ev))), 
                        count_touches || (last_move_event = null, enable_detect = !1, touch_triggered = !1, 
                        ionic.Gestures.PointerEvent.reset());
                    }
                });
            },
            determineEventTypes: function() {
                var types;
                types = ionic.Gestures.HAS_POINTEREVENTS ? ionic.Gestures.PointerEvent.getEvents() : ionic.Gestures.NO_MOUSEEVENTS ? [ "touchstart", "touchmove", "touchend touchcancel" ] : [ "touchstart mousedown", "touchmove mousemove", "touchend touchcancel mouseup" ], 
                ionic.Gestures.EVENT_TYPES[ionic.Gestures.EVENT_START] = types[0], ionic.Gestures.EVENT_TYPES[ionic.Gestures.EVENT_MOVE] = types[1], 
                ionic.Gestures.EVENT_TYPES[ionic.Gestures.EVENT_END] = types[2];
            },
            getTouchList: function(ev) {
                return ionic.Gestures.HAS_POINTEREVENTS ? ionic.Gestures.PointerEvent.getTouchList() : ev.touches ? ev.touches : (ev.identifier = 1, 
                [ ev ]);
            },
            collectEventData: function(element, eventType, touches, ev) {
                var pointerType = ionic.Gestures.POINTER_TOUCH;
                return (ev.type.match(/mouse/) || ionic.Gestures.PointerEvent.matchType(ionic.Gestures.POINTER_MOUSE, ev)) && (pointerType = ionic.Gestures.POINTER_MOUSE), 
                {
                    center: ionic.Gestures.utils.getCenter(touches),
                    timeStamp: new Date().getTime(),
                    target: ev.target,
                    touches: touches,
                    eventType: eventType,
                    pointerType: pointerType,
                    srcEvent: ev,
                    preventDefault: function() {
                        this.srcEvent.preventManipulation && this.srcEvent.preventManipulation(), this.srcEvent.preventDefault;
                    },
                    stopPropagation: function() {
                        this.srcEvent.stopPropagation();
                    },
                    stopDetect: function() {
                        return ionic.Gestures.detection.stopDetect();
                    }
                };
            }
        }, ionic.Gestures.PointerEvent = {
            pointers: {},
            getTouchList: function() {
                var self = this, touchlist = [];
                return Object.keys(self.pointers).sort().forEach(function(id) {
                    touchlist.push(self.pointers[id]);
                }), touchlist;
            },
            updatePointer: function(type, pointerEvent) {
                return type == ionic.Gestures.EVENT_END ? this.pointers = {} : (pointerEvent.identifier = pointerEvent.pointerId, 
                this.pointers[pointerEvent.pointerId] = pointerEvent), Object.keys(this.pointers).length;
            },
            matchType: function(pointerType, ev) {
                if (!ev.pointerType) return !1;
                var types = {};
                return types[ionic.Gestures.POINTER_MOUSE] = ev.pointerType == ev.MSPOINTER_TYPE_MOUSE || ev.pointerType == ionic.Gestures.POINTER_MOUSE, 
                types[ionic.Gestures.POINTER_TOUCH] = ev.pointerType == ev.MSPOINTER_TYPE_TOUCH || ev.pointerType == ionic.Gestures.POINTER_TOUCH, 
                types[ionic.Gestures.POINTER_PEN] = ev.pointerType == ev.MSPOINTER_TYPE_PEN || ev.pointerType == ionic.Gestures.POINTER_PEN, 
                types[pointerType];
            },
            getEvents: function() {
                return [ "pointerdown MSPointerDown", "pointermove MSPointerMove", "pointerup pointercancel MSPointerUp MSPointerCancel" ];
            },
            reset: function() {
                this.pointers = {};
            }
        }, ionic.Gestures.utils = {
            extend: function(dest, src, merge) {
                for (var key in src) void 0 !== dest[key] && merge || (dest[key] = src[key]);
                return dest;
            },
            hasParent: function(node, parent) {
                for (;node; ) {
                    if (node == parent) return !0;
                    node = node.parentNode;
                }
                return !1;
            },
            getCenter: function(touches) {
                for (var valuesX = [], valuesY = [], t = 0, len = touches.length; len > t; t++) valuesX.push(touches[t].pageX), 
                valuesY.push(touches[t].pageY);
                return {
                    pageX: (Math.min.apply(Math, valuesX) + Math.max.apply(Math, valuesX)) / 2,
                    pageY: (Math.min.apply(Math, valuesY) + Math.max.apply(Math, valuesY)) / 2
                };
            },
            getVelocity: function(delta_time, delta_x, delta_y) {
                return {
                    x: Math.abs(delta_x / delta_time) || 0,
                    y: Math.abs(delta_y / delta_time) || 0
                };
            },
            getAngle: function(touch1, touch2) {
                var y = touch2.pageY - touch1.pageY, x = touch2.pageX - touch1.pageX;
                return 180 * Math.atan2(y, x) / Math.PI;
            },
            getDirection: function(touch1, touch2) {
                var x = Math.abs(touch1.pageX - touch2.pageX), y = Math.abs(touch1.pageY - touch2.pageY);
                return x >= y ? touch1.pageX - touch2.pageX > 0 ? ionic.Gestures.DIRECTION_LEFT : ionic.Gestures.DIRECTION_RIGHT : touch1.pageY - touch2.pageY > 0 ? ionic.Gestures.DIRECTION_UP : ionic.Gestures.DIRECTION_DOWN;
            },
            getDistance: function(touch1, touch2) {
                var x = touch2.pageX - touch1.pageX, y = touch2.pageY - touch1.pageY;
                return Math.sqrt(x * x + y * y);
            },
            getScale: function(start, end) {
                return start.length >= 2 && end.length >= 2 ? this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]) : 1;
            },
            getRotation: function(start, end) {
                return start.length >= 2 && end.length >= 2 ? this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]) : 0;
            },
            isVertical: function(direction) {
                return direction == ionic.Gestures.DIRECTION_UP || direction == ionic.Gestures.DIRECTION_DOWN;
            },
            stopDefaultBrowserBehavior: function(element, css_class) {
                element && element.classList && (element.classList.add(css_class), element.onselectstart = function() {
                    return !1;
                });
            }
        }, ionic.Gestures.detection = {
            gestures: [],
            current: null,
            previous: null,
            stopped: !1,
            startDetect: function(inst, eventData) {
                this.current || (this.stopped = !1, this.current = {
                    inst: inst,
                    startEvent: ionic.Gestures.utils.extend({}, eventData),
                    lastEvent: !1,
                    name: ""
                }, this.detect(eventData));
            },
            detect: function(eventData) {
                if (!this.current || this.stopped) return null;
                eventData = this.extendEventData(eventData);
                for (var inst_options = this.current.inst.options, g = 0, len = this.gestures.length; len > g; g++) {
                    var gesture = this.gestures[g];
                    if (!this.stopped && inst_options[gesture.name] !== !1 && gesture.handler.call(gesture, eventData, this.current.inst) === !1) {
                        this.stopDetect();
                        break;
                    }
                }
                return this.current && (this.current.lastEvent = eventData), eventData.eventType == ionic.Gestures.EVENT_END && !eventData.touches.length - 1 && this.stopDetect(), 
                eventData;
            },
            stopDetect: function() {
                this.previous = ionic.Gestures.utils.extend({}, this.current), this.current = null, 
                this.stopped = !0;
            },
            extendEventData: function(ev) {
                var startEv = this.current.startEvent;
                if (startEv && (ev.touches.length != startEv.touches.length || ev.touches === startEv.touches)) {
                    startEv.touches = [];
                    for (var i = 0, len = ev.touches.length; len > i; i++) startEv.touches.push(ionic.Gestures.utils.extend({}, ev.touches[i]));
                }
                var delta_time = ev.timeStamp - startEv.timeStamp, delta_x = ev.center.pageX - startEv.center.pageX, delta_y = ev.center.pageY - startEv.center.pageY, velocity = ionic.Gestures.utils.getVelocity(delta_time, delta_x, delta_y);
                return ionic.Gestures.utils.extend(ev, {
                    deltaTime: delta_time,
                    deltaX: delta_x,
                    deltaY: delta_y,
                    velocityX: velocity.x,
                    velocityY: velocity.y,
                    distance: ionic.Gestures.utils.getDistance(startEv.center, ev.center),
                    angle: ionic.Gestures.utils.getAngle(startEv.center, ev.center),
                    direction: ionic.Gestures.utils.getDirection(startEv.center, ev.center),
                    scale: ionic.Gestures.utils.getScale(startEv.touches, ev.touches),
                    rotation: ionic.Gestures.utils.getRotation(startEv.touches, ev.touches),
                    startEvent: startEv
                }), ev;
            },
            register: function(gesture) {
                var options = gesture.defaults || {};
                return void 0 === options[gesture.name] && (options[gesture.name] = !0), ionic.Gestures.utils.extend(ionic.Gestures.defaults, options, !0), 
                gesture.index = gesture.index || 1e3, this.gestures.push(gesture), this.gestures.sort(function(a, b) {
                    return a.index < b.index ? -1 : a.index > b.index ? 1 : 0;
                }), this.gestures;
            }
        }, ionic.Gestures.gestures = ionic.Gestures.gestures || {}, ionic.Gestures.gestures.Hold = {
            name: "hold",
            index: 10,
            defaults: {
                hold_timeout: 500,
                hold_threshold: 9
            },
            timer: null,
            handler: function(ev, inst) {
                switch (ev.eventType) {
                  case ionic.Gestures.EVENT_START:
                    clearTimeout(this.timer), ionic.Gestures.detection.current.name = this.name, this.timer = setTimeout(function() {
                        "hold" == ionic.Gestures.detection.current.name && (ionic.tap.cancelClick(), inst.trigger("hold", ev));
                    }, inst.options.hold_timeout);
                    break;

                  case ionic.Gestures.EVENT_MOVE:
                    ev.distance > inst.options.hold_threshold && clearTimeout(this.timer);
                    break;

                  case ionic.Gestures.EVENT_END:
                    clearTimeout(this.timer);
                }
            }
        }, ionic.Gestures.gestures.Tap = {
            name: "tap",
            index: 100,
            defaults: {
                tap_max_touchtime: 250,
                tap_max_distance: 10,
                tap_always: !0,
                doubletap_distance: 20,
                doubletap_interval: 300
            },
            handler: function(ev, inst) {
                if (ev.eventType == ionic.Gestures.EVENT_END && "touchcancel" != ev.srcEvent.type) {
                    var prev = ionic.Gestures.detection.previous, did_doubletap = !1;
                    if (ev.deltaTime > inst.options.tap_max_touchtime || ev.distance > inst.options.tap_max_distance) return;
                    prev && "tap" == prev.name && ev.timeStamp - prev.lastEvent.timeStamp < inst.options.doubletap_interval && ev.distance < inst.options.doubletap_distance && (inst.trigger("doubletap", ev), 
                    did_doubletap = !0), (!did_doubletap || inst.options.tap_always) && (ionic.Gestures.detection.current.name = "tap", 
                    inst.trigger("tap", ev));
                }
            }
        }, ionic.Gestures.gestures.Swipe = {
            name: "swipe",
            index: 40,
            defaults: {
                swipe_max_touches: 1,
                swipe_velocity: .4
            },
            handler: function(ev, inst) {
                if (ev.eventType == ionic.Gestures.EVENT_END) {
                    if (inst.options.swipe_max_touches > 0 && ev.touches.length > inst.options.swipe_max_touches) return;
                    (ev.velocityX > inst.options.swipe_velocity || ev.velocityY > inst.options.swipe_velocity) && (inst.trigger(this.name, ev), 
                    inst.trigger(this.name + ev.direction, ev));
                }
            }
        }, ionic.Gestures.gestures.Drag = {
            name: "drag",
            index: 50,
            defaults: {
                drag_min_distance: 10,
                correct_for_drag_min_distance: !0,
                drag_max_touches: 1,
                drag_block_horizontal: !0,
                drag_block_vertical: !0,
                drag_lock_to_axis: !1,
                drag_lock_min_distance: 25,
                prevent_default_directions: []
            },
            triggered: !1,
            handler: function(ev, inst) {
                if ("touchstart" == ev.srcEvent.type || "touchend" == ev.srcEvent.type ? this.preventedFirstMove = !1 : this.preventedFirstMove || "touchmove" != ev.srcEvent.type || (inst.options.prevent_default_directions.length > 0 && -1 != inst.options.prevent_default_directions.indexOf(ev.direction) && ev.srcEvent.preventDefault(), 
                this.preventedFirstMove = !0), ionic.Gestures.detection.current.name != this.name && this.triggered) return inst.trigger(this.name + "end", ev), 
                void (this.triggered = !1);
                if (!(inst.options.drag_max_touches > 0 && ev.touches.length > inst.options.drag_max_touches)) switch (ev.eventType) {
                  case ionic.Gestures.EVENT_START:
                    this.triggered = !1;
                    break;

                  case ionic.Gestures.EVENT_MOVE:
                    if (ev.distance < inst.options.drag_min_distance && ionic.Gestures.detection.current.name != this.name) return;
                    if (ionic.Gestures.detection.current.name != this.name && (ionic.Gestures.detection.current.name = this.name, 
                    inst.options.correct_for_drag_min_distance)) {
                        var factor = Math.abs(inst.options.drag_min_distance / ev.distance);
                        ionic.Gestures.detection.current.startEvent.center.pageX += ev.deltaX * factor, 
                        ionic.Gestures.detection.current.startEvent.center.pageY += ev.deltaY * factor, 
                        ev = ionic.Gestures.detection.extendEventData(ev);
                    }
                    (ionic.Gestures.detection.current.lastEvent.drag_locked_to_axis || inst.options.drag_lock_to_axis && inst.options.drag_lock_min_distance <= ev.distance) && (ev.drag_locked_to_axis = !0);
                    var last_direction = ionic.Gestures.detection.current.lastEvent.direction;
                    ev.drag_locked_to_axis && last_direction !== ev.direction && (ionic.Gestures.utils.isVertical(last_direction) ? ev.direction = ev.deltaY < 0 ? ionic.Gestures.DIRECTION_UP : ionic.Gestures.DIRECTION_DOWN : ev.direction = ev.deltaX < 0 ? ionic.Gestures.DIRECTION_LEFT : ionic.Gestures.DIRECTION_RIGHT), 
                    this.triggered || (inst.trigger(this.name + "start", ev), this.triggered = !0), 
                    inst.trigger(this.name, ev), inst.trigger(this.name + ev.direction, ev), (inst.options.drag_block_vertical && ionic.Gestures.utils.isVertical(ev.direction) || inst.options.drag_block_horizontal && !ionic.Gestures.utils.isVertical(ev.direction)) && ev.preventDefault();
                    break;

                  case ionic.Gestures.EVENT_END:
                    this.triggered && inst.trigger(this.name + "end", ev), this.triggered = !1;
                }
            }
        }, ionic.Gestures.gestures.Transform = {
            name: "transform",
            index: 45,
            defaults: {
                transform_min_scale: .01,
                transform_min_rotation: 1,
                transform_always_block: !1
            },
            triggered: !1,
            handler: function(ev, inst) {
                if (ionic.Gestures.detection.current.name != this.name && this.triggered) return inst.trigger(this.name + "end", ev), 
                void (this.triggered = !1);
                if (!(ev.touches.length < 2)) switch (inst.options.transform_always_block && ev.preventDefault(), 
                ev.eventType) {
                  case ionic.Gestures.EVENT_START:
                    this.triggered = !1;
                    break;

                  case ionic.Gestures.EVENT_MOVE:
                    var scale_threshold = Math.abs(1 - ev.scale), rotation_threshold = Math.abs(ev.rotation);
                    if (scale_threshold < inst.options.transform_min_scale && rotation_threshold < inst.options.transform_min_rotation) return;
                    ionic.Gestures.detection.current.name = this.name, this.triggered || (inst.trigger(this.name + "start", ev), 
                    this.triggered = !0), inst.trigger(this.name, ev), rotation_threshold > inst.options.transform_min_rotation && inst.trigger("rotate", ev), 
                    scale_threshold > inst.options.transform_min_scale && (inst.trigger("pinch", ev), 
                    inst.trigger("pinch" + (ev.scale < 1 ? "in" : "out"), ev));
                    break;

                  case ionic.Gestures.EVENT_END:
                    this.triggered && inst.trigger(this.name + "end", ev), this.triggered = !1;
                }
            }
        }, ionic.Gestures.gestures.Touch = {
            name: "touch",
            index: -(1 / 0),
            defaults: {
                prevent_default: !1,
                prevent_mouseevents: !1
            },
            handler: function(ev, inst) {
                return inst.options.prevent_mouseevents && ev.pointerType == ionic.Gestures.POINTER_MOUSE ? void ev.stopDetect() : (inst.options.prevent_default && ev.preventDefault(), 
                void (ev.eventType == ionic.Gestures.EVENT_START && inst.trigger(this.name, ev)));
            }
        }, ionic.Gestures.gestures.Release = {
            name: "release",
            index: 1 / 0,
            handler: function(ev, inst) {
                ev.eventType == ionic.Gestures.EVENT_END && inst.trigger(this.name, ev);
            }
        };
    }(window.ionic), function(window, document, ionic) {
        function getParameterByName(name) {
            name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
            var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"), results = regex.exec(location.search);
            return null === results ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
        }
        function verifyPlatformReady() {
            setTimeout(function() {
                !self.isReady && self.isWebView();
            }, platformReadyTimer);
        }
        function onWindowLoad() {
            self.isWebView() ? document.addEventListener("deviceready", onPlatformReady, !1) : onPlatformReady(), 
            windowLoadListenderAttached && window.removeEventListener("load", onWindowLoad, !1);
        }
        function onPlatformReady() {
            self.isReady = !0, self.detect();
            for (var x = 0; x < readyCallbacks.length; x++) readyCallbacks[x]();
            readyCallbacks = [], ionic.trigger("platformready", {
                target: document
            }), requestAnimationFrame(function() {
                document.body.classList.add("platform-ready");
            });
        }
        var windowLoadListenderAttached, IOS = "ios", ANDROID = "android", WINDOWS_PHONE = "windowsphone", EDGE = "edge", CROSSWALK = "crosswalk", requestAnimationFrame = ionic.requestAnimationFrame, self = ionic.Platform = {
            navigator: window.navigator,
            isReady: !1,
            isFullScreen: !1,
            platforms: null,
            grade: null,
            ua: navigator.userAgent,
            ready: function(cb) {
                self.isReady ? cb() : readyCallbacks.push(cb);
            },
            detect: function() {
                self._checkPlatforms(), requestAnimationFrame(function() {
                    for (var i = 0; i < self.platforms.length; i++) document.body.classList.add("platform-" + self.platforms[i]);
                });
            },
            setGrade: function(grade) {
                var oldGrade = self.grade;
                self.grade = grade, requestAnimationFrame(function() {
                    oldGrade && document.body.classList.remove("grade-" + oldGrade), document.body.classList.add("grade-" + grade);
                });
            },
            device: function() {
                return window.device || {};
            },
            _checkPlatforms: function() {
                self.platforms = [];
                var grade = "a";
                self.isWebView() ? (self.platforms.push("webview"), window.cordova || window.PhoneGap || window.phonegap ? self.platforms.push("cordova") : window.forge && self.platforms.push("trigger")) : self.platforms.push("browser"), 
                self.isIPad() && self.platforms.push("ipad");
                var platform = self.platform();
                if (platform) {
                    self.platforms.push(platform);
                    var version = self.version();
                    if (version) {
                        var v = version.toString();
                        v.indexOf(".") > 0 ? v = v.replace(".", "_") : v += "_0", self.platforms.push(platform + v.split("_")[0]), 
                        self.platforms.push(platform + v), self.isAndroid() && 4.4 > version ? grade = 4 > version ? "c" : "b" : self.isWindowsPhone() && (grade = "b");
                    }
                }
                self.setGrade(grade);
            },
            isWebView: function() {
                return !!(window.cordova || window.PhoneGap || window.phonegap || window.forge);
            },
            isIPad: function() {
                return /iPad/i.test(self.navigator.platform) ? !0 : /iPad/i.test(self.ua);
            },
            isIOS: function() {
                return self.is(IOS);
            },
            isAndroid: function() {
                return self.is(ANDROID);
            },
            isWindowsPhone: function() {
                return self.is(WINDOWS_PHONE);
            },
            isEdge: function() {
                return self.is(EDGE);
            },
            isCrosswalk: function() {
                return self.is(CROSSWALK);
            },
            platform: function() {
                return null === platformName && self.setPlatform(self.device().platform), platformName;
            },
            setPlatform: function(n) {
                platformName = "undefined" != typeof n && null !== n && n.length ? n.toLowerCase() : getParameterByName("ionicplatform") ? getParameterByName("ionicplatform") : self.ua.indexOf("Edge") > -1 ? EDGE : self.ua.indexOf("Windows Phone") > -1 ? WINDOWS_PHONE : self.ua.indexOf("Android") > 0 ? ANDROID : /iPhone|iPad|iPod/.test(self.ua) ? IOS : self.navigator.platform && navigator.platform.toLowerCase().split(" ")[0] || "";
            },
            version: function() {
                return null === platformVersion && self.setVersion(self.device().version), platformVersion;
            },
            setVersion: function(v) {
                if ("undefined" != typeof v && null !== v && (v = v.split("."), v = parseFloat(v[0] + "." + (v.length > 1 ? v[1] : 0)), 
                !isNaN(v))) return void (platformVersion = v);
                platformVersion = 0;
                var pName = self.platform(), versionMatch = {
                    android: /Android (\d+).(\d+)?/,
                    ios: /OS (\d+)_(\d+)?/,
                    windowsphone: /Windows Phone (\d+).(\d+)?/
                };
                versionMatch[pName] && (v = self.ua.match(versionMatch[pName]), v && v.length > 2 && (platformVersion = parseFloat(v[1] + "." + v[2])));
            },
            is: function(type) {
                if (type = type.toLowerCase(), self.platforms) for (var x = 0; x < self.platforms.length; x++) if (self.platforms[x] === type) return !0;
                var pName = self.platform();
                return pName ? pName === type.toLowerCase() : self.ua.toLowerCase().indexOf(type) >= 0;
            },
            exitApp: function() {
                self.ready(function() {
                    navigator.app && navigator.app.exitApp && navigator.app.exitApp();
                });
            },
            showStatusBar: function(val) {
                self._showStatusBar = val, self.ready(function() {
                    requestAnimationFrame(function() {
                        self._showStatusBar ? (window.StatusBar && window.StatusBar.show(), document.body.classList.remove("status-bar-hide")) : (window.StatusBar && window.StatusBar.hide(), 
                        document.body.classList.add("status-bar-hide"));
                    });
                });
            },
            fullScreen: function(showFullScreen, showStatusBar) {
                self.isFullScreen = showFullScreen !== !1, ionic.DomUtil.ready(function() {
                    requestAnimationFrame(function() {
                        self.isFullScreen ? document.body.classList.add("fullscreen") : document.body.classList.remove("fullscreen");
                    }), self.showStatusBar(showStatusBar === !0);
                });
            }
        }, platformName = null, platformVersion = null, readyCallbacks = [], platformReadyTimer = 2e3;
        verifyPlatformReady(), "complete" === document.readyState ? onWindowLoad() : (windowLoadListenderAttached = !0, 
        window.addEventListener("load", onWindowLoad, !1));
    }(window, document, ionic), function(document, ionic) {
        "use strict";
        ionic.CSS = {}, ionic.CSS.TRANSITION = [], ionic.CSS.TRANSFORM = [], ionic.EVENTS = {}, 
        function() {
            var i, keys = [ "webkitTransform", "transform", "-webkit-transform", "webkit-transform", "-moz-transform", "moz-transform", "MozTransform", "mozTransform", "msTransform" ];
            for (i = 0; i < keys.length; i++) if (void 0 !== document.documentElement.style[keys[i]]) {
                ionic.CSS.TRANSFORM = keys[i];
                break;
            }
            for (keys = [ "webkitTransition", "mozTransition", "msTransition", "transition" ], 
            i = 0; i < keys.length; i++) if (void 0 !== document.documentElement.style[keys[i]]) {
                ionic.CSS.TRANSITION = keys[i];
                break;
            }
            ionic.CSS.TRANSITION = ionic.CSS.TRANSITION || "transition";
            var isWebkit = ionic.CSS.TRANSITION.indexOf("webkit") > -1;
            ionic.CSS.TRANSITION_DURATION = (isWebkit ? "-webkit-" : "") + "transition-duration", 
            ionic.CSS.TRANSITIONEND = (isWebkit ? "webkitTransitionEnd " : "") + "transitionend";
        }(), function() {
            var touchStartEvent = "touchstart", touchMoveEvent = "touchmove", touchEndEvent = "touchend", touchCancelEvent = "touchcancel";
            window.navigator.pointerEnabled ? (touchStartEvent = "pointerdown", touchMoveEvent = "pointermove", 
            touchEndEvent = "pointerup", touchCancelEvent = "pointercancel") : window.navigator.msPointerEnabled && (touchStartEvent = "MSPointerDown", 
            touchMoveEvent = "MSPointerMove", touchEndEvent = "MSPointerUp", touchCancelEvent = "MSPointerCancel"), 
            ionic.EVENTS.touchstart = touchStartEvent, ionic.EVENTS.touchmove = touchMoveEvent, 
            ionic.EVENTS.touchend = touchEndEvent, ionic.EVENTS.touchcancel = touchCancelEvent;
        }(), "classList" in document.documentElement || !Object.defineProperty || "undefined" == typeof HTMLElement || Object.defineProperty(HTMLElement.prototype, "classList", {
            get: function() {
                function update(fn) {
                    return function() {
                        var x, classes = self.className.split(/\s+/);
                        for (x = 0; x < arguments.length; x++) fn(classes, classes.indexOf(arguments[x]), arguments[x]);
                        self.className = classes.join(" ");
                    };
                }
                var self = this;
                return {
                    add: update(function(classes, index, value) {
                        ~index || classes.push(value);
                    }),
                    remove: update(function(classes, index) {
                        ~index && classes.splice(index, 1);
                    }),
                    toggle: update(function(classes, index, value) {
                        ~index ? classes.splice(index, 1) : classes.push(value);
                    }),
                    contains: function(value) {
                        return !!~self.className.split(/\s+/).indexOf(value);
                    },
                    item: function(i) {
                        return self.className.split(/\s+/)[i] || null;
                    }
                };
            }
        });
    }(document, ionic);
    var tapDoc, tapActiveEle, tapEnabledTouchEvents, tapMouseResetTimer, tapPointerMoved, tapPointerStart, tapTouchFocusedInput, tapLastTouchTarget, tapTouchMoveListener = "touchmove", TAP_RELEASE_TOLERANCE = 12, TAP_RELEASE_BUTTON_TOLERANCE = 50, tapEventListeners = {
        click: tapClickGateKeeper,
        mousedown: tapMouseDown,
        mouseup: tapMouseUp,
        mousemove: tapMouseMove,
        touchstart: tapTouchStart,
        touchend: tapTouchEnd,
        touchcancel: tapTouchCancel,
        touchmove: tapTouchMove,
        pointerdown: tapTouchStart,
        pointerup: tapTouchEnd,
        pointercancel: tapTouchCancel,
        pointermove: tapTouchMove,
        MSPointerDown: tapTouchStart,
        MSPointerUp: tapTouchEnd,
        MSPointerCancel: tapTouchCancel,
        MSPointerMove: tapTouchMove,
        focusin: tapFocusIn,
        focusout: tapFocusOut
    };
    ionic.tap = {
        register: function(ele) {
            return tapDoc = ele, tapEventListener("click", !0, !0), tapEventListener("mouseup"), 
            tapEventListener("mousedown"), window.navigator.pointerEnabled ? (tapEventListener("pointerdown"), 
            tapEventListener("pointerup"), tapEventListener("pointercancel"), tapTouchMoveListener = "pointermove") : window.navigator.msPointerEnabled ? (tapEventListener("MSPointerDown"), 
            tapEventListener("MSPointerUp"), tapEventListener("MSPointerCancel"), tapTouchMoveListener = "MSPointerMove") : (tapEventListener("touchstart"), 
            tapEventListener("touchend"), tapEventListener("touchcancel")), tapEventListener("focusin"), 
            tapEventListener("focusout"), function() {
                for (var type in tapEventListeners) tapEventListener(type, !1);
                tapDoc = null, tapActiveEle = null, tapEnabledTouchEvents = !1, tapPointerMoved = !1, 
                tapPointerStart = null;
            };
        },
        ignoreScrollStart: function(e) {
            return e.defaultPrevented || /^(file|range)$/i.test(e.target.type) || "true" == (e.target.dataset ? e.target.dataset.preventScroll : e.target.getAttribute("data-prevent-scroll")) || !!/^(object|embed)$/i.test(e.target.tagName) || ionic.tap.isElementTapDisabled(e.target);
        },
        isTextInput: function(ele) {
            return !!ele && ("TEXTAREA" == ele.tagName || "true" === ele.contentEditable || "INPUT" == ele.tagName && !/^(radio|checkbox|range|file|submit|reset|color|image|button)$/i.test(ele.type));
        },
        isDateInput: function(ele) {
            return !!ele && "INPUT" == ele.tagName && /^(date|time|datetime-local|month|week)$/i.test(ele.type);
        },
        isVideo: function(ele) {
            return !!ele && "VIDEO" == ele.tagName;
        },
        isKeyboardElement: function(ele) {
            return !ionic.Platform.isIOS() || ionic.Platform.isIPad() ? ionic.tap.isTextInput(ele) && !ionic.tap.isDateInput(ele) : ionic.tap.isTextInput(ele) || !!ele && "SELECT" == ele.tagName;
        },
        isLabelWithTextInput: function(ele) {
            var container = tapContainingElement(ele, !1);
            return !!container && ionic.tap.isTextInput(tapTargetElement(container));
        },
        containsOrIsTextInput: function(ele) {
            return ionic.tap.isTextInput(ele) || ionic.tap.isLabelWithTextInput(ele);
        },
        cloneFocusedInput: function(container) {
            ionic.tap.hasCheckedClone || (ionic.tap.hasCheckedClone = !0, ionic.requestAnimationFrame(function() {
                var focusInput = container.querySelector(":focus");
                if (ionic.tap.isTextInput(focusInput) && !ionic.tap.isDateInput(focusInput)) {
                    var clonedInput = focusInput.cloneNode(!0);
                    clonedInput.value = focusInput.value, clonedInput.classList.add("cloned-text-input"), 
                    clonedInput.readOnly = !0, focusInput.isContentEditable && (clonedInput.contentEditable = focusInput.contentEditable, 
                    clonedInput.innerHTML = focusInput.innerHTML), focusInput.parentElement.insertBefore(clonedInput, focusInput), 
                    focusInput.classList.add("previous-input-focus"), clonedInput.scrollTop = focusInput.scrollTop;
                }
            }));
        },
        hasCheckedClone: !1,
        removeClonedInputs: function(container) {
            ionic.tap.hasCheckedClone = !1, ionic.requestAnimationFrame(function() {
                var x, clonedInputs = container.querySelectorAll(".cloned-text-input"), previousInputFocus = container.querySelectorAll(".previous-input-focus");
                for (x = 0; x < clonedInputs.length; x++) clonedInputs[x].parentElement.removeChild(clonedInputs[x]);
                for (x = 0; x < previousInputFocus.length; x++) previousInputFocus[x].classList.remove("previous-input-focus"), 
                previousInputFocus[x].style.top = "", ionic.keyboard.isOpen && !ionic.keyboard.isClosing && previousInputFocus[x].focus();
            });
        },
        requiresNativeClick: function(ele) {
            return ionic.Platform.isWindowsPhone() && ("A" == ele.tagName || "BUTTON" == ele.tagName || ele.hasAttribute("ng-click") || "INPUT" == ele.tagName && ("button" == ele.type || "submit" == ele.type)) ? !0 : !ele || ele.disabled || /^(file|range)$/i.test(ele.type) || /^(object|video)$/i.test(ele.tagName) || ionic.tap.isLabelContainingFileInput(ele) ? !0 : ionic.tap.isElementTapDisabled(ele);
        },
        isLabelContainingFileInput: function(ele) {
            var lbl = tapContainingElement(ele);
            if ("LABEL" !== lbl.tagName) return !1;
            var fileInput = lbl.querySelector("input[type=file]");
            return fileInput && fileInput.disabled === !1 ? !0 : !1;
        },
        isElementTapDisabled: function(ele) {
            if (ele && 1 === ele.nodeType) for (var element = ele; element; ) {
                if ("true" == (element.dataset ? element.dataset.tapDisabled : element.getAttribute && element.getAttribute("data-tap-disabled"))) return !0;
                element = element.parentElement;
            }
            return !1;
        },
        setTolerance: function(releaseTolerance, releaseButtonTolerance) {
            TAP_RELEASE_TOLERANCE = releaseTolerance, TAP_RELEASE_BUTTON_TOLERANCE = releaseButtonTolerance;
        },
        cancelClick: function() {
            tapPointerMoved = !0;
        },
        pointerCoord: function(event) {
            var c = {
                x: 0,
                y: 0
            };
            if (event) {
                var touches = event.touches && event.touches.length ? event.touches : [ event ], e = event.changedTouches && event.changedTouches[0] || touches[0];
                e && (c.x = e.clientX || e.pageX || 0, c.y = e.clientY || e.pageY || 0);
            }
            return c;
        }
    }, ionic.DomUtil.ready(function() {
        var ng = "undefined" != typeof angular ? angular : null;
        (!ng || ng && !ng.scenario) && ionic.tap.register(document);
    }), function(document, ionic) {
        "use strict";
        function clear() {
            queueElements = {}, ionic.requestAnimationFrame(deactivateElements);
        }
        function activateElements() {
            for (var key in queueElements) queueElements[key] && (queueElements[key].classList.add(ACTIVATED_CLASS), 
            activeElements[key] = queueElements[key]);
            queueElements = {};
        }
        function deactivateElements() {
            if (ionic.transition && ionic.transition.isActive) return void setTimeout(deactivateElements, 400);
            for (var key in activeElements) activeElements[key] && (activeElements[key].classList.remove(ACTIVATED_CLASS), 
            delete activeElements[key]);
        }
        var queueElements = {}, activeElements = {}, keyId = 0, ACTIVATED_CLASS = "activated";
        ionic.activator = {
            start: function(e) {
                var hitX = ionic.tap.pointerCoord(e).x;
                hitX > 0 && 30 > hitX || ionic.requestAnimationFrame(function() {
                    if (!(ionic.scroll && ionic.scroll.isScrolling || ionic.tap.requiresNativeClick(e.target))) {
                        for (var eleToActivate, ele = e.target, x = 0; 6 > x && (ele && 1 === ele.nodeType); x++) {
                            if (eleToActivate && ele.classList && ele.classList.contains("item")) {
                                eleToActivate = ele;
                                break;
                            }
                            if ("A" == ele.tagName || "BUTTON" == ele.tagName || ele.hasAttribute("ng-click")) {
                                eleToActivate = ele;
                                break;
                            }
                            if (ele.classList.contains("button")) {
                                eleToActivate = ele;
                                break;
                            }
                            if ("ION-CONTENT" == ele.tagName || ele.classList && ele.classList.contains("pane") || "BODY" == ele.tagName) break;
                            ele = ele.parentElement;
                        }
                        eleToActivate && (queueElements[keyId] = eleToActivate, ionic.requestAnimationFrame(activateElements), 
                        keyId = keyId > 29 ? 0 : keyId + 1);
                    }
                });
            },
            end: function() {
                setTimeout(clear, 200);
            }
        };
    }(document, ionic), function(ionic) {
        var nextId = 0;
        ionic.Utils = {
            arrayMove: function(arr, oldIndex, newIndex) {
                if (newIndex >= arr.length) for (var k = newIndex - arr.length; k-- + 1; ) arr.push(void 0);
                return arr.splice(newIndex, 0, arr.splice(oldIndex, 1)[0]), arr;
            },
            proxy: function(func, context) {
                var args = Array.prototype.slice.call(arguments, 2);
                return function() {
                    return func.apply(context, args.concat(Array.prototype.slice.call(arguments)));
                };
            },
            debounce: function(func, wait, immediate) {
                var timeout, args, context, timestamp, result;
                return function() {
                    context = this, args = arguments, timestamp = new Date();
                    var later = function() {
                        var last = new Date() - timestamp;
                        wait > last ? timeout = setTimeout(later, wait - last) : (timeout = null, immediate || (result = func.apply(context, args)));
                    }, callNow = immediate && !timeout;
                    return timeout || (timeout = setTimeout(later, wait)), callNow && (result = func.apply(context, args)), 
                    result;
                };
            },
            throttle: function(func, wait, options) {
                var context, args, result, timeout = null, previous = 0;
                options || (options = {});
                var later = function() {
                    previous = options.leading === !1 ? 0 : Date.now(), timeout = null, result = func.apply(context, args);
                };
                return function() {
                    var now = Date.now();
                    previous || options.leading !== !1 || (previous = now);
                    var remaining = wait - (now - previous);
                    return context = this, args = arguments, 0 >= remaining ? (clearTimeout(timeout), 
                    timeout = null, previous = now, result = func.apply(context, args)) : timeout || options.trailing === !1 || (timeout = setTimeout(later, remaining)), 
                    result;
                };
            },
            inherit: function(protoProps, staticProps) {
                var child, parent = this;
                child = protoProps && protoProps.hasOwnProperty("constructor") ? protoProps.constructor : function() {
                    return parent.apply(this, arguments);
                }, ionic.extend(child, parent, staticProps);
                var Surrogate = function() {
                    this.constructor = child;
                };
                return Surrogate.prototype = parent.prototype, child.prototype = new Surrogate(), 
                protoProps && ionic.extend(child.prototype, protoProps), child.__super__ = parent.prototype, 
                child;
            },
            extend: function(obj) {
                for (var args = Array.prototype.slice.call(arguments, 1), i = 0; i < args.length; i++) {
                    var source = args[i];
                    if (source) for (var prop in source) obj[prop] = source[prop];
                }
                return obj;
            },
            nextUid: function() {
                return "ion" + nextId++;
            },
            disconnectScope: function(scope) {
                if (scope && scope.$root !== scope) {
                    var parent = scope.$parent;
                    scope.$$disconnected = !0, scope.$broadcast("$ionic.disconnectScope", scope), parent.$$childHead === scope && (parent.$$childHead = scope.$$nextSibling), 
                    parent.$$childTail === scope && (parent.$$childTail = scope.$$prevSibling), scope.$$prevSibling && (scope.$$prevSibling.$$nextSibling = scope.$$nextSibling), 
                    scope.$$nextSibling && (scope.$$nextSibling.$$prevSibling = scope.$$prevSibling), 
                    scope.$$nextSibling = scope.$$prevSibling = null;
                }
            },
            reconnectScope: function(scope) {
                if (scope && scope.$root !== scope && scope.$$disconnected) {
                    var parent = scope.$parent;
                    scope.$$disconnected = !1, scope.$broadcast("$ionic.reconnectScope", scope), scope.$$prevSibling = parent.$$childTail, 
                    parent.$$childHead ? (parent.$$childTail.$$nextSibling = scope, parent.$$childTail = scope) : parent.$$childHead = parent.$$childTail = scope;
                }
            },
            isScopeDisconnected: function(scope) {
                for (var climbScope = scope; climbScope; ) {
                    if (climbScope.$$disconnected) return !0;
                    climbScope = climbScope.$parent;
                }
                return !1;
            }
        }, ionic.inherit = ionic.Utils.inherit, ionic.extend = ionic.Utils.extend, ionic.throttle = ionic.Utils.throttle, 
        ionic.proxy = ionic.Utils.proxy, ionic.debounce = ionic.Utils.debounce;
    }(window.ionic);
    var keyboardActiveElement, lastKeyboardActiveElement, scrollView, waitForResizeTimer, keyboardFocusOutTimer, keyboardCurrentViewportHeight = 0, keyboardPortraitViewportHeight = 0, keyboardLandscapeViewportHeight = 0, wasOrientationChange = !1, KEYBOARD_OPEN_CSS = "keyboard-open", SCROLL_CONTAINER_CSS = "scroll-content", debouncedKeyboardFocusIn = ionic.debounce(keyboardFocusIn, 200, !0), debouncedKeyboardNativeShow = ionic.debounce(keyboardNativeShow, 100, !0);
    ionic.keyboard = {
        isOpen: !1,
        isClosing: !1,
        isOpening: !1,
        height: 0,
        isLandscape: !1,
        isInitialized: !1,
        hide: function() {
            keyboardHasPlugin() && cordova.plugins.Keyboard.close(), keyboardActiveElement && keyboardActiveElement.blur();
        },
        show: function() {
            keyboardHasPlugin() && cordova.plugins.Keyboard.show();
        },
        disable: function() {
            keyboardHasPlugin() ? (window.removeEventListener("native.keyboardshow", debouncedKeyboardNativeShow), 
            window.removeEventListener("native.keyboardhide", keyboardFocusOut)) : document.body.removeEventListener("focusout", keyboardFocusOut), 
            document.body.removeEventListener("ionic.focusin", debouncedKeyboardFocusIn), document.body.removeEventListener("focusin", debouncedKeyboardFocusIn), 
            window.removeEventListener("orientationchange", keyboardOrientationChange), window.navigator.msPointerEnabled ? document.removeEventListener("MSPointerDown", keyboardInit) : document.removeEventListener("touchstart", keyboardInit), 
            ionic.keyboard.isInitialized = !1;
        },
        enable: function() {
            keyboardInit();
        }
    }, keyboardCurrentViewportHeight = getViewportHeight(), ionic.Platform.ready(function() {
        keyboardInitViewportHeight(), window.addEventListener("orientationchange", keyboardOrientationChange), 
        setTimeout(keyboardInitViewportHeight, 999), window.navigator.msPointerEnabled ? document.addEventListener("MSPointerDown", keyboardInit, !1) : document.addEventListener("touchstart", keyboardInit, !1);
    });
    var viewportTag, viewportProperties = {};
    ionic.viewport = {
        orientation: function() {
            return window.innerWidth > window.innerHeight ? 90 : 0;
        }
    }, ionic.Platform.ready(function() {
        viewportLoadTag(), window.addEventListener("orientationchange", function() {
            setTimeout(viewportUpdate, 1e3);
        }, !1);
    }), function(ionic) {
        "use strict";
        ionic.views.View = function() {
            this.initialize.apply(this, arguments);
        }, ionic.views.View.inherit = ionic.inherit, ionic.extend(ionic.views.View.prototype, {
            initialize: function() {}
        });
    }(window.ionic);
    var zyngaCore = {
        effect: {}
    };
    !function(global) {
        var time = Date.now || function() {
            return +new Date();
        }, desiredFrames = 60, millisecondsPerSecond = 1e3, running = {}, counter = 1;
        zyngaCore.effect.Animate = {
            requestAnimationFrame: function() {
                var requestFrame = global.requestAnimationFrame || global.webkitRequestAnimationFrame || global.mozRequestAnimationFrame || global.oRequestAnimationFrame, isNative = !!requestFrame;
                if (requestFrame && !/requestAnimationFrame\(\)\s*\{\s*\[native code\]\s*\}/i.test(requestFrame.toString()) && (isNative = !1), 
                isNative) return function(callback, root) {
                    requestFrame(callback, root);
                };
                var TARGET_FPS = 60, requests = {}, requestCount = 0, rafHandle = 1, intervalHandle = null, lastActive = +new Date();
                return function(callback) {
                    var callbackHandle = rafHandle++;
                    return requests[callbackHandle] = callback, requestCount++, null === intervalHandle && (intervalHandle = setInterval(function() {
                        var time = +new Date(), currentRequests = requests;
                        requests = {}, requestCount = 0;
                        for (var key in currentRequests) currentRequests.hasOwnProperty(key) && (currentRequests[key](time), 
                        lastActive = time);
                        time - lastActive > 2500 && (clearInterval(intervalHandle), intervalHandle = null);
                    }, 1e3 / TARGET_FPS)), callbackHandle;
                };
            }(),
            stop: function(id) {
                var cleared = null != running[id];
                return cleared && (running[id] = null), cleared;
            },
            isRunning: function(id) {
                return null != running[id];
            },
            start: function(stepCallback, verifyCallback, completedCallback, duration, easingMethod, root) {
                var start = time(), lastFrame = start, percent = 0, dropCounter = 0, id = counter++;
                if (root || (root = document.body), id % 20 === 0) {
                    var newRunning = {};
                    for (var usedId in running) newRunning[usedId] = !0;
                    running = newRunning;
                }
                var step = function(virtual) {
                    var render = virtual !== !0, now = time();
                    if (!running[id] || verifyCallback && !verifyCallback(id)) return running[id] = null, 
                    void (completedCallback && completedCallback(desiredFrames - dropCounter / ((now - start) / millisecondsPerSecond), id, !1));
                    if (render) for (var droppedFrames = Math.round((now - lastFrame) / (millisecondsPerSecond / desiredFrames)) - 1, j = 0; j < Math.min(droppedFrames, 4); j++) step(!0), 
                    dropCounter++;
                    duration && (percent = (now - start) / duration, percent > 1 && (percent = 1));
                    var value = easingMethod ? easingMethod(percent) : percent;
                    stepCallback(value, now, render) !== !1 && 1 !== percent || !render ? render && (lastFrame = now, 
                    zyngaCore.effect.Animate.requestAnimationFrame(step, root)) : (running[id] = null, 
                    completedCallback && completedCallback(desiredFrames - dropCounter / ((now - start) / millisecondsPerSecond), id, 1 === percent || null == duration));
                };
                return running[id] = !0, zyngaCore.effect.Animate.requestAnimationFrame(step, root), 
                id;
            }
        };
    }(window), function(ionic) {
        var NOOP = function() {}, easeOutCubic = function(pos) {
            return Math.pow(pos - 1, 3) + 1;
        }, easeInOutCubic = function(pos) {
            return (pos /= .5) < 1 ? .5 * Math.pow(pos, 3) : .5 * (Math.pow(pos - 2, 3) + 2);
        };
        ionic.views.Scroll = ionic.views.View.inherit({
            initialize: function(options) {
                var self = this;
                self.__container = options.el, self.__content = options.el.firstElementChild, setTimeout(function() {
                    self.__container && self.__content && (self.__container.scrollTop = 0, self.__content.scrollTop = 0);
                }), self.options = {
                    scrollingX: !1,
                    scrollbarX: !0,
                    scrollingY: !0,
                    scrollbarY: !0,
                    startX: 0,
                    startY: 0,
                    wheelDampen: 6,
                    minScrollbarSizeX: 5,
                    minScrollbarSizeY: 5,
                    scrollbarsFade: !0,
                    scrollbarFadeDelay: 300,
                    scrollbarResizeFadeDelay: 1e3,
                    animating: !0,
                    animationDuration: 250,
                    decelVelocityThreshold: 4,
                    decelVelocityThresholdPaging: 4,
                    bouncing: !0,
                    locking: !0,
                    paging: !1,
                    snapping: !1,
                    zooming: !1,
                    minZoom: .5,
                    maxZoom: 3,
                    speedMultiplier: 1,
                    deceleration: .97,
                    preventDefault: !1,
                    scrollingComplete: NOOP,
                    penetrationDeceleration: .03,
                    penetrationAcceleration: .08,
                    scrollEventInterval: 10,
                    freeze: !1,
                    getContentWidth: function() {
                        return Math.max(self.__content.scrollWidth, self.__content.offsetWidth);
                    },
                    getContentHeight: function() {
                        return Math.max(self.__content.scrollHeight, self.__content.offsetHeight + 2 * self.__content.offsetTop);
                    }
                };
                for (var key in options) self.options[key] = options[key];
                self.hintResize = ionic.debounce(function() {
                    self.resize();
                }, 1e3, !0), self.onScroll = function() {
                    ionic.scroll.isScrolling ? (clearTimeout(self.scrollTimer), self.scrollTimer = setTimeout(self.setScrollStop, 80)) : setTimeout(self.setScrollStart, 50);
                }, self.freeze = function(shouldFreeze) {
                    return arguments.length && (self.options.freeze = shouldFreeze), self.options.freeze;
                }, self.freezeShut = self.freeze, self.setScrollStart = function() {
                    ionic.scroll.isScrolling = Math.abs(ionic.scroll.lastTop - self.__scrollTop) > 1, 
                    clearTimeout(self.scrollTimer), self.scrollTimer = setTimeout(self.setScrollStop, 80);
                }, self.setScrollStop = function() {
                    ionic.scroll.isScrolling = !1, ionic.scroll.lastTop = self.__scrollTop;
                }, self.triggerScrollEvent = ionic.throttle(function() {
                    self.onScroll(), ionic.trigger("scroll", {
                        scrollTop: self.__scrollTop,
                        scrollLeft: self.__scrollLeft,
                        target: self.__container
                    });
                }, self.options.scrollEventInterval), self.triggerScrollEndEvent = function() {
                    ionic.trigger("scrollend", {
                        scrollTop: self.__scrollTop,
                        scrollLeft: self.__scrollLeft,
                        target: self.__container
                    });
                }, self.__scrollLeft = self.options.startX, self.__scrollTop = self.options.startY, 
                self.__callback = self.getRenderFn(), self.__initEventHandlers(), self.__createScrollbars();
            },
            run: function() {
                this.resize(), this.__fadeScrollbars("out", this.options.scrollbarResizeFadeDelay);
            },
            __isSingleTouch: !1,
            __isTracking: !1,
            __didDecelerationComplete: !1,
            __isGesturing: !1,
            __isDragging: !1,
            __isDecelerating: !1,
            __isAnimating: !1,
            __clientLeft: 0,
            __clientTop: 0,
            __clientWidth: 0,
            __clientHeight: 0,
            __contentWidth: 0,
            __contentHeight: 0,
            __snapWidth: 100,
            __snapHeight: 100,
            __refreshHeight: null,
            __refreshActive: !1,
            __refreshActivate: null,
            __refreshDeactivate: null,
            __refreshStart: null,
            __zoomLevel: 1,
            __scrollLeft: 0,
            __scrollTop: 0,
            __maxScrollLeft: 0,
            __maxScrollTop: 0,
            __scheduledLeft: 0,
            __scheduledTop: 0,
            __scheduledZoom: 0,
            __lastTouchLeft: null,
            __lastTouchTop: null,
            __lastTouchMove: null,
            __positions: null,
            __minDecelerationScrollLeft: null,
            __minDecelerationScrollTop: null,
            __maxDecelerationScrollLeft: null,
            __maxDecelerationScrollTop: null,
            __decelerationVelocityX: null,
            __decelerationVelocityY: null,
            __transformProperty: null,
            __perspectiveProperty: null,
            __indicatorX: null,
            __indicatorY: null,
            __scrollbarFadeTimeout: null,
            __didWaitForSize: null,
            __sizerTimeout: null,
            __initEventHandlers: function() {
                function getEventTouches(e) {
                    return e.touches && e.touches.length ? e.touches : [ {
                        pageX: e.pageX,
                        pageY: e.pageY
                    } ];
                }
                var scrollViewOffsetHeight, self = this, container = self.__container;
                if (self.scrollChildIntoView = function(e) {
                    var scrollBottomOffsetToTop = container.getBoundingClientRect().bottom;
                    scrollViewOffsetHeight = container.offsetHeight;
                    var alreadyShrunk = self.isShrunkForKeyboard, isModal = container.parentNode.classList.contains("modal"), isInsetModal = isModal && window.innerWidth >= 680;
                    if (!alreadyShrunk) {
                        if (ionic.Platform.isIOS() || ionic.Platform.isFullScreen || isInsetModal) {
                            var scrollBottomOffsetToBottom = e.detail.viewportHeight - scrollBottomOffsetToTop, keyboardOffset = Math.max(0, e.detail.keyboardHeight - scrollBottomOffsetToBottom);
                            ionic.requestAnimationFrame(function() {
                                scrollViewOffsetHeight -= keyboardOffset, container.style.height = scrollViewOffsetHeight + "px", 
                                container.style.overflow = "visible", self.resize();
                            });
                        }
                        self.isShrunkForKeyboard = !0;
                    }
                    e.detail.isElementUnderKeyboard && ionic.requestAnimationFrame(function() {
                        container.scrollTop = 0, self.isShrunkForKeyboard && !alreadyShrunk && (scrollBottomOffsetToTop = container.getBoundingClientRect().bottom);
                        var scrollMidpointOffset = .5 * scrollViewOffsetHeight, inputMidpoint = (e.detail.elementBottom + e.detail.elementTop) / 2, inputMidpointOffsetToScrollBottom = inputMidpoint - scrollBottomOffsetToTop, scrollTop = inputMidpointOffsetToScrollBottom + scrollMidpointOffset;
                        scrollTop > 0 && (ionic.Platform.isIOS() && ionic.tap.cloneFocusedInput(container, self), 
                        self.scrollBy(0, scrollTop, !0), self.onScroll());
                    }), e.stopPropagation();
                }, self.resetScrollView = function() {
                    self.isShrunkForKeyboard && (self.isShrunkForKeyboard = !1, container.style.height = "", 
                    container.style.overflow = ""), self.resize();
                }, container.addEventListener("scrollChildIntoView", self.scrollChildIntoView), 
                document.addEventListener("resetScrollView", self.resetScrollView), self.touchStart = function(e) {
                    if (self.startCoordinates = ionic.tap.pointerCoord(e), !ionic.tap.ignoreScrollStart(e)) {
                        if (self.__isDown = !0, ionic.tap.containsOrIsTextInput(e.target) || "SELECT" === e.target.tagName) return void (self.__hasStarted = !1);
                        self.__isSelectable = !0, self.__enableScrollY = !0, self.__hasStarted = !0, self.doTouchStart(getEventTouches(e), e.timeStamp), 
                        e.preventDefault();
                    }
                }, self.touchMove = function(e) {
                    if (!(self.options.freeze || !self.__isDown || !self.__isDown && e.defaultPrevented || "TEXTAREA" === e.target.tagName && e.target.parentElement.querySelector(":focus"))) {
                        if (!self.__hasStarted && (ionic.tap.containsOrIsTextInput(e.target) || "SELECT" === e.target.tagName)) return self.__hasStarted = !0, 
                        self.doTouchStart(getEventTouches(e), e.timeStamp), void e.preventDefault();
                        if (self.startCoordinates) {
                            var currentCoordinates = ionic.tap.pointerCoord(e);
                            self.__isSelectable && ionic.tap.isTextInput(e.target) && Math.abs(self.startCoordinates.x - currentCoordinates.x) > 20 && (self.__enableScrollY = !1, 
                            self.__isSelectable = !0), self.__enableScrollY && Math.abs(self.startCoordinates.y - currentCoordinates.y) > 10 && (self.__isSelectable = !1, 
                            ionic.tap.cloneFocusedInput(container, self));
                        }
                        self.doTouchMove(getEventTouches(e), e.timeStamp, e.scale), self.__isDown = !0;
                    }
                }, self.touchMoveBubble = function(e) {
                    self.__isDown && self.options.preventDefault && e.preventDefault();
                }, self.touchEnd = function(e) {
                    self.__isDown && (self.doTouchEnd(e, e.timeStamp), self.__isDown = !1, self.__hasStarted = !1, 
                    self.__isSelectable = !0, self.__enableScrollY = !0, self.__isDragging || self.__isDecelerating || self.__isAnimating || ionic.tap.removeClonedInputs(container, self));
                }, self.mouseWheel = ionic.animationFrameThrottle(function(e) {
                    var scrollParent = ionic.DomUtil.getParentOrSelfWithClass(e.target, "ionic-scroll");
                    self.options.freeze || scrollParent !== self.__container || (self.hintResize(), 
                    self.scrollBy((e.wheelDeltaX || e.deltaX || 0) / self.options.wheelDampen, (-e.wheelDeltaY || e.deltaY || 0) / self.options.wheelDampen), 
                    self.__fadeScrollbars("in"), clearTimeout(self.__wheelHideBarTimeout), self.__wheelHideBarTimeout = setTimeout(function() {
                        self.__fadeScrollbars("out");
                    }, 100));
                }), "ontouchstart" in window) container.addEventListener("touchstart", self.touchStart, !1), 
                self.options.preventDefault && container.addEventListener("touchmove", self.touchMoveBubble, !1), 
                document.addEventListener("touchmove", self.touchMove, !1), document.addEventListener("touchend", self.touchEnd, !1), 
                document.addEventListener("touchcancel", self.touchEnd, !1), document.addEventListener("wheel", self.mouseWheel, !1); else if (window.navigator.pointerEnabled) container.addEventListener("pointerdown", self.touchStart, !1), 
                self.options.preventDefault && container.addEventListener("pointermove", self.touchMoveBubble, !1), 
                document.addEventListener("pointermove", self.touchMove, !1), document.addEventListener("pointerup", self.touchEnd, !1), 
                document.addEventListener("pointercancel", self.touchEnd, !1), document.addEventListener("wheel", self.mouseWheel, !1); else if (window.navigator.msPointerEnabled) container.addEventListener("MSPointerDown", self.touchStart, !1), 
                self.options.preventDefault && container.addEventListener("MSPointerMove", self.touchMoveBubble, !1), 
                document.addEventListener("MSPointerMove", self.touchMove, !1), document.addEventListener("MSPointerUp", self.touchEnd, !1), 
                document.addEventListener("MSPointerCancel", self.touchEnd, !1), document.addEventListener("wheel", self.mouseWheel, !1); else {
                    var mousedown = !1;
                    self.mouseDown = function(e) {
                        ionic.tap.ignoreScrollStart(e) || "SELECT" === e.target.tagName || (self.doTouchStart(getEventTouches(e), e.timeStamp), 
                        ionic.tap.isTextInput(e.target) || e.preventDefault(), mousedown = !0);
                    }, self.mouseMove = function(e) {
                        self.options.freeze || !mousedown || !mousedown && e.defaultPrevented || (self.doTouchMove(getEventTouches(e), e.timeStamp), 
                        mousedown = !0);
                    }, self.mouseMoveBubble = function(e) {
                        mousedown && self.options.preventDefault && e.preventDefault();
                    }, self.mouseUp = function(e) {
                        mousedown && (self.doTouchEnd(e, e.timeStamp), mousedown = !1);
                    }, container.addEventListener("mousedown", self.mouseDown, !1), self.options.preventDefault && container.addEventListener("mousemove", self.mouseMoveBubble, !1), 
                    document.addEventListener("mousemove", self.mouseMove, !1), document.addEventListener("mouseup", self.mouseUp, !1), 
                    document.addEventListener("mousewheel", self.mouseWheel, !1), document.addEventListener("wheel", self.mouseWheel, !1);
                }
            },
            __cleanup: function() {
                var self = this, container = self.__container;
                container.removeEventListener("touchstart", self.touchStart), container.removeEventListener("touchmove", self.touchMoveBubble), 
                document.removeEventListener("touchmove", self.touchMove), document.removeEventListener("touchend", self.touchEnd), 
                document.removeEventListener("touchcancel", self.touchEnd), container.removeEventListener("pointerdown", self.touchStart), 
                container.removeEventListener("pointermove", self.touchMoveBubble), document.removeEventListener("pointermove", self.touchMove), 
                document.removeEventListener("pointerup", self.touchEnd), document.removeEventListener("pointercancel", self.touchEnd), 
                container.removeEventListener("MSPointerDown", self.touchStart), container.removeEventListener("MSPointerMove", self.touchMoveBubble), 
                document.removeEventListener("MSPointerMove", self.touchMove), document.removeEventListener("MSPointerUp", self.touchEnd), 
                document.removeEventListener("MSPointerCancel", self.touchEnd), container.removeEventListener("mousedown", self.mouseDown), 
                container.removeEventListener("mousemove", self.mouseMoveBubble), document.removeEventListener("mousemove", self.mouseMove), 
                document.removeEventListener("mouseup", self.mouseUp), document.removeEventListener("mousewheel", self.mouseWheel), 
                document.removeEventListener("wheel", self.mouseWheel), container.removeEventListener("scrollChildIntoView", self.scrollChildIntoView), 
                document.removeEventListener("resetScrollView", self.resetScrollView), ionic.tap.removeClonedInputs(container, self), 
                delete self.__container, delete self.__content, delete self.__indicatorX, delete self.__indicatorY, 
                delete self.options.el, self.__callback = self.scrollChildIntoView = self.resetScrollView = NOOP, 
                self.mouseMove = self.mouseDown = self.mouseUp = self.mouseWheel = self.touchStart = self.touchMove = self.touchEnd = self.touchCancel = NOOP, 
                self.resize = self.scrollTo = self.zoomTo = self.__scrollingComplete = NOOP, container = null;
            },
            __createScrollbar: function(direction) {
                var bar = document.createElement("div"), indicator = document.createElement("div");
                return indicator.className = "scroll-bar-indicator scroll-bar-fade-out", "h" == direction ? bar.className = "scroll-bar scroll-bar-h" : bar.className = "scroll-bar scroll-bar-v", 
                bar.appendChild(indicator), bar;
            },
            __createScrollbars: function() {
                var indicatorX, indicatorY, self = this;
                self.options.scrollingX && (indicatorX = {
                    el: self.__createScrollbar("h"),
                    sizeRatio: 1
                }, indicatorX.indicator = indicatorX.el.children[0], self.options.scrollbarX && self.__container.appendChild(indicatorX.el), 
                self.__indicatorX = indicatorX), self.options.scrollingY && (indicatorY = {
                    el: self.__createScrollbar("v"),
                    sizeRatio: 1
                }, indicatorY.indicator = indicatorY.el.children[0], self.options.scrollbarY && self.__container.appendChild(indicatorY.el), 
                self.__indicatorY = indicatorY);
            },
            __resizeScrollbars: function() {
                var self = this;
                if (self.__indicatorX) {
                    var width = Math.max(Math.round(self.__clientWidth * self.__clientWidth / self.__contentWidth), 20);
                    width > self.__contentWidth && (width = 0), width !== self.__indicatorX.size && ionic.requestAnimationFrame(function() {
                        self.__indicatorX.indicator.style.width = width + "px";
                    }), self.__indicatorX.size = width, self.__indicatorX.minScale = self.options.minScrollbarSizeX / width, 
                    self.__indicatorX.maxPos = self.__clientWidth - width, self.__indicatorX.sizeRatio = self.__maxScrollLeft ? self.__indicatorX.maxPos / self.__maxScrollLeft : 1;
                }
                if (self.__indicatorY) {
                    var height = Math.max(Math.round(self.__clientHeight * self.__clientHeight / self.__contentHeight), 20);
                    height > self.__contentHeight && (height = 0), height !== self.__indicatorY.size && ionic.requestAnimationFrame(function() {
                        self.__indicatorY && (self.__indicatorY.indicator.style.height = height + "px");
                    }), self.__indicatorY.size = height, self.__indicatorY.minScale = self.options.minScrollbarSizeY / height, 
                    self.__indicatorY.maxPos = self.__clientHeight - height, self.__indicatorY.sizeRatio = self.__maxScrollTop ? self.__indicatorY.maxPos / self.__maxScrollTop : 1;
                }
            },
            __repositionScrollbars: function() {
                var heightScale, widthScale, widthDiff, heightDiff, x, y, self = this, xstop = 0, ystop = 0;
                if (self.__indicatorX) {
                    self.__indicatorY && (xstop = 10), x = Math.round(self.__indicatorX.sizeRatio * self.__scrollLeft) || 0, 
                    widthDiff = self.__scrollLeft - (self.__maxScrollLeft - xstop), self.__scrollLeft < 0 ? (widthScale = Math.max(self.__indicatorX.minScale, (self.__indicatorX.size - Math.abs(self.__scrollLeft)) / self.__indicatorX.size), 
                    x = 0, self.__indicatorX.indicator.style[self.__transformOriginProperty] = "left center") : widthDiff > 0 ? (widthScale = Math.max(self.__indicatorX.minScale, (self.__indicatorX.size - widthDiff) / self.__indicatorX.size), 
                    x = self.__indicatorX.maxPos - xstop, self.__indicatorX.indicator.style[self.__transformOriginProperty] = "right center") : (x = Math.min(self.__maxScrollLeft, Math.max(0, x)), 
                    widthScale = 1);
                    var translate3dX = "translate3d(" + x + "px, 0, 0) scaleX(" + widthScale + ")";
                    self.__indicatorX.transformProp !== translate3dX && (self.__indicatorX.indicator.style[self.__transformProperty] = translate3dX, 
                    self.__indicatorX.transformProp = translate3dX);
                }
                if (self.__indicatorY) {
                    y = Math.round(self.__indicatorY.sizeRatio * self.__scrollTop) || 0, self.__indicatorX && (ystop = 10), 
                    heightDiff = self.__scrollTop - (self.__maxScrollTop - ystop), self.__scrollTop < 0 ? (heightScale = Math.max(self.__indicatorY.minScale, (self.__indicatorY.size - Math.abs(self.__scrollTop)) / self.__indicatorY.size), 
                    y = 0, "center top" !== self.__indicatorY.originProp && (self.__indicatorY.indicator.style[self.__transformOriginProperty] = "center top", 
                    self.__indicatorY.originProp = "center top")) : heightDiff > 0 ? (heightScale = Math.max(self.__indicatorY.minScale, (self.__indicatorY.size - heightDiff) / self.__indicatorY.size), 
                    y = self.__indicatorY.maxPos - ystop, "center bottom" !== self.__indicatorY.originProp && (self.__indicatorY.indicator.style[self.__transformOriginProperty] = "center bottom", 
                    self.__indicatorY.originProp = "center bottom")) : (y = Math.min(self.__maxScrollTop, Math.max(0, y)), 
                    heightScale = 1);
                    var translate3dY = "translate3d(0," + y + "px, 0) scaleY(" + heightScale + ")";
                    self.__indicatorY.transformProp !== translate3dY && (self.__indicatorY.indicator.style[self.__transformProperty] = translate3dY, 
                    self.__indicatorY.transformProp = translate3dY);
                }
            },
            __fadeScrollbars: function(direction, delay) {
                var self = this;
                if (self.options.scrollbarsFade) {
                    var className = "scroll-bar-fade-out";
                    self.options.scrollbarsFade === !0 && (clearTimeout(self.__scrollbarFadeTimeout), 
                    "in" == direction ? (self.__indicatorX && self.__indicatorX.indicator.classList.remove(className), 
                    self.__indicatorY && self.__indicatorY.indicator.classList.remove(className)) : self.__scrollbarFadeTimeout = setTimeout(function() {
                        self.__indicatorX && self.__indicatorX.indicator.classList.add(className), self.__indicatorY && self.__indicatorY.indicator.classList.add(className);
                    }, delay || self.options.scrollbarFadeDelay));
                }
            },
            __scrollingComplete: function() {
                this.options.scrollingComplete(), ionic.tap.removeClonedInputs(this.__container, this), 
                this.__fadeScrollbars("out");
            },
            resize: function(continueScrolling) {
                var self = this;
                self.__container && self.options && self.setDimensions(self.__container.clientWidth, self.__container.clientHeight, self.options.getContentWidth(), self.options.getContentHeight(), continueScrolling);
            },
            getRenderFn: function() {
                var engine, self = this, content = self.__content, docStyle = document.documentElement.style;
                "MozAppearance" in docStyle ? engine = "gecko" : "WebkitAppearance" in docStyle ? engine = "webkit" : "string" == typeof navigator.cpuClass && (engine = "trident");
                var undef, vendorPrefix = {
                    trident: "ms",
                    gecko: "Moz",
                    webkit: "Webkit",
                    presto: "O"
                }[engine], helperElem = document.createElement("div"), perspectiveProperty = vendorPrefix + "Perspective", transformProperty = vendorPrefix + "Transform", transformOriginProperty = vendorPrefix + "TransformOrigin";
                return self.__perspectiveProperty = transformProperty, self.__transformProperty = transformProperty, 
                self.__transformOriginProperty = transformOriginProperty, helperElem.style[perspectiveProperty] !== undef ? function(left, top, zoom, wasResize) {
                    var translate3d = "translate3d(" + -left + "px," + -top + "px,0) scale(" + zoom + ")";
                    translate3d !== self.contentTransform && (content.style[transformProperty] = translate3d, 
                    self.contentTransform = translate3d), self.__repositionScrollbars(), wasResize || self.triggerScrollEvent();
                } : helperElem.style[transformProperty] !== undef ? function(left, top, zoom, wasResize) {
                    content.style[transformProperty] = "translate(" + -left + "px," + -top + "px) scale(" + zoom + ")", 
                    self.__repositionScrollbars(), wasResize || self.triggerScrollEvent();
                } : function(left, top, zoom, wasResize) {
                    content.style.marginLeft = left ? -left / zoom + "px" : "", content.style.marginTop = top ? -top / zoom + "px" : "", 
                    content.style.zoom = zoom || "", self.__repositionScrollbars(), wasResize || self.triggerScrollEvent();
                };
            },
            setDimensions: function(clientWidth, clientHeight, contentWidth, contentHeight, continueScrolling) {
                var self = this;
                (clientWidth || clientHeight || contentWidth || contentHeight) && (clientWidth === +clientWidth && (self.__clientWidth = clientWidth), 
                clientHeight === +clientHeight && (self.__clientHeight = clientHeight), contentWidth === +contentWidth && (self.__contentWidth = contentWidth), 
                contentHeight === +contentHeight && (self.__contentHeight = contentHeight), self.__computeScrollMax(), 
                self.__resizeScrollbars(), continueScrolling || self.scrollTo(self.__scrollLeft, self.__scrollTop, !0, null, !0));
            },
            setPosition: function(left, top) {
                this.__clientLeft = left || 0, this.__clientTop = top || 0;
            },
            setSnapSize: function(width, height) {
                this.__snapWidth = width, this.__snapHeight = height;
            },
            activatePullToRefresh: function(height, refresherMethods) {
                var self = this;
                self.__refreshHeight = height, self.__refreshActivate = function() {
                    ionic.requestAnimationFrame(refresherMethods.activate);
                }, self.__refreshDeactivate = function() {
                    ionic.requestAnimationFrame(refresherMethods.deactivate);
                }, self.__refreshStart = function() {
                    ionic.requestAnimationFrame(refresherMethods.start);
                }, self.__refreshShow = function() {
                    ionic.requestAnimationFrame(refresherMethods.show);
                }, self.__refreshHide = function() {
                    ionic.requestAnimationFrame(refresherMethods.hide);
                }, self.__refreshTail = function() {
                    ionic.requestAnimationFrame(refresherMethods.tail);
                }, self.__refreshTailTime = 100, self.__minSpinTime = 600;
            },
            triggerPullToRefresh: function() {
                this.__publish(this.__scrollLeft, -this.__refreshHeight, this.__zoomLevel, !0);
                var d = new Date();
                this.refreshStartTime = d.getTime(), this.__refreshStart && this.__refreshStart();
            },
            finishPullToRefresh: function() {
                var self = this, d = new Date(), delay = 0;
                self.refreshStartTime + self.__minSpinTime > d.getTime() && (delay = self.refreshStartTime + self.__minSpinTime - d.getTime()), 
                setTimeout(function() {
                    self.__refreshTail && self.__refreshTail(), setTimeout(function() {
                        self.__refreshActive = !1, self.__refreshDeactivate && self.__refreshDeactivate(), 
                        self.__refreshHide && self.__refreshHide(), self.scrollTo(self.__scrollLeft, self.__scrollTop, !0);
                    }, self.__refreshTailTime);
                }, delay);
            },
            getValues: function() {
                return {
                    left: this.__scrollLeft,
                    top: this.__scrollTop,
                    zoom: this.__zoomLevel
                };
            },
            getScrollMax: function() {
                return {
                    left: this.__maxScrollLeft,
                    top: this.__maxScrollTop
                };
            },
            zoomTo: function(level, animate, originLeft, originTop) {
                var self = this;
                if (!self.options.zooming) throw new Error("Zooming is not enabled!");
                self.__isDecelerating && (zyngaCore.effect.Animate.stop(self.__isDecelerating), 
                self.__isDecelerating = !1);
                var oldLevel = self.__zoomLevel;
                null == originLeft && (originLeft = self.__clientWidth / 2), null == originTop && (originTop = self.__clientHeight / 2), 
                level = Math.max(Math.min(level, self.options.maxZoom), self.options.minZoom), self.__computeScrollMax(level);
                var left = (originLeft + self.__scrollLeft) * level / oldLevel - originLeft, top = (originTop + self.__scrollTop) * level / oldLevel - originTop;
                left > self.__maxScrollLeft ? left = self.__maxScrollLeft : 0 > left && (left = 0), 
                top > self.__maxScrollTop ? top = self.__maxScrollTop : 0 > top && (top = 0), self.__publish(left, top, level, animate);
            },
            zoomBy: function(factor, animate, originLeft, originTop) {
                this.zoomTo(this.__zoomLevel * factor, animate, originLeft, originTop);
            },
            scrollTo: function(left, top, animate, zoom, wasResize) {
                var self = this;
                if (self.__isDecelerating && (zyngaCore.effect.Animate.stop(self.__isDecelerating), 
                self.__isDecelerating = !1), null != zoom && zoom !== self.__zoomLevel) {
                    if (!self.options.zooming) throw new Error("Zooming is not enabled!");
                    left *= zoom, top *= zoom, self.__computeScrollMax(zoom);
                } else zoom = self.__zoomLevel;
                self.options.scrollingX ? self.options.paging ? left = Math.round(left / self.__clientWidth) * self.__clientWidth : self.options.snapping && (left = Math.round(left / self.__snapWidth) * self.__snapWidth) : left = self.__scrollLeft, 
                self.options.scrollingY ? self.options.paging ? top = Math.round(top / self.__clientHeight) * self.__clientHeight : self.options.snapping && (top = Math.round(top / self.__snapHeight) * self.__snapHeight) : top = self.__scrollTop, 
                left = Math.max(Math.min(self.__maxScrollLeft, left), 0), top = Math.max(Math.min(self.__maxScrollTop, top), 0), 
                left === self.__scrollLeft && top === self.__scrollTop && (animate = !1), self.__publish(left, top, zoom, animate, wasResize);
            },
            scrollBy: function(left, top, animate) {
                var self = this, startLeft = self.__isAnimating ? self.__scheduledLeft : self.__scrollLeft, startTop = self.__isAnimating ? self.__scheduledTop : self.__scrollTop;
                self.scrollTo(startLeft + (left || 0), startTop + (top || 0), animate);
            },
            doMouseZoom: function(wheelDelta, timeStamp, pageX, pageY) {
                var change = wheelDelta > 0 ? .97 : 1.03;
                return this.zoomTo(this.__zoomLevel * change, !1, pageX - this.__clientLeft, pageY - this.__clientTop);
            },
            doTouchStart: function(touches, timeStamp) {
                var self = this;
                self.__decStopped = !(!self.__isDecelerating && !self.__isAnimating), self.hintResize(), 
                timeStamp instanceof Date && (timeStamp = timeStamp.valueOf()), "number" != typeof timeStamp && (timeStamp = Date.now()), 
                self.__interruptedAnimation = !0, self.__isDecelerating && (zyngaCore.effect.Animate.stop(self.__isDecelerating), 
                self.__isDecelerating = !1, self.__interruptedAnimation = !0), self.__isAnimating && (zyngaCore.effect.Animate.stop(self.__isAnimating), 
                self.__isAnimating = !1, self.__interruptedAnimation = !0);
                var currentTouchLeft, currentTouchTop, isSingleTouch = 1 === touches.length;
                isSingleTouch ? (currentTouchLeft = touches[0].pageX, currentTouchTop = touches[0].pageY) : (currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2, 
                currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2), self.__initialTouchLeft = currentTouchLeft, 
                self.__initialTouchTop = currentTouchTop, self.__initialTouches = touches, self.__zoomLevelStart = self.__zoomLevel, 
                self.__lastTouchLeft = currentTouchLeft, self.__lastTouchTop = currentTouchTop, 
                self.__lastTouchMove = timeStamp, self.__lastScale = 1, self.__enableScrollX = !isSingleTouch && self.options.scrollingX, 
                self.__enableScrollY = !isSingleTouch && self.options.scrollingY, self.__isTracking = !0, 
                self.__didDecelerationComplete = !1, self.__isDragging = !isSingleTouch, self.__isSingleTouch = isSingleTouch, 
                self.__positions = [];
            },
            doTouchMove: function(touches, timeStamp, scale) {
                timeStamp instanceof Date && (timeStamp = timeStamp.valueOf()), "number" != typeof timeStamp && (timeStamp = Date.now());
                var self = this;
                if (self.__isTracking) {
                    var currentTouchLeft, currentTouchTop;
                    2 === touches.length ? (currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2, 
                    currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2, !scale && self.options.zooming && (scale = self.__getScale(self.__initialTouches, touches))) : (currentTouchLeft = touches[0].pageX, 
                    currentTouchTop = touches[0].pageY);
                    var positions = self.__positions;
                    if (self.__isDragging) {
                        self.__decStopped = !1;
                        var moveX = currentTouchLeft - self.__lastTouchLeft, moveY = currentTouchTop - self.__lastTouchTop, scrollLeft = self.__scrollLeft, scrollTop = self.__scrollTop, level = self.__zoomLevel;
                        if (null != scale && self.options.zooming) {
                            var oldLevel = level;
                            if (level = level / self.__lastScale * scale, level = Math.max(Math.min(level, self.options.maxZoom), self.options.minZoom), 
                            oldLevel !== level) {
                                var currentTouchLeftRel = currentTouchLeft - self.__clientLeft, currentTouchTopRel = currentTouchTop - self.__clientTop;
                                scrollLeft = (currentTouchLeftRel + scrollLeft) * level / oldLevel - currentTouchLeftRel, 
                                scrollTop = (currentTouchTopRel + scrollTop) * level / oldLevel - currentTouchTopRel, 
                                self.__computeScrollMax(level);
                            }
                        }
                        if (self.__enableScrollX) {
                            scrollLeft -= moveX * self.options.speedMultiplier;
                            var maxScrollLeft = self.__maxScrollLeft;
                            (scrollLeft > maxScrollLeft || 0 > scrollLeft) && (self.options.bouncing ? scrollLeft += moveX / 2 * self.options.speedMultiplier : scrollLeft = scrollLeft > maxScrollLeft ? maxScrollLeft : 0);
                        }
                        if (self.__enableScrollY) {
                            scrollTop -= moveY * self.options.speedMultiplier;
                            var maxScrollTop = self.__maxScrollTop;
                            scrollTop > maxScrollTop || 0 > scrollTop ? self.options.bouncing || self.__refreshHeight && 0 > scrollTop ? (scrollTop += moveY / 2 * self.options.speedMultiplier, 
                            self.__enableScrollX || null == self.__refreshHeight || (0 > scrollTop ? (self.__refreshHidden = !1, 
                            self.__refreshShow()) : (self.__refreshHide(), self.__refreshHidden = !0), !self.__refreshActive && scrollTop <= -self.__refreshHeight ? (self.__refreshActive = !0, 
                            self.__refreshActivate && self.__refreshActivate()) : self.__refreshActive && scrollTop > -self.__refreshHeight && (self.__refreshActive = !1, 
                            self.__refreshDeactivate && self.__refreshDeactivate()))) : scrollTop = scrollTop > maxScrollTop ? maxScrollTop : 0 : self.__refreshHeight && !self.__refreshHidden && (self.__refreshHide(), 
                            self.__refreshHidden = !0);
                        }
                        positions.length > 60 && positions.splice(0, 30), positions.push(scrollLeft, scrollTop, timeStamp), 
                        self.__publish(scrollLeft, scrollTop, level);
                    } else {
                        var minimumTrackingForScroll = self.options.locking ? 3 : 0, minimumTrackingForDrag = 5, distanceX = Math.abs(currentTouchLeft - self.__initialTouchLeft), distanceY = Math.abs(currentTouchTop - self.__initialTouchTop);
                        self.__enableScrollX = self.options.scrollingX && distanceX >= minimumTrackingForScroll, 
                        self.__enableScrollY = self.options.scrollingY && distanceY >= minimumTrackingForScroll, 
                        positions.push(self.__scrollLeft, self.__scrollTop, timeStamp), self.__isDragging = (self.__enableScrollX || self.__enableScrollY) && (distanceX >= minimumTrackingForDrag || distanceY >= minimumTrackingForDrag), 
                        self.__isDragging && (self.__interruptedAnimation = !1, self.__fadeScrollbars("in"));
                    }
                    self.__lastTouchLeft = currentTouchLeft, self.__lastTouchTop = currentTouchTop, 
                    self.__lastTouchMove = timeStamp, self.__lastScale = scale;
                }
            },
            doTouchEnd: function(e, timeStamp) {
                timeStamp instanceof Date && (timeStamp = timeStamp.valueOf()), "number" != typeof timeStamp && (timeStamp = Date.now());
                var self = this;
                if (self.__isTracking) {
                    if (self.__isTracking = !1, self.__isDragging) if (self.__isDragging = !1, self.__isSingleTouch && self.options.animating && timeStamp - self.__lastTouchMove <= 100) {
                        for (var positions = self.__positions, endPos = positions.length - 1, startPos = endPos, i = endPos; i > 0 && positions[i] > self.__lastTouchMove - 100; i -= 3) startPos = i;
                        if (startPos !== endPos) {
                            var timeOffset = positions[endPos] - positions[startPos], movedLeft = self.__scrollLeft - positions[startPos - 2], movedTop = self.__scrollTop - positions[startPos - 1];
                            self.__decelerationVelocityX = movedLeft / timeOffset * (1e3 / 60), self.__decelerationVelocityY = movedTop / timeOffset * (1e3 / 60);
                            var minVelocityToStartDeceleration = self.options.paging || self.options.snapping ? self.options.decelVelocityThresholdPaging : self.options.decelVelocityThreshold;
                            (Math.abs(self.__decelerationVelocityX) > minVelocityToStartDeceleration || Math.abs(self.__decelerationVelocityY) > minVelocityToStartDeceleration) && (self.__refreshActive || self.__startDeceleration(timeStamp));
                        } else self.__scrollingComplete();
                    } else timeStamp - self.__lastTouchMove > 100 && self.__scrollingComplete(); else self.__decStopped && (e.isTapHandled = !0, 
                    self.__decStopped = !1);
                    if (!self.__isDecelerating) if (self.__refreshActive && self.__refreshStart) {
                        self.__publish(self.__scrollLeft, -self.__refreshHeight, self.__zoomLevel, !0);
                        var d = new Date();
                        self.refreshStartTime = d.getTime(), self.__refreshStart && self.__refreshStart(), 
                        ionic.Platform.isAndroid() || self.__startDeceleration();
                    } else (self.__interruptedAnimation || self.__isDragging) && self.__scrollingComplete(), 
                    self.scrollTo(self.__scrollLeft, self.__scrollTop, !0, self.__zoomLevel), self.__refreshActive && (self.__refreshActive = !1, 
                    self.__refreshDeactivate && self.__refreshDeactivate());
                    self.__positions.length = 0;
                }
            },
            __publish: function(left, top, zoom, animate, wasResize) {
                var self = this, wasAnimating = self.__isAnimating;
                if (wasAnimating && (zyngaCore.effect.Animate.stop(wasAnimating), self.__isAnimating = !1), 
                animate && self.options.animating) {
                    self.__scheduledLeft = left, self.__scheduledTop = top, self.__scheduledZoom = zoom;
                    var oldLeft = self.__scrollLeft, oldTop = self.__scrollTop, oldZoom = self.__zoomLevel, diffLeft = left - oldLeft, diffTop = top - oldTop, diffZoom = zoom - oldZoom, step = function(percent, now, render) {
                        render && (self.__scrollLeft = oldLeft + diffLeft * percent, self.__scrollTop = oldTop + diffTop * percent, 
                        self.__zoomLevel = oldZoom + diffZoom * percent, self.__callback && self.__callback(self.__scrollLeft, self.__scrollTop, self.__zoomLevel, wasResize));
                    }, verify = function(id) {
                        return self.__isAnimating === id;
                    }, completed = function(renderedFramesPerSecond, animationId, wasFinished) {
                        animationId === self.__isAnimating && (self.__isAnimating = !1), (self.__didDecelerationComplete || wasFinished) && self.__scrollingComplete(), 
                        self.options.zooming && self.__computeScrollMax();
                    };
                    self.__isAnimating = zyngaCore.effect.Animate.start(step, verify, completed, self.options.animationDuration, wasAnimating ? easeOutCubic : easeInOutCubic);
                } else self.__scheduledLeft = self.__scrollLeft = left, self.__scheduledTop = self.__scrollTop = top, 
                self.__scheduledZoom = self.__zoomLevel = zoom, self.__callback && self.__callback(left, top, zoom, wasResize), 
                self.options.zooming && self.__computeScrollMax();
            },
            __computeScrollMax: function(zoomLevel) {
                var self = this;
                null == zoomLevel && (zoomLevel = self.__zoomLevel), self.__maxScrollLeft = Math.max(self.__contentWidth * zoomLevel - self.__clientWidth, 0), 
                self.__maxScrollTop = Math.max(self.__contentHeight * zoomLevel - self.__clientHeight, 0), 
                self.__didWaitForSize || self.__maxScrollLeft || self.__maxScrollTop || (self.__didWaitForSize = !0, 
                self.__waitForSize());
            },
            __waitForSize: function() {
                var self = this;
                clearTimeout(self.__sizerTimeout);
                var sizer = function() {
                    self.resize(!0);
                };
                sizer(), self.__sizerTimeout = setTimeout(sizer, 500);
            },
            __startDeceleration: function() {
                var self = this;
                if (self.options.paging) {
                    var scrollLeft = Math.max(Math.min(self.__scrollLeft, self.__maxScrollLeft), 0), scrollTop = Math.max(Math.min(self.__scrollTop, self.__maxScrollTop), 0), clientWidth = self.__clientWidth, clientHeight = self.__clientHeight;
                    self.__minDecelerationScrollLeft = Math.floor(scrollLeft / clientWidth) * clientWidth, 
                    self.__minDecelerationScrollTop = Math.floor(scrollTop / clientHeight) * clientHeight, 
                    self.__maxDecelerationScrollLeft = Math.ceil(scrollLeft / clientWidth) * clientWidth, 
                    self.__maxDecelerationScrollTop = Math.ceil(scrollTop / clientHeight) * clientHeight;
                } else self.__minDecelerationScrollLeft = 0, self.__minDecelerationScrollTop = 0, 
                self.__maxDecelerationScrollLeft = self.__maxScrollLeft, self.__maxDecelerationScrollTop = self.__maxScrollTop, 
                self.__refreshActive && (self.__minDecelerationScrollTop = -1 * self.__refreshHeight);
                var step = function(percent, now, render) {
                    self.__stepThroughDeceleration(render);
                };
                self.__minVelocityToKeepDecelerating = self.options.snapping ? 4 : .1;
                var verify = function() {
                    var shouldContinue = Math.abs(self.__decelerationVelocityX) >= self.__minVelocityToKeepDecelerating || Math.abs(self.__decelerationVelocityY) >= self.__minVelocityToKeepDecelerating;
                    return shouldContinue || (self.__didDecelerationComplete = !0, self.options.bouncing && !self.__refreshActive && self.scrollTo(Math.min(Math.max(self.__scrollLeft, 0), self.__maxScrollLeft), Math.min(Math.max(self.__scrollTop, 0), self.__maxScrollTop), self.__refreshActive)), 
                    shouldContinue;
                }, completed = function() {
                    self.__isDecelerating = !1, self.__didDecelerationComplete && self.__scrollingComplete(), 
                    self.options.paging && self.scrollTo(self.__scrollLeft, self.__scrollTop, self.options.snapping);
                };
                self.__isDecelerating = zyngaCore.effect.Animate.start(step, verify, completed);
            },
            __stepThroughDeceleration: function(render) {
                var self = this, scrollLeft = self.__scrollLeft + self.__decelerationVelocityX, scrollTop = self.__scrollTop + self.__decelerationVelocityY;
                if (!self.options.bouncing) {
                    var scrollLeftFixed = Math.max(Math.min(self.__maxDecelerationScrollLeft, scrollLeft), self.__minDecelerationScrollLeft);
                    scrollLeftFixed !== scrollLeft && (scrollLeft = scrollLeftFixed, self.__decelerationVelocityX = 0);
                    var scrollTopFixed = Math.max(Math.min(self.__maxDecelerationScrollTop, scrollTop), self.__minDecelerationScrollTop);
                    scrollTopFixed !== scrollTop && (scrollTop = scrollTopFixed, self.__decelerationVelocityY = 0);
                }
                if (render ? self.__publish(scrollLeft, scrollTop, self.__zoomLevel) : (self.__scrollLeft = scrollLeft, 
                self.__scrollTop = scrollTop), !self.options.paging) {
                    var frictionFactor = self.options.deceleration;
                    self.__decelerationVelocityX *= frictionFactor, self.__decelerationVelocityY *= frictionFactor;
                }
                if (self.options.bouncing) {
                    var scrollOutsideX = 0, scrollOutsideY = 0, penetrationDeceleration = self.options.penetrationDeceleration, penetrationAcceleration = self.options.penetrationAcceleration;
                    if (scrollLeft < self.__minDecelerationScrollLeft ? scrollOutsideX = self.__minDecelerationScrollLeft - scrollLeft : scrollLeft > self.__maxDecelerationScrollLeft && (scrollOutsideX = self.__maxDecelerationScrollLeft - scrollLeft), 
                    scrollTop < self.__minDecelerationScrollTop ? scrollOutsideY = self.__minDecelerationScrollTop - scrollTop : scrollTop > self.__maxDecelerationScrollTop && (scrollOutsideY = self.__maxDecelerationScrollTop - scrollTop), 
                    0 !== scrollOutsideX) {
                        var isHeadingOutwardsX = scrollOutsideX * self.__decelerationVelocityX <= self.__minDecelerationScrollLeft;
                        isHeadingOutwardsX && (self.__decelerationVelocityX += scrollOutsideX * penetrationDeceleration);
                        var isStoppedX = Math.abs(self.__decelerationVelocityX) <= self.__minVelocityToKeepDecelerating;
                        (!isHeadingOutwardsX || isStoppedX) && (self.__decelerationVelocityX = scrollOutsideX * penetrationAcceleration);
                    }
                    if (0 !== scrollOutsideY) {
                        var isHeadingOutwardsY = scrollOutsideY * self.__decelerationVelocityY <= self.__minDecelerationScrollTop;
                        isHeadingOutwardsY && (self.__decelerationVelocityY += scrollOutsideY * penetrationDeceleration);
                        var isStoppedY = Math.abs(self.__decelerationVelocityY) <= self.__minVelocityToKeepDecelerating;
                        (!isHeadingOutwardsY || isStoppedY) && (self.__decelerationVelocityY = scrollOutsideY * penetrationAcceleration);
                    }
                }
            },
            __getDistance: function(touch1, touch2) {
                var x = touch2.pageX - touch1.pageX, y = touch2.pageY - touch1.pageY;
                return Math.sqrt(x * x + y * y);
            },
            __getScale: function(start, end) {
                return start.length >= 2 && end.length >= 2 ? this.__getDistance(end[0], end[1]) / this.__getDistance(start[0], start[1]) : 1;
            }
        }), ionic.scroll = {
            isScrolling: !1,
            lastTop: 0
        };
    }(ionic), function(ionic) {
        var NOOP = function() {}, deprecated = function(name) {};
        ionic.views.ScrollNative = ionic.views.View.inherit({
            initialize: function(options) {
                var self = this;
                self.__container = self.el = options.el, self.__content = options.el.firstElementChild, 
                self.__frozen = !1, self.isNative = !0, self.__scrollTop = self.el.scrollTop, self.__scrollLeft = self.el.scrollLeft, 
                self.__clientHeight = self.__content.clientHeight, self.__clientWidth = self.__content.clientWidth, 
                self.__maxScrollTop = Math.max(self.__contentHeight - self.__clientHeight, 0), self.__maxScrollLeft = Math.max(self.__contentWidth - self.__clientWidth, 0), 
                (options.startY >= 0 || options.startX >= 0) && ionic.requestAnimationFrame(function() {
                    self.el.scrollTop = options.startY || 0, self.el.scrollLeft = options.startX || 0, 
                    self.__scrollTop = self.el.scrollTop, self.__scrollLeft = self.el.scrollLeft;
                }), self.options = {
                    freeze: !1,
                    getContentWidth: function() {
                        return Math.max(self.__content.scrollWidth, self.__content.offsetWidth);
                    },
                    getContentHeight: function() {
                        return Math.max(self.__content.scrollHeight, self.__content.offsetHeight + 2 * self.__content.offsetTop);
                    }
                };
                for (var key in options) self.options[key] = options[key];
                self.onScroll = function() {
                    ionic.scroll.isScrolling || (ionic.scroll.isScrolling = !0), clearTimeout(self.scrollTimer), 
                    self.scrollTimer = setTimeout(function() {
                        ionic.scroll.isScrolling = !1;
                    }, 80);
                }, self.freeze = function(shouldFreeze) {
                    self.__frozen = shouldFreeze;
                }, self.freezeShut = function(shouldFreezeShut) {
                    self.__frozenShut = shouldFreezeShut;
                }, self.__initEventHandlers();
            },
            __callback: function() {
                deprecated("__callback");
            },
            zoomTo: function() {
                deprecated("zoomTo");
            },
            zoomBy: function() {
                deprecated("zoomBy");
            },
            activatePullToRefresh: function() {
                deprecated("activatePullToRefresh");
            },
            resize: function(continueScrolling) {
                var self = this;
                self.__container && self.options && self.setDimensions(self.__container.clientWidth, self.__container.clientHeight, self.options.getContentWidth(), self.options.getContentHeight(), continueScrolling);
            },
            run: function() {
                this.resize();
            },
            getValues: function() {
                var self = this;
                return self.update(), {
                    left: self.__scrollLeft,
                    top: self.__scrollTop,
                    zoom: 1
                };
            },
            update: function() {
                var self = this;
                self.__scrollLeft = self.el.scrollLeft, self.__scrollTop = self.el.scrollTop;
            },
            setDimensions: function(clientWidth, clientHeight, contentWidth, contentHeight) {
                var self = this;
                (clientWidth || clientHeight || contentWidth || contentHeight) && (clientWidth === +clientWidth && (self.__clientWidth = clientWidth), 
                clientHeight === +clientHeight && (self.__clientHeight = clientHeight), contentWidth === +contentWidth && (self.__contentWidth = contentWidth), 
                contentHeight === +contentHeight && (self.__contentHeight = contentHeight), self.__computeScrollMax());
            },
            getScrollMax: function() {
                return {
                    left: this.__maxScrollLeft,
                    top: this.__maxScrollTop
                };
            },
            scrollBy: function(left, top, animate) {
                var self = this;
                self.update();
                var startLeft = self.__isAnimating ? self.__scheduledLeft : self.__scrollLeft, startTop = self.__isAnimating ? self.__scheduledTop : self.__scrollTop;
                self.scrollTo(startLeft + (left || 0), startTop + (top || 0), animate);
            },
            scrollTo: function(left, top, animate) {
                function animateScroll(Y, X) {
                    function easeOutCubic(t) {
                        return --t * t * t + 1;
                    }
                    function animateScrollStep() {
                        var currentTime = Date.now(), time = Math.min(1, (currentTime - start) / duration), easedT = easeOutCubic(time);
                        fromY != Y && (self.el.scrollTop = parseInt(easedT * (Y - fromY) + fromY, 10)), 
                        fromX != X && (self.el.scrollLeft = parseInt(easedT * (X - fromX) + fromX, 10)), 
                        1 > time ? ionic.requestAnimationFrame(animateScrollStep) : (ionic.tap.removeClonedInputs(self.__container, self), 
                        self.el.style.overflowX = oldOverflowX, self.el.style.overflowY = oldOverflowY, 
                        self.resize());
                    }
                    var start = Date.now(), duration = 250, fromY = self.el.scrollTop, fromX = self.el.scrollLeft;
                    return fromY === Y && fromX === X ? (self.el.style.overflowX = oldOverflowX, self.el.style.overflowY = oldOverflowY, 
                    void self.resize()) : void ionic.requestAnimationFrame(animateScrollStep);
                }
                var self = this;
                if (!animate) return self.el.scrollTop = top, self.el.scrollLeft = left, void self.resize();
                var oldOverflowX = self.el.style.overflowX, oldOverflowY = self.el.style.overflowY;
                clearTimeout(self.__scrollToCleanupTimeout), self.__scrollToCleanupTimeout = setTimeout(function() {
                    self.el.style.overflowX = oldOverflowX, self.el.style.overflowY = oldOverflowY;
                }, 500), self.el.style.overflowY = "hidden", self.el.style.overflowX = "hidden", 
                animateScroll(top, left);
            },
            __waitForSize: function() {
                var self = this;
                clearTimeout(self.__sizerTimeout);
                var sizer = function() {
                    self.resize(!0);
                };
                sizer(), self.__sizerTimeout = setTimeout(sizer, 500);
            },
            __computeScrollMax: function() {
                var self = this;
                self.__maxScrollLeft = Math.max(self.__contentWidth - self.__clientWidth, 0), self.__maxScrollTop = Math.max(self.__contentHeight - self.__clientHeight, 0), 
                self.__didWaitForSize || self.__maxScrollLeft || self.__maxScrollTop || (self.__didWaitForSize = !0, 
                self.__waitForSize());
            },
            __initEventHandlers: function() {
                var scrollViewOffsetHeight, lastKeyboardHeight, self = this, container = self.__container;
                self.scrollChildIntoView = function(e) {
                    var rect = container.getBoundingClientRect();
                    self.__originalContainerHeight || (self.__originalContainerHeight = rect.height), 
                    scrollViewOffsetHeight = self.__originalContainerHeight;
                    var alreadyShrunk = self.isShrunkForKeyboard, isModal = container.parentNode.classList.contains("modal"), isPopover = container.parentNode.classList.contains("popover"), isInsetModal = isModal && window.innerWidth >= 680, changedKeyboardHeight = lastKeyboardHeight && lastKeyboardHeight !== e.detail.keyboardHeight;
                    (!alreadyShrunk || changedKeyboardHeight) && (!isPopover && (ionic.Platform.isIOS() || ionic.Platform.isFullScreen || isInsetModal) && ionic.requestAnimationFrame(function() {
                        scrollViewOffsetHeight = Math.max(0, Math.min(self.__originalContainerHeight, self.__originalContainerHeight - (e.detail.keyboardHeight - 43))), 
                        container.style.height = scrollViewOffsetHeight + "px", container.classList.add("keyboard-up"), 
                        self.resize();
                    }), self.isShrunkForKeyboard = !0), lastKeyboardHeight = e.detail.keyboardHeight, 
                    e.detail.isElementUnderKeyboard && ionic.requestAnimationFrame(function() {
                        var pos = ionic.DomUtil.getOffsetTop(e.detail.target);
                        setTimeout(function() {
                            ionic.Platform.isIOS() && ionic.tap.cloneFocusedInput(container, self), self.scrollTo(0, pos - (rect.top + 100), !0), 
                            self.onScroll();
                        }, 32);
                    }), e.stopPropagation();
                }, self.resetScrollView = function() {
                    self.isShrunkForKeyboard && (self.isShrunkForKeyboard = !1, container.style.height = "", 
                    self.__originalContainerHeight = container.getBoundingClientRect().height, ionic.Platform.isIOS() && ionic.requestAnimationFrame(function() {
                        container.classList.remove("keyboard-up");
                    })), self.resize();
                }, self.handleTouchMove = function(e) {
                    return self.__frozenShut ? (e.preventDefault(), e.stopPropagation(), !1) : void 0;
                }, container.addEventListener("scroll", self.onScroll), container.addEventListener("scrollChildIntoView", self.scrollChildIntoView), 
                container.addEventListener(ionic.EVENTS.touchstart, self.handleTouchMove), container.addEventListener(ionic.EVENTS.touchmove, self.handleTouchMove), 
                document.addEventListener("resetScrollView", self.resetScrollView);
            },
            __cleanup: function() {
                var self = this, container = self.__container;
                container.removeEventListener("resetScrollView", self.resetScrollView), container.removeEventListener("scroll", self.onScroll), 
                container.removeEventListener("scrollChildIntoView", self.scrollChildIntoView), 
                container.removeEventListener("resetScrollView", self.resetScrollView), container.removeEventListener(ionic.EVENTS.touchstart, self.handleTouchMove), 
                container.removeEventListener(ionic.EVENTS.touchmove, self.handleTouchMove), ionic.tap.removeClonedInputs(container, self), 
                delete self.__container, delete self.__content, delete self.__indicatorX, delete self.__indicatorY, 
                delete self.options.el, self.resize = self.scrollTo = self.onScroll = self.resetScrollView = NOOP, 
                self.scrollChildIntoView = NOOP, container = null;
            }
        });
    }(ionic), function(ionic) {
        "use strict";
        var ITEM_CLASS = "item", ITEM_CONTENT_CLASS = "item-content", ITEM_SLIDING_CLASS = "item-sliding", ITEM_OPTIONS_CLASS = "item-options", ITEM_PLACEHOLDER_CLASS = "item-placeholder", ITEM_REORDERING_CLASS = "item-reordering", ITEM_REORDER_BTN_CLASS = "item-reorder", DragOp = function() {};
        DragOp.prototype = {
            start: function() {},
            drag: function() {},
            end: function() {},
            isSameItem: function() {
                return !1;
            }
        };
        var SlideDrag = function(opts) {
            this.dragThresholdX = opts.dragThresholdX || 10, this.el = opts.el, this.item = opts.item, 
            this.canSwipe = opts.canSwipe;
        };
        SlideDrag.prototype = new DragOp(), SlideDrag.prototype.start = function(e) {
            var content, buttons, offsetX, buttonsWidth;
            this.canSwipe() && (content = e.target.classList.contains(ITEM_CONTENT_CLASS) ? e.target : e.target.classList.contains(ITEM_CLASS) ? e.target.querySelector("." + ITEM_CONTENT_CLASS) : ionic.DomUtil.getParentWithClass(e.target, ITEM_CONTENT_CLASS), 
            content && (content.classList.remove(ITEM_SLIDING_CLASS), offsetX = parseFloat(content.style[ionic.CSS.TRANSFORM].replace("translate3d(", "").split(",")[0]) || 0, 
            buttons = content.parentNode.querySelector("." + ITEM_OPTIONS_CLASS), buttons && (buttons.classList.remove("invisible"), 
            buttonsWidth = buttons.offsetWidth, this._currentDrag = {
                buttons: buttons,
                buttonsWidth: buttonsWidth,
                content: content,
                startOffsetX: offsetX
            })));
        }, SlideDrag.prototype.isSameItem = function(op) {
            return op._lastDrag && this._currentDrag ? this._currentDrag.content == op._lastDrag.content : !1;
        }, SlideDrag.prototype.clean = function(isInstant) {
            function makeInvisible() {
                lastDrag.buttons && lastDrag.buttons.classList.add("invisible");
            }
            var lastDrag = this._lastDrag;
            lastDrag && lastDrag.content && (lastDrag.content.style[ionic.CSS.TRANSITION] = "", 
            lastDrag.content.style[ionic.CSS.TRANSFORM] = "", isInstant ? (lastDrag.content.style[ionic.CSS.TRANSITION] = "none", 
            makeInvisible(), ionic.requestAnimationFrame(function() {
                lastDrag.content.style[ionic.CSS.TRANSITION] = "";
            })) : ionic.requestAnimationFrame(function() {
                setTimeout(makeInvisible, 250);
            }));
        }, SlideDrag.prototype.drag = ionic.animationFrameThrottle(function(e) {
            var buttonsWidth;
            if (this._currentDrag && (!this._isDragging && (Math.abs(e.gesture.deltaX) > this.dragThresholdX || Math.abs(this._currentDrag.startOffsetX) > 0) && (this._isDragging = !0), 
            this._isDragging)) {
                buttonsWidth = this._currentDrag.buttonsWidth;
                var newX = Math.min(0, this._currentDrag.startOffsetX + e.gesture.deltaX);
                -buttonsWidth > newX && (newX = Math.min(-buttonsWidth, -buttonsWidth + .4 * (e.gesture.deltaX + buttonsWidth))), 
                this._currentDrag.content.$$ionicOptionsOpen = 0 !== newX, this._currentDrag.content.style[ionic.CSS.TRANSFORM] = "translate3d(" + newX + "px, 0, 0)", 
                this._currentDrag.content.style[ionic.CSS.TRANSITION] = "none";
            }
        }), SlideDrag.prototype.end = function(e, doneCallback) {
            var self = this;
            if (!self._currentDrag) return void (doneCallback && doneCallback());
            var restingPoint = -self._currentDrag.buttonsWidth;
            e.gesture.deltaX > -(self._currentDrag.buttonsWidth / 2) && ("left" == e.gesture.direction && Math.abs(e.gesture.velocityX) < .3 ? restingPoint = 0 : "right" == e.gesture.direction && (restingPoint = 0)), 
            ionic.requestAnimationFrame(function() {
                if (0 === restingPoint) {
                    self._currentDrag.content.style[ionic.CSS.TRANSFORM] = "";
                    var buttons = self._currentDrag.buttons;
                    setTimeout(function() {
                        buttons && buttons.classList.add("invisible");
                    }, 250);
                } else self._currentDrag.content.style[ionic.CSS.TRANSFORM] = "translate3d(" + restingPoint + "px,0,0)";
                self._currentDrag.content.style[ionic.CSS.TRANSITION] = "", self._lastDrag || (self._lastDrag = {}), 
                ionic.extend(self._lastDrag, self._currentDrag), self._currentDrag && (self._currentDrag.buttons = null, 
                self._currentDrag.content = null), self._currentDrag = null, doneCallback && doneCallback();
            });
        };
        var ReorderDrag = function(opts) {
            var self = this;
            if (self.dragThresholdY = opts.dragThresholdY || 0, self.onReorder = opts.onReorder, 
            self.listEl = opts.listEl, self.el = self.item = opts.el, self.scrollEl = opts.scrollEl, 
            self.scrollView = opts.scrollView, self.listElTrueTop = 0, self.listEl.offsetParent) {
                var obj = self.listEl;
                do self.listElTrueTop += obj.offsetTop, obj = obj.offsetParent; while (obj);
            }
        };
        ReorderDrag.prototype = new DragOp(), ReorderDrag.prototype._moveElement = function(e) {
            var y = e.gesture.center.pageY + this.scrollView.getValues().top - this._currentDrag.elementHeight / 2 - this.listElTrueTop;
            this.el.style[ionic.CSS.TRANSFORM] = "translate3d(0, " + y + "px, 0)";
        }, ReorderDrag.prototype.deregister = function() {
            this.listEl = this.el = this.scrollEl = this.scrollView = null;
        }, ReorderDrag.prototype.start = function(e) {
            var startIndex = ionic.DomUtil.getChildIndex(this.el, this.el.nodeName.toLowerCase()), elementHeight = this.el.scrollHeight, placeholder = this.el.cloneNode(!0);
            placeholder.classList.add(ITEM_PLACEHOLDER_CLASS), this.el.parentNode.insertBefore(placeholder, this.el), 
            this.el.classList.add(ITEM_REORDERING_CLASS), this._currentDrag = {
                elementHeight: elementHeight,
                startIndex: startIndex,
                placeholder: placeholder,
                scrollHeight: scroll,
                list: placeholder.parentNode
            }, this._moveElement(e);
        }, ReorderDrag.prototype.drag = ionic.animationFrameThrottle(function(e) {
            var self = this;
            if (this._currentDrag) {
                var scrollY = 0, pageY = e.gesture.center.pageY, offset = this.listElTrueTop;
                if (this.scrollView) {
                    var container = this.scrollView.__container;
                    scrollY = this.scrollView.getValues().top;
                    var containerTop = container.offsetTop, pixelsPastTop = containerTop - pageY + this._currentDrag.elementHeight / 2, pixelsPastBottom = pageY + this._currentDrag.elementHeight / 2 - containerTop - container.offsetHeight;
                    e.gesture.deltaY < 0 && pixelsPastTop > 0 && scrollY > 0 && (this.scrollView.scrollBy(null, -pixelsPastTop), 
                    ionic.requestAnimationFrame(function() {
                        self.drag(e);
                    })), e.gesture.deltaY > 0 && pixelsPastBottom > 0 && scrollY < this.scrollView.getScrollMax().top && (this.scrollView.scrollBy(null, pixelsPastBottom), 
                    ionic.requestAnimationFrame(function() {
                        self.drag(e);
                    }));
                }
                !this._isDragging && Math.abs(e.gesture.deltaY) > this.dragThresholdY && (this._isDragging = !0), 
                this._isDragging && (this._moveElement(e), this._currentDrag.currentY = scrollY + pageY - offset);
            }
        }), ReorderDrag.prototype._getReorderIndex = function() {
            for (var el, self = this, siblings = Array.prototype.slice.call(self._currentDrag.placeholder.parentNode.children).filter(function(el) {
                return el.nodeName === self.el.nodeName && el !== self.el;
            }), dragOffsetTop = self._currentDrag.currentY, i = 0, len = siblings.length; len > i; i++) if (el = siblings[i], 
            i === len - 1) {
                if (dragOffsetTop > el.offsetTop) return i;
            } else if (0 === i) {
                if (dragOffsetTop < el.offsetTop + el.offsetHeight) return i;
            } else if (dragOffsetTop > el.offsetTop - el.offsetHeight / 2 && dragOffsetTop < el.offsetTop + el.offsetHeight) return i;
            return self._currentDrag.startIndex;
        }, ReorderDrag.prototype.end = function(e, doneCallback) {
            if (!this._currentDrag) return void (doneCallback && doneCallback());
            var placeholder = this._currentDrag.placeholder, finalIndex = this._getReorderIndex();
            this.el.classList.remove(ITEM_REORDERING_CLASS), this.el.style[ionic.CSS.TRANSFORM] = "", 
            placeholder.parentNode.insertBefore(this.el, placeholder), placeholder.parentNode.removeChild(placeholder), 
            this.onReorder && this.onReorder(this.el, this._currentDrag.startIndex, finalIndex), 
            this._currentDrag = {
                placeholder: null,
                content: null
            }, this._currentDrag = null, doneCallback && doneCallback();
        }, ionic.views.ListView = ionic.views.View.inherit({
            initialize: function(opts) {
                var self = this;
                opts = ionic.extend({
                    onReorder: function() {},
                    virtualRemoveThreshold: -200,
                    virtualAddThreshold: 200,
                    canSwipe: function() {
                        return !0;
                    }
                }, opts), ionic.extend(self, opts), !self.itemHeight && self.listEl && (self.itemHeight = self.listEl.children[0] && parseInt(self.listEl.children[0].style.height, 10)), 
                self.onRefresh = opts.onRefresh || function() {}, self.onRefreshOpening = opts.onRefreshOpening || function() {}, 
                self.onRefreshHolding = opts.onRefreshHolding || function() {};
                var gestureOpts = {};
                ionic.DomUtil.getParentOrSelfWithClass(self.el, "overflow-scroll") && (gestureOpts.prevent_default_directions = [ "left", "right" ]), 
                window.ionic.onGesture("release", function(e) {
                    self._handleEndDrag(e);
                }, self.el, gestureOpts), window.ionic.onGesture("drag", function(e) {
                    self._handleDrag(e);
                }, self.el, gestureOpts), self._initDrag();
            },
            deregister: function() {
                this.el = this.listEl = this.scrollEl = this.scrollView = null, this.isScrollFreeze && self.scrollView.freeze(!1);
            },
            stopRefreshing: function() {
                var refresher = this.el.querySelector(".list-refresher");
                refresher.style.height = "0";
            },
            didScroll: function(e) {
                var self = this;
                if (self.isVirtual) {
                    var itemHeight = self.itemHeight, scrollHeight = e.target.scrollHeight, viewportHeight = self.el.parentNode.offsetHeight, highWater = Math.max(0, e.scrollTop + self.virtualRemoveThreshold), lowWater = Math.min(scrollHeight, Math.abs(e.scrollTop) + viewportHeight + self.virtualAddThreshold), first = parseInt(Math.abs(highWater / itemHeight), 10), last = parseInt(Math.abs(lowWater / itemHeight), 10);
                    self._virtualItemsToRemove = Array.prototype.slice.call(self.listEl.children, 0, first), 
                    self.renderViewport && self.renderViewport(highWater, lowWater, first, last);
                }
            },
            didStopScrolling: function() {
                if (this.isVirtual) for (var i = 0; i < this._virtualItemsToRemove.length; i++) this.didHideItem && this.didHideItem(i);
            },
            clearDragEffects: function(isInstant) {
                this._lastDragOp && (this._lastDragOp.clean && this._lastDragOp.clean(isInstant), 
                this._lastDragOp.deregister && this._lastDragOp.deregister(), this._lastDragOp = null);
            },
            _initDrag: function() {
                this._lastDragOp && this._lastDragOp.deregister && this._lastDragOp.deregister(), 
                this._lastDragOp = this._dragOp, this._dragOp = null;
            },
            _getItem: function(target) {
                for (;target; ) {
                    if (target.classList && target.classList.contains(ITEM_CLASS)) return target;
                    target = target.parentNode;
                }
                return null;
            },
            _startDrag: function(e) {
                var self = this;
                self._isDragging = !1;
                var item, lastDragOp = self._lastDragOp;
                self._didDragUpOrDown && lastDragOp instanceof SlideDrag && lastDragOp.clean && lastDragOp.clean(), 
                !ionic.DomUtil.getParentOrSelfWithClass(e.target, ITEM_REORDER_BTN_CLASS) || "up" != e.gesture.direction && "down" != e.gesture.direction ? !self._didDragUpOrDown && ("left" == e.gesture.direction || "right" == e.gesture.direction) && Math.abs(e.gesture.deltaX) > 5 && (item = self._getItem(e.target), 
                item && item.querySelector(".item-options") && (self._dragOp = new SlideDrag({
                    el: self.el,
                    item: item,
                    canSwipe: self.canSwipe
                }), self._dragOp.start(e), e.preventDefault(), self.isScrollFreeze = self.scrollView.freeze(!0))) : (item = self._getItem(e.target), 
                item && (self._dragOp = new ReorderDrag({
                    listEl: self.el,
                    el: item,
                    scrollEl: self.scrollEl,
                    scrollView: self.scrollView,
                    onReorder: function(el, start, end) {
                        self.onReorder && self.onReorder(el, start, end);
                    }
                }), self._dragOp.start(e), e.preventDefault())), lastDragOp && self._dragOp && !self._dragOp.isSameItem(lastDragOp) && e.defaultPrevented && lastDragOp.clean && lastDragOp.clean();
            },
            _handleEndDrag: function(e) {
                var self = this;
                self.scrollView && (self.isScrollFreeze = self.scrollView.freeze(!1)), self._didDragUpOrDown = !1, 
                self._dragOp && self._dragOp.end(e, function() {
                    self._initDrag();
                });
            },
            _handleDrag: function(e) {
                var self = this;
                Math.abs(e.gesture.deltaY) > 5 && (self._didDragUpOrDown = !0), self.isDragging || self._dragOp || self._startDrag(e), 
                self._dragOp && (e.gesture.srcEvent.preventDefault(), self._dragOp.drag(e));
            }
        });
    }(ionic), function(ionic) {
        "use strict";
        ionic.views.Modal = ionic.views.View.inherit({
            initialize: function(opts) {
                opts = ionic.extend({
                    focusFirstInput: !1,
                    unfocusOnHide: !0,
                    focusFirstDelay: 600,
                    backdropClickToClose: !0,
                    hardwareBackButtonClose: !0
                }, opts), ionic.extend(this, opts), this.el = opts.el;
            },
            show: function() {
                var self = this;
                self.focusFirstInput && window.setTimeout(function() {
                    var input = self.el.querySelector("input, textarea");
                    input && input.focus && input.focus();
                }, self.focusFirstDelay);
            },
            hide: function() {
                if (this.unfocusOnHide) {
                    var inputs = this.el.querySelectorAll("input, textarea");
                    window.setTimeout(function() {
                        for (var i = 0; i < inputs.length; i++) inputs[i].blur && inputs[i].blur();
                    });
                }
            }
        });
    }(ionic), function(ionic) {
        "use strict";
        ionic.views.SideMenu = ionic.views.View.inherit({
            initialize: function(opts) {
                this.el = opts.el, this.isEnabled = "undefined" == typeof opts.isEnabled ? !0 : opts.isEnabled, 
                this.setWidth(opts.width);
            },
            getFullWidth: function() {
                return this.width;
            },
            setWidth: function(width) {
                this.width = width, this.el.style.width = width + "px";
            },
            setIsEnabled: function(isEnabled) {
                this.isEnabled = isEnabled;
            },
            bringUp: function() {
                "0" !== this.el.style.zIndex && (this.el.style.zIndex = "0");
            },
            pushDown: function() {
                "-1" !== this.el.style.zIndex && (this.el.style.zIndex = "-1");
            }
        }), ionic.views.SideMenuContent = ionic.views.View.inherit({
            initialize: function(opts) {
                ionic.extend(this, {
                    animationClass: "menu-animated",
                    onDrag: function() {},
                    onEndDrag: function() {}
                }, opts), ionic.onGesture("drag", ionic.proxy(this._onDrag, this), this.el), ionic.onGesture("release", ionic.proxy(this._onEndDrag, this), this.el);
            },
            _onDrag: function(e) {
                this.onDrag && this.onDrag(e);
            },
            _onEndDrag: function(e) {
                this.onEndDrag && this.onEndDrag(e);
            },
            disableAnimation: function() {
                this.el.classList.remove(this.animationClass);
            },
            enableAnimation: function() {
                this.el.classList.add(this.animationClass);
            },
            getTranslateX: function() {
                return parseFloat(this.el.style[ionic.CSS.TRANSFORM].replace("translate3d(", "").split(",")[0]);
            },
            setTranslateX: ionic.animationFrameThrottle(function(x) {
                this.el.style[ionic.CSS.TRANSFORM] = "translate3d(" + x + "px, 0, 0)";
            })
        });
    }(ionic), function(ionic) {
        "use strict";
        ionic.views.Slider = ionic.views.View.inherit({
            initialize: function(options) {
                function setup() {
                    if (container.offsetWidth) {
                        slides = element.children, length = slides.length, slides.length < 2 && (options.continuous = !1), 
                        browser.transitions && options.continuous && slides.length < 3 && (element.appendChild(slides[0].cloneNode(!0)), 
                        element.appendChild(element.children[1].cloneNode(!0)), slides = element.children), 
                        slidePos = new Array(slides.length), width = container.offsetWidth || container.getBoundingClientRect().width, 
                        element.style.width = slides.length * width + "px";
                        for (var pos = slides.length; pos--; ) {
                            var slide = slides[pos];
                            slide.style.width = width + "px", slide.setAttribute("data-index", pos), browser.transitions && (slide.style.left = pos * -width + "px", 
                            move(pos, index > pos ? -width : pos > index ? width : 0, 0));
                        }
                        options.continuous && browser.transitions && (move(circle(index - 1), -width, 0), 
                        move(circle(index + 1), width, 0)), browser.transitions || (element.style.left = index * -width + "px"), 
                        container.style.visibility = "visible", options.slidesChanged && options.slidesChanged();
                    }
                }
                function prev(slideSpeed) {
                    options.continuous ? slide(index - 1, slideSpeed) : index && slide(index - 1, slideSpeed);
                }
                function next(slideSpeed) {
                    options.continuous ? slide(index + 1, slideSpeed) : index < slides.length - 1 && slide(index + 1, slideSpeed);
                }
                function circle(index) {
                    return (slides.length + index % slides.length) % slides.length;
                }
                function slide(to, slideSpeed) {
                    if (index != to) {
                        if (!slides) return void (index = to);
                        if (browser.transitions) {
                            var direction = Math.abs(index - to) / (index - to);
                            if (options.continuous) {
                                var naturalDirection = direction;
                                direction = -slidePos[circle(to)] / width, direction !== naturalDirection && (to = -direction * slides.length + to);
                            }
                            for (var diff = Math.abs(index - to) - 1; diff--; ) move(circle((to > index ? to : index) - diff - 1), width * direction, 0);
                            to = circle(to), move(index, width * direction, slideSpeed || speed), move(to, 0, slideSpeed || speed), 
                            options.continuous && move(circle(to - direction), -(width * direction), 0);
                        } else to = circle(to), animate(index * -width, to * -width, slideSpeed || speed);
                        index = to, offloadFn(options.callback && options.callback(index, slides[index]));
                    }
                }
                function move(index, dist, speed) {
                    translate(index, dist, speed), slidePos[index] = dist;
                }
                function translate(index, dist, speed) {
                    var slide = slides[index], style = slide && slide.style;
                    style && (style.webkitTransitionDuration = style.MozTransitionDuration = style.msTransitionDuration = style.OTransitionDuration = style.transitionDuration = speed + "ms", 
                    style.webkitTransform = "translate(" + dist + "px,0)translateZ(0)", style.msTransform = style.MozTransform = style.OTransform = "translateX(" + dist + "px)");
                }
                function animate(from, to, speed) {
                    if (!speed) return void (element.style.left = to + "px");
                    var start = +new Date(), timer = setInterval(function() {
                        var timeElap = +new Date() - start;
                        return timeElap > speed ? (element.style.left = to + "px", delay && begin(), options.transitionEnd && options.transitionEnd.call(event, index, slides[index]), 
                        void clearInterval(timer)) : void (element.style.left = (to - from) * (Math.floor(timeElap / speed * 100) / 100) + from + "px");
                    }, 4);
                }
                function begin() {
                    interval = setTimeout(next, delay);
                }
                function stop() {
                    delay = options.auto || 0, clearTimeout(interval);
                }
                var touchStartEvent, touchMoveEvent, touchEndEvent, slider = this;
                window.navigator.pointerEnabled ? (touchStartEvent = "pointerdown", touchMoveEvent = "pointermove", 
                touchEndEvent = "pointerup") : window.navigator.msPointerEnabled ? (touchStartEvent = "MSPointerDown", 
                touchMoveEvent = "MSPointerMove", touchEndEvent = "MSPointerUp") : (touchStartEvent = "touchstart", 
                touchMoveEvent = "touchmove", touchEndEvent = "touchend");
                var mouseStartEvent = "mousedown", mouseMoveEvent = "mousemove", mouseEndEvent = "mouseup", noop = function() {}, offloadFn = function(fn) {
                    setTimeout(fn || noop, 0);
                }, browser = {
                    addEventListener: !!window.addEventListener,
                    transitions: function(temp) {
                        var props = [ "transitionProperty", "WebkitTransition", "MozTransition", "OTransition", "msTransition" ];
                        for (var i in props) if (void 0 !== temp.style[props[i]]) return !0;
                        return !1;
                    }(document.createElement("swipe"))
                }, container = options.el;
                if (container) {
                    var slides, slidePos, width, length, element = container.children[0];
                    options = options || {};
                    var index = parseInt(options.startSlide, 10) || 0, speed = options.speed || 300;
                    options.continuous = void 0 !== options.continuous ? options.continuous : !0;
                    var interval, isScrolling, delay = options.auto || 0, start = {}, delta = {}, events = {
                        handleEvent: function(event) {
                            switch (!event.touches && event.pageX && event.pageY && (event.touches = [ {
                                pageX: event.pageX,
                                pageY: event.pageY
                            } ]), event.type) {
                              case touchStartEvent:
                                this.start(event);
                                break;

                              case mouseStartEvent:
                                this.start(event);
                                break;

                              case touchMoveEvent:
                                this.touchmove(event);
                                break;

                              case mouseMoveEvent:
                                this.touchmove(event);
                                break;

                              case touchEndEvent:
                                offloadFn(this.end(event));
                                break;

                              case mouseEndEvent:
                                offloadFn(this.end(event));
                                break;

                              case "webkitTransitionEnd":
                              case "msTransitionEnd":
                              case "oTransitionEnd":
                              case "otransitionend":
                              case "transitionend":
                                offloadFn(this.transitionEnd(event));
                                break;

                              case "resize":
                                offloadFn(setup);
                            }
                            options.stopPropagation && event.stopPropagation();
                        },
                        start: function(event) {
                            if (event.touches) {
                                var touches = event.touches[0];
                                start = {
                                    x: touches.pageX,
                                    y: touches.pageY,
                                    time: +new Date()
                                }, isScrolling = void 0, delta = {}, element.addEventListener(touchMoveEvent, this, !1), 
                                element.addEventListener(mouseMoveEvent, this, !1), element.addEventListener(touchEndEvent, this, !1), 
                                element.addEventListener(mouseEndEvent, this, !1), document.addEventListener(touchEndEvent, this, !1), 
                                document.addEventListener(mouseEndEvent, this, !1);
                            }
                        },
                        touchmove: function(event) {
                            if (!(!event.touches || event.touches.length > 1 || event.scale && 1 !== event.scale || slider.slideIsDisabled)) {
                                options.disableScroll && event.preventDefault();
                                var touches = event.touches[0];
                                delta = {
                                    x: touches.pageX - start.x,
                                    y: touches.pageY - start.y
                                }, "undefined" == typeof isScrolling && (isScrolling = !!(isScrolling || Math.abs(delta.x) < Math.abs(delta.y))), 
                                isScrolling || (event.preventDefault(), stop(), options.continuous ? (translate(circle(index - 1), delta.x + slidePos[circle(index - 1)], 0), 
                                translate(index, delta.x + slidePos[index], 0), translate(circle(index + 1), delta.x + slidePos[circle(index + 1)], 0)) : (options.bouncing ? delta.x = delta.x / (!index && delta.x > 0 || index == slides.length - 1 && delta.x < 0 ? Math.abs(delta.x) / width + 1 : 1) : (width * index - delta.x < 0 && (delta.x = Math.min(delta.x, width * index)), 
                                Math.abs(delta.x) > width * (slides.length - index - 1) && (delta.x = Math.max(-width * (slides.length - index - 1), delta.x))), 
                                translate(index - 1, delta.x + slidePos[index - 1], 0), translate(index, delta.x + slidePos[index], 0), 
                                translate(index + 1, delta.x + slidePos[index + 1], 0)), options.onDrag && options.onDrag());
                            }
                        },
                        end: function() {
                            var duration = +new Date() - start.time, isValidSlide = Number(duration) < 250 && Math.abs(delta.x) > 20 || Math.abs(delta.x) > width / 2, isPastBounds = !index && delta.x > 0 || index == slides.length - 1 && delta.x < 0;
                            options.continuous && (isPastBounds = !1);
                            var direction = delta.x < 0;
                            isScrolling || (isValidSlide && !isPastBounds ? (direction ? (options.continuous ? (move(circle(index - 1), -width, 0), 
                            move(circle(index + 2), width, 0)) : move(index - 1, -width, 0), move(index, slidePos[index] - width, speed), 
                            move(circle(index + 1), slidePos[circle(index + 1)] - width, speed), index = circle(index + 1)) : (options.continuous ? (move(circle(index + 1), width, 0), 
                            move(circle(index - 2), -width, 0)) : move(index + 1, width, 0), move(index, slidePos[index] + width, speed), 
                            move(circle(index - 1), slidePos[circle(index - 1)] + width, speed), index = circle(index - 1)), 
                            options.callback && options.callback(index, slides[index])) : options.continuous ? (move(circle(index - 1), -width, speed), 
                            move(index, 0, speed), move(circle(index + 1), width, speed)) : (move(index - 1, -width, speed), 
                            move(index, 0, speed), move(index + 1, width, speed))), element.removeEventListener(touchMoveEvent, events, !1), 
                            element.removeEventListener(mouseMoveEvent, events, !1), element.removeEventListener(touchEndEvent, events, !1), 
                            element.removeEventListener(mouseEndEvent, events, !1), document.removeEventListener(touchEndEvent, events, !1), 
                            document.removeEventListener(mouseEndEvent, events, !1), options.onDragEnd && options.onDragEnd();
                        },
                        transitionEnd: function(event) {
                            parseInt(event.target.getAttribute("data-index"), 10) == index && (delay && begin(), 
                            options.transitionEnd && options.transitionEnd.call(event, index, slides[index]));
                        }
                    };
                    this.update = function() {
                        setTimeout(setup);
                    }, this.setup = function() {
                        setup();
                    }, this.loop = function(value) {
                        return arguments.length && (options.continuous = !!value), options.continuous;
                    }, this.enableSlide = function(shouldEnable) {
                        return arguments.length && (this.slideIsDisabled = !shouldEnable), !this.slideIsDisabled;
                    }, this.slide = this.select = function(to, speed) {
                        stop(), slide(to, speed);
                    }, this.prev = this.previous = function() {
                        stop(), prev();
                    }, this.next = function() {
                        stop(), next();
                    }, this.stop = function() {
                        stop();
                    }, this.start = function() {
                        begin();
                    }, this.autoPlay = function(newDelay) {
                        !delay || 0 > delay ? stop() : (delay = newDelay, begin());
                    }, this.currentIndex = this.selected = function() {
                        return index;
                    }, this.slidesCount = this.count = function() {
                        return length;
                    }, this.kill = function() {
                        stop(), element.style.width = "", element.style.left = "", slides && (slides = []), 
                        browser.addEventListener ? (element.removeEventListener(touchStartEvent, events, !1), 
                        element.removeEventListener(mouseStartEvent, events, !1), element.removeEventListener("webkitTransitionEnd", events, !1), 
                        element.removeEventListener("msTransitionEnd", events, !1), element.removeEventListener("oTransitionEnd", events, !1), 
                        element.removeEventListener("otransitionend", events, !1), element.removeEventListener("transitionend", events, !1), 
                        window.removeEventListener("resize", events, !1)) : window.onresize = null;
                    }, this.load = function() {
                        setup(), delay && begin(), browser.addEventListener ? (element.addEventListener(touchStartEvent, events, !1), 
                        element.addEventListener(mouseStartEvent, events, !1), browser.transitions && (element.addEventListener("webkitTransitionEnd", events, !1), 
                        element.addEventListener("msTransitionEnd", events, !1), element.addEventListener("oTransitionEnd", events, !1), 
                        element.addEventListener("otransitionend", events, !1), element.addEventListener("transitionend", events, !1)), 
                        window.addEventListener("resize", events, !1)) : window.onresize = function() {
                            setup();
                        };
                    };
                }
            }
        });
    }(ionic), function() {
        "use strict";
        function addLibraryPlugin(lib) {
            lib.fn.swiper = function(params) {
                var firstInstance;
                return lib(this).each(function() {
                    var s = new Swiper(this, params);
                    firstInstance || (firstInstance = s);
                }), firstInstance;
            };
        }
        var $, Swiper = function(container, params, _scope, $compile) {
            function isH() {
                return "horizontal" === s.params.direction;
            }
            function round(a) {
                return Math.floor(a);
            }
            function autoplay() {
                s.autoplayTimeoutId = setTimeout(function() {
                    s.params.loop ? (s.fixLoop(), s._slideNext()) : s.isEnd ? params.autoplayStopOnLast ? s.stopAutoplay() : s._slideTo(0) : s._slideNext();
                }, s.params.autoplay);
            }
            function findElementInEvent(e, selector) {
                var el = $(e.target);
                if (!el.is(selector)) if ("string" == typeof selector) el = el.parents(selector); else if (selector.nodeType) {
                    var found;
                    return el.parents().each(function(index, _el) {
                        _el === selector && (found = selector);
                    }), found ? selector : void 0;
                }
                return 0 === el.length ? void 0 : el[0];
            }
            function initObserver(target, options) {
                options = options || {};
                var ObserverFunc = window.MutationObserver || window.WebkitMutationObserver, observer = new ObserverFunc(function(mutations) {
                    mutations.forEach(function(mutation) {
                        s.onResize(!0), s.emit("onObserverUpdate", s, mutation);
                    });
                });
                observer.observe(target, {
                    attributes: "undefined" == typeof options.attributes ? !0 : options.attributes,
                    childList: "undefined" == typeof options.childList ? !0 : options.childList,
                    characterData: "undefined" == typeof options.characterData ? !0 : options.characterData
                }), s.observers.push(observer);
            }
            function handleKeyboard(e) {
                e.originalEvent && (e = e.originalEvent);
                var kc = e.keyCode || e.charCode;
                if (!s.params.allowSwipeToNext && (isH() && 39 === kc || !isH() && 40 === kc)) return !1;
                if (!s.params.allowSwipeToPrev && (isH() && 37 === kc || !isH() && 38 === kc)) return !1;
                if (!(e.shiftKey || e.altKey || e.ctrlKey || e.metaKey || document.activeElement && document.activeElement.nodeName && ("input" === document.activeElement.nodeName.toLowerCase() || "textarea" === document.activeElement.nodeName.toLowerCase()))) {
                    if (37 === kc || 39 === kc || 38 === kc || 40 === kc) {
                        var inView = !1;
                        if (s.container.parents(".swiper-slide").length > 0 && 0 === s.container.parents(".swiper-slide-active").length) return;
                        var windowScroll = {
                            left: window.pageXOffset,
                            top: window.pageYOffset
                        }, windowWidth = window.innerWidth, windowHeight = window.innerHeight, swiperOffset = s.container.offset();
                        s.rtl && (swiperOffset.left = swiperOffset.left - s.container[0].scrollLeft);
                        for (var swiperCoord = [ [ swiperOffset.left, swiperOffset.top ], [ swiperOffset.left + s.width, swiperOffset.top ], [ swiperOffset.left, swiperOffset.top + s.height ], [ swiperOffset.left + s.width, swiperOffset.top + s.height ] ], i = 0; i < swiperCoord.length; i++) {
                            var point = swiperCoord[i];
                            point[0] >= windowScroll.left && point[0] <= windowScroll.left + windowWidth && point[1] >= windowScroll.top && point[1] <= windowScroll.top + windowHeight && (inView = !0);
                        }
                        if (!inView) return;
                    }
                    isH() ? ((37 === kc || 39 === kc) && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), 
                    (39 === kc && !s.rtl || 37 === kc && s.rtl) && s.slideNext(), (37 === kc && !s.rtl || 39 === kc && s.rtl) && s.slidePrev()) : ((38 === kc || 40 === kc) && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), 
                    40 === kc && s.slideNext(), 38 === kc && s.slidePrev());
                }
            }
            function handleMousewheel(e) {
                e.originalEvent && (e = e.originalEvent);
                var we = s.mousewheel.event, delta = 0, rtlFactor = s.rtl ? -1 : 1;
                if (e.detail) delta = -e.detail; else if ("mousewheel" === we) if (s.params.mousewheelForceToAxis) if (isH()) {
                    if (!(Math.abs(e.wheelDeltaX) > Math.abs(e.wheelDeltaY))) return;
                    delta = e.wheelDeltaX * rtlFactor;
                } else {
                    if (!(Math.abs(e.wheelDeltaY) > Math.abs(e.wheelDeltaX))) return;
                    delta = e.wheelDeltaY;
                } else delta = Math.abs(e.wheelDeltaX) > Math.abs(e.wheelDeltaY) ? -e.wheelDeltaX * rtlFactor : -e.wheelDeltaY; else if ("DOMMouseScroll" === we) delta = -e.detail; else if ("wheel" === we) if (s.params.mousewheelForceToAxis) if (isH()) {
                    if (!(Math.abs(e.deltaX) > Math.abs(e.deltaY))) return;
                    delta = -e.deltaX * rtlFactor;
                } else {
                    if (!(Math.abs(e.deltaY) > Math.abs(e.deltaX))) return;
                    delta = -e.deltaY;
                } else delta = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? -e.deltaX * rtlFactor : -e.deltaY;
                if (0 !== delta) {
                    if (s.params.mousewheelInvert && (delta = -delta), s.params.freeMode) {
                        var position = s.getWrapperTranslate() + delta * s.params.mousewheelSensitivity, wasBeginning = s.isBeginning, wasEnd = s.isEnd;
                        if (position >= s.minTranslate() && (position = s.minTranslate()), position <= s.maxTranslate() && (position = s.maxTranslate()), 
                        s.setWrapperTransition(0), s.setWrapperTranslate(position), s.updateProgress(), 
                        s.updateActiveIndex(), (!wasBeginning && s.isBeginning || !wasEnd && s.isEnd) && s.updateClasses(), 
                        s.params.freeModeSticky && (clearTimeout(s.mousewheel.timeout), s.mousewheel.timeout = setTimeout(function() {
                            s.slideReset();
                        }, 300)), 0 === position || position === s.maxTranslate()) return;
                    } else {
                        if (new window.Date().getTime() - s.mousewheel.lastScrollTime > 60) if (0 > delta) if (s.isEnd && !s.params.loop || s.animating) {
                            if (s.params.mousewheelReleaseOnEdges) return !0;
                        } else s.slideNext(); else if (s.isBeginning && !s.params.loop || s.animating) {
                            if (s.params.mousewheelReleaseOnEdges) return !0;
                        } else s.slidePrev();
                        s.mousewheel.lastScrollTime = new window.Date().getTime();
                    }
                    return s.params.autoplay && s.stopAutoplay(), e.preventDefault ? e.preventDefault() : e.returnValue = !1, 
                    !1;
                }
            }
            function setParallaxTransform(el, progress) {
                el = $(el);
                var p, pX, pY, rtlFactor = s.rtl ? -1 : 1;
                p = el.attr("data-swiper-parallax") || "0", pX = el.attr("data-swiper-parallax-x"), 
                pY = el.attr("data-swiper-parallax-y"), pX || pY ? (pX = pX || "0", pY = pY || "0") : isH() ? (pX = p, 
                pY = "0") : (pY = p, pX = "0"), pX = pX.indexOf("%") >= 0 ? parseInt(pX, 10) * progress * rtlFactor + "%" : pX * progress * rtlFactor + "px", 
                pY = pY.indexOf("%") >= 0 ? parseInt(pY, 10) * progress + "%" : pY * progress + "px", 
                el.transform("translate3d(" + pX + ", " + pY + ",0px)");
            }
            function normalizeEventName(eventName) {
                return 0 !== eventName.indexOf("on") && (eventName = eventName[0] !== eventName[0].toUpperCase() ? "on" + eventName[0].toUpperCase() + eventName.substring(1) : "on" + eventName), 
                eventName;
            }
            if (!(this instanceof Swiper)) return new Swiper(container, params);
            var defaults = {
                direction: "horizontal",
                touchEventsTarget: "container",
                initialSlide: 0,
                speed: 300,
                autoplay: !1,
                autoplayDisableOnInteraction: !0,
                iOSEdgeSwipeDetection: !1,
                iOSEdgeSwipeThreshold: 20,
                freeMode: !1,
                freeModeMomentum: !0,
                freeModeMomentumRatio: 1,
                freeModeMomentumBounce: !0,
                freeModeMomentumBounceRatio: 1,
                freeModeSticky: !1,
                freeModeMinimumVelocity: .02,
                autoHeight: !1,
                setWrapperSize: !1,
                virtualTranslate: !1,
                effect: "slide",
                coverflow: {
                    rotate: 50,
                    stretch: 0,
                    depth: 100,
                    modifier: 1,
                    slideShadows: !0
                },
                cube: {
                    slideShadows: !0,
                    shadow: !0,
                    shadowOffset: 20,
                    shadowScale: .94
                },
                fade: {
                    crossFade: !1
                },
                parallax: !1,
                scrollbar: null,
                scrollbarHide: !0,
                scrollbarDraggable: !1,
                scrollbarSnapOnRelease: !1,
                keyboardControl: !1,
                mousewheelControl: !1,
                mousewheelReleaseOnEdges: !1,
                mousewheelInvert: !1,
                mousewheelForceToAxis: !1,
                mousewheelSensitivity: 1,
                hashnav: !1,
                breakpoints: void 0,
                spaceBetween: 0,
                slidesPerView: 1,
                slidesPerColumn: 1,
                slidesPerColumnFill: "column",
                slidesPerGroup: 1,
                centeredSlides: !1,
                slidesOffsetBefore: 0,
                slidesOffsetAfter: 0,
                roundLengths: !1,
                touchRatio: 1,
                touchAngle: 45,
                simulateTouch: !0,
                shortSwipes: !0,
                longSwipes: !0,
                longSwipesRatio: .5,
                longSwipesMs: 300,
                followFinger: !0,
                onlyExternal: !1,
                threshold: 0,
                touchMoveStopPropagation: !0,
                pagination: null,
                paginationElement: "span",
                paginationClickable: !1,
                paginationHide: !1,
                paginationBulletRender: null,
                resistance: !0,
                resistanceRatio: .85,
                nextButton: null,
                prevButton: null,
                watchSlidesProgress: !1,
                watchSlidesVisibility: !1,
                grabCursor: !1,
                preventClicks: !0,
                preventClicksPropagation: !0,
                slideToClickedSlide: !1,
                lazyLoading: !1,
                lazyLoadingInPrevNext: !1,
                lazyLoadingOnTransitionStart: !1,
                preloadImages: !0,
                updateOnImagesReady: !0,
                loop: !1,
                loopAdditionalSlides: 0,
                loopedSlides: null,
                control: void 0,
                controlInverse: !1,
                controlBy: "slide",
                allowSwipeToPrev: !0,
                allowSwipeToNext: !0,
                swipeHandler: null,
                noSwiping: !0,
                noSwipingClass: "swiper-no-swiping",
                slideClass: "swiper-slide",
                slideActiveClass: "swiper-slide-active",
                slideVisibleClass: "swiper-slide-visible",
                slideDuplicateClass: "swiper-slide-duplicate",
                slideNextClass: "swiper-slide-next",
                slidePrevClass: "swiper-slide-prev",
                wrapperClass: "swiper-wrapper",
                bulletClass: "swiper-pagination-bullet",
                bulletActiveClass: "swiper-pagination-bullet-active",
                buttonDisabledClass: "swiper-button-disabled",
                paginationHiddenClass: "swiper-pagination-hidden",
                observer: !1,
                observeParents: !1,
                a11y: !1,
                prevSlideMessage: "Previous slide",
                nextSlideMessage: "Next slide",
                firstSlideMessage: "This is the first slide",
                lastSlideMessage: "This is the last slide",
                paginationBulletMessage: "Go to slide {{index}}",
                runCallbacksOnInit: !0
            }, initialVirtualTranslate = params && params.virtualTranslate;
            params = params || {};
            var originalParams = {};
            for (var param in params) if ("object" != typeof params[param] || (params[param].nodeType || params[param] === window || params[param] === document || "undefined" != typeof Dom7 && params[param] instanceof Dom7 || "undefined" != typeof jQuery && params[param] instanceof jQuery)) originalParams[param] = params[param]; else {
                originalParams[param] = {};
                for (var deepParam in params[param]) originalParams[param][deepParam] = params[param][deepParam];
            }
            for (var def in defaults) if ("undefined" == typeof params[def]) params[def] = defaults[def]; else if ("object" == typeof params[def]) for (var deepDef in defaults[def]) "undefined" == typeof params[def][deepDef] && (params[def][deepDef] = defaults[def][deepDef]);
            var s = this;
            if (s.params = params, s.originalParams = originalParams, s.classNames = [], "undefined" != typeof $ && "undefined" != typeof Dom7 && ($ = Dom7), 
            ("undefined" != typeof $ || ($ = "undefined" == typeof Dom7 ? window.Dom7 || window.Zepto || window.jQuery : Dom7)) && (s.$ = $, 
            s.currentBreakpoint = void 0, s.getActiveBreakpoint = function() {
                if (!s.params.breakpoints) return !1;
                var point, breakpoint = !1, points = [];
                for (point in s.params.breakpoints) s.params.breakpoints.hasOwnProperty(point) && points.push(point);
                points.sort(function(a, b) {
                    return parseInt(a, 10) > parseInt(b, 10);
                });
                for (var i = 0; i < points.length; i++) point = points[i], point >= window.innerWidth && !breakpoint && (breakpoint = point);
                return breakpoint || "max";
            }, s.setBreakpoint = function() {
                var breakpoint = s.getActiveBreakpoint();
                if (breakpoint && s.currentBreakpoint !== breakpoint) {
                    var breakPointsParams = breakpoint in s.params.breakpoints ? s.params.breakpoints[breakpoint] : s.originalParams;
                    for (var param in breakPointsParams) s.params[param] = breakPointsParams[param];
                    s.currentBreakpoint = breakpoint;
                }
            }, s.params.breakpoints && s.setBreakpoint(), s.container = $(container), 0 !== s.container.length)) {
                if (s.container.length > 1) return void s.container.each(function() {
                    new Swiper(this, params);
                });
                s.container[0].swiper = s, s.container.data("swiper", s), s.classNames.push("swiper-container-" + s.params.direction), 
                s.params.freeMode && s.classNames.push("swiper-container-free-mode"), s.support.flexbox || (s.classNames.push("swiper-container-no-flexbox"), 
                s.params.slidesPerColumn = 1), s.params.autoHeight && s.classNames.push("swiper-container-autoheight"), 
                (s.params.parallax || s.params.watchSlidesVisibility) && (s.params.watchSlidesProgress = !0), 
                [ "cube", "coverflow" ].indexOf(s.params.effect) >= 0 && (s.support.transforms3d ? (s.params.watchSlidesProgress = !0, 
                s.classNames.push("swiper-container-3d")) : s.params.effect = "slide"), "slide" !== s.params.effect && s.classNames.push("swiper-container-" + s.params.effect), 
                "cube" === s.params.effect && (s.params.resistanceRatio = 0, s.params.slidesPerView = 1, 
                s.params.slidesPerColumn = 1, s.params.slidesPerGroup = 1, s.params.centeredSlides = !1, 
                s.params.spaceBetween = 0, s.params.virtualTranslate = !0, s.params.setWrapperSize = !1), 
                "fade" === s.params.effect && (s.params.slidesPerView = 1, s.params.slidesPerColumn = 1, 
                s.params.slidesPerGroup = 1, s.params.watchSlidesProgress = !0, s.params.spaceBetween = 0, 
                "undefined" == typeof initialVirtualTranslate && (s.params.virtualTranslate = !0)), 
                s.params.grabCursor && s.support.touch && (s.params.grabCursor = !1), s.wrapper = s.container.children("." + s.params.wrapperClass), 
                s.params.pagination && (s.paginationContainer = $(s.params.pagination), s.params.paginationClickable && s.paginationContainer.addClass("swiper-pagination-clickable")), 
                s.rtl = isH() && ("rtl" === s.container[0].dir.toLowerCase() || "rtl" === s.container.css("direction")), 
                s.rtl && s.classNames.push("swiper-container-rtl"), s.rtl && (s.wrongRTL = "-webkit-box" === s.wrapper.css("display")), 
                s.params.slidesPerColumn > 1 && s.classNames.push("swiper-container-multirow"), 
                s.device.android && s.classNames.push("swiper-container-android"), s.container.addClass(s.classNames.join(" ")), 
                s.translate = 0, s.progress = 0, s.velocity = 0, s.lockSwipeToNext = function() {
                    s.params.allowSwipeToNext = !1;
                }, s.lockSwipeToPrev = function() {
                    s.params.allowSwipeToPrev = !1;
                }, s.lockSwipes = function() {
                    s.params.allowSwipeToNext = s.params.allowSwipeToPrev = !1;
                }, s.unlockSwipeToNext = function() {
                    s.params.allowSwipeToNext = !0;
                }, s.unlockSwipeToPrev = function() {
                    s.params.allowSwipeToPrev = !0;
                }, s.unlockSwipes = function() {
                    s.params.allowSwipeToNext = s.params.allowSwipeToPrev = !0;
                }, s.params.grabCursor && (s.container[0].style.cursor = "move", s.container[0].style.cursor = "-webkit-grab", 
                s.container[0].style.cursor = "-moz-grab", s.container[0].style.cursor = "grab"), 
                s.imagesToLoad = [], s.imagesLoaded = 0, s.loadImage = function(imgElement, src, srcset, checkForComplete, callback) {
                    function onReady() {
                        callback && callback();
                    }
                    var image;
                    imgElement.complete && checkForComplete ? onReady() : src ? (image = new window.Image(), 
                    image.onload = onReady, image.onerror = onReady, srcset && (image.srcset = srcset), 
                    src && (image.src = src)) : onReady();
                }, s.preloadImages = function() {
                    function _onReady() {
                        "undefined" != typeof s && null !== s && (void 0 !== s.imagesLoaded && s.imagesLoaded++, 
                        s.imagesLoaded === s.imagesToLoad.length && (s.params.updateOnImagesReady && s.update(), 
                        s.emit("onImagesReady", s)));
                    }
                    s.imagesToLoad = s.container.find("img");
                    for (var i = 0; i < s.imagesToLoad.length; i++) s.loadImage(s.imagesToLoad[i], s.imagesToLoad[i].currentSrc || s.imagesToLoad[i].getAttribute("src"), s.imagesToLoad[i].srcset || s.imagesToLoad[i].getAttribute("srcset"), !0, _onReady);
                }, s.autoplayTimeoutId = void 0, s.autoplaying = !1, s.autoplayPaused = !1, s.startAutoplay = function() {
                    return "undefined" != typeof s.autoplayTimeoutId ? !1 : s.params.autoplay ? s.autoplaying ? !1 : (s.autoplaying = !0, 
                    s.emit("onAutoplayStart", s), void autoplay()) : !1;
                }, s.stopAutoplay = function(internal) {
                    s.autoplayTimeoutId && (s.autoplayTimeoutId && clearTimeout(s.autoplayTimeoutId), 
                    s.autoplaying = !1, s.autoplayTimeoutId = void 0, s.emit("onAutoplayStop", s));
                }, s.pauseAutoplay = function(speed) {
                    s.autoplayPaused || (s.autoplayTimeoutId && clearTimeout(s.autoplayTimeoutId), s.autoplayPaused = !0, 
                    0 === speed ? (s.autoplayPaused = !1, autoplay()) : s.wrapper.transitionEnd(function() {
                        s && (s.autoplayPaused = !1, s.autoplaying ? autoplay() : s.stopAutoplay());
                    }));
                }, s.minTranslate = function() {
                    return -s.snapGrid[0];
                }, s.maxTranslate = function() {
                    return -s.snapGrid[s.snapGrid.length - 1];
                }, s.updateAutoHeight = function() {
                    var newHeight = s.slides.eq(s.activeIndex)[0].offsetHeight;
                    newHeight && s.wrapper.css("height", s.slides.eq(s.activeIndex)[0].offsetHeight + "px");
                }, s.updateContainerSize = function() {
                    var width, height;
                    width = "undefined" != typeof s.params.width ? s.params.width : s.container[0].clientWidth, 
                    height = "undefined" != typeof s.params.height ? s.params.height : s.container[0].clientHeight, 
                    0 === width && isH() || 0 === height && !isH() || (width = width - parseInt(s.container.css("padding-left"), 10) - parseInt(s.container.css("padding-right"), 10), 
                    height = height - parseInt(s.container.css("padding-top"), 10) - parseInt(s.container.css("padding-bottom"), 10), 
                    s.width = width, s.height = height, s.size = isH() ? s.width : s.height);
                }, s.updateSlidesSize = function() {
                    s.slides = s.wrapper.children("." + s.params.slideClass), s.snapGrid = [], s.slidesGrid = [], 
                    s.slidesSizesGrid = [];
                    var i, spaceBetween = s.params.spaceBetween, slidePosition = -s.params.slidesOffsetBefore, prevSlideSize = 0, index = 0;
                    "string" == typeof spaceBetween && spaceBetween.indexOf("%") >= 0 && (spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * s.size), 
                    s.virtualSize = -spaceBetween, s.rtl ? s.slides.css({
                        marginLeft: "",
                        marginTop: ""
                    }) : s.slides.css({
                        marginRight: "",
                        marginBottom: ""
                    });
                    var slidesNumberEvenToRows;
                    s.params.slidesPerColumn > 1 && (slidesNumberEvenToRows = Math.floor(s.slides.length / s.params.slidesPerColumn) === s.slides.length / s.params.slidesPerColumn ? s.slides.length : Math.ceil(s.slides.length / s.params.slidesPerColumn) * s.params.slidesPerColumn, 
                    "auto" !== s.params.slidesPerView && "row" === s.params.slidesPerColumnFill && (slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, s.params.slidesPerView * s.params.slidesPerColumn)));
                    var slideSize, slidesPerColumn = s.params.slidesPerColumn, slidesPerRow = slidesNumberEvenToRows / slidesPerColumn, numFullColumns = slidesPerRow - (s.params.slidesPerColumn * slidesPerRow - s.slides.length);
                    for (i = 0; i < s.slides.length; i++) {
                        slideSize = 0;
                        var slide = s.slides.eq(i);
                        if (s.params.slidesPerColumn > 1) {
                            var newSlideOrderIndex, column, row;
                            "column" === s.params.slidesPerColumnFill ? (column = Math.floor(i / slidesPerColumn), 
                            row = i - column * slidesPerColumn, (column > numFullColumns || column === numFullColumns && row === slidesPerColumn - 1) && ++row >= slidesPerColumn && (row = 0, 
                            column++), newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn, 
                            slide.css({
                                "-webkit-box-ordinal-group": newSlideOrderIndex,
                                "-moz-box-ordinal-group": newSlideOrderIndex,
                                "-ms-flex-order": newSlideOrderIndex,
                                "-webkit-order": newSlideOrderIndex,
                                order: newSlideOrderIndex
                            })) : (row = Math.floor(i / slidesPerRow), column = i - row * slidesPerRow), slide.css({
                                "margin-top": 0 !== row && s.params.spaceBetween && s.params.spaceBetween + "px"
                            }).attr("data-swiper-column", column).attr("data-swiper-row", row);
                        }
                        "none" !== slide.css("display") && ("auto" === s.params.slidesPerView ? (slideSize = isH() ? slide.outerWidth(!0) : slide.outerHeight(!0), 
                        s.params.roundLengths && (slideSize = round(slideSize))) : (slideSize = (s.size - (s.params.slidesPerView - 1) * spaceBetween) / s.params.slidesPerView, 
                        s.params.roundLengths && (slideSize = round(slideSize)), isH() ? s.slides[i].style.width = slideSize + "px" : s.slides[i].style.height = slideSize + "px"), 
                        s.slides[i].swiperSlideSize = slideSize, s.slidesSizesGrid.push(slideSize), s.params.centeredSlides ? (slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween, 
                        0 === i && (slidePosition = slidePosition - s.size / 2 - spaceBetween), Math.abs(slidePosition) < .001 && (slidePosition = 0), 
                        index % s.params.slidesPerGroup === 0 && s.snapGrid.push(slidePosition), s.slidesGrid.push(slidePosition)) : (index % s.params.slidesPerGroup === 0 && s.snapGrid.push(slidePosition), 
                        s.slidesGrid.push(slidePosition), slidePosition = slidePosition + slideSize + spaceBetween), 
                        s.virtualSize += slideSize + spaceBetween, prevSlideSize = slideSize, index++);
                    }
                    s.virtualSize = Math.max(s.virtualSize, s.size) + s.params.slidesOffsetAfter;
                    var newSlidesGrid;
                    if (s.rtl && s.wrongRTL && ("slide" === s.params.effect || "coverflow" === s.params.effect) && s.wrapper.css({
                        width: s.virtualSize + s.params.spaceBetween + "px"
                    }), (!s.support.flexbox || s.params.setWrapperSize) && (isH() ? s.wrapper.css({
                        width: s.virtualSize + s.params.spaceBetween + "px"
                    }) : s.wrapper.css({
                        height: s.virtualSize + s.params.spaceBetween + "px"
                    })), s.params.slidesPerColumn > 1 && (s.virtualSize = (slideSize + s.params.spaceBetween) * slidesNumberEvenToRows, 
                    s.virtualSize = Math.ceil(s.virtualSize / s.params.slidesPerColumn) - s.params.spaceBetween, 
                    s.wrapper.css({
                        width: s.virtualSize + s.params.spaceBetween + "px"
                    }), s.params.centeredSlides)) {
                        for (newSlidesGrid = [], i = 0; i < s.snapGrid.length; i++) s.snapGrid[i] < s.virtualSize + s.snapGrid[0] && newSlidesGrid.push(s.snapGrid[i]);
                        s.snapGrid = newSlidesGrid;
                    }
                    if (!s.params.centeredSlides) {
                        for (newSlidesGrid = [], i = 0; i < s.snapGrid.length; i++) s.snapGrid[i] <= s.virtualSize - s.size && newSlidesGrid.push(s.snapGrid[i]);
                        s.snapGrid = newSlidesGrid, Math.floor(s.virtualSize - s.size) > Math.floor(s.snapGrid[s.snapGrid.length - 1]) && s.snapGrid.push(s.virtualSize - s.size);
                    }
                    0 === s.snapGrid.length && (s.snapGrid = [ 0 ]), 0 !== s.params.spaceBetween && (isH() ? s.rtl ? s.slides.css({
                        marginLeft: spaceBetween + "px"
                    }) : s.slides.css({
                        marginRight: spaceBetween + "px"
                    }) : s.slides.css({
                        marginBottom: spaceBetween + "px"
                    })), s.params.watchSlidesProgress && s.updateSlidesOffset();
                }, s.updateSlidesOffset = function() {
                    for (var i = 0; i < s.slides.length; i++) s.slides[i].swiperSlideOffset = isH() ? s.slides[i].offsetLeft : s.slides[i].offsetTop;
                }, s.updateSlidesProgress = function(translate) {
                    if ("undefined" == typeof translate && (translate = s.translate || 0), 0 !== s.slides.length) {
                        "undefined" == typeof s.slides[0].swiperSlideOffset && s.updateSlidesOffset();
                        var offsetCenter = -translate;
                        s.rtl && (offsetCenter = translate), s.slides.removeClass(s.params.slideVisibleClass);
                        for (var i = 0; i < s.slides.length; i++) {
                            var slide = s.slides[i], slideProgress = (offsetCenter - slide.swiperSlideOffset) / (slide.swiperSlideSize + s.params.spaceBetween);
                            if (s.params.watchSlidesVisibility) {
                                var slideBefore = -(offsetCenter - slide.swiperSlideOffset), slideAfter = slideBefore + s.slidesSizesGrid[i], isVisible = slideBefore >= 0 && slideBefore < s.size || slideAfter > 0 && slideAfter <= s.size || 0 >= slideBefore && slideAfter >= s.size;
                                isVisible && s.slides.eq(i).addClass(s.params.slideVisibleClass);
                            }
                            slide.progress = s.rtl ? -slideProgress : slideProgress;
                        }
                    }
                }, s.updateProgress = function(translate) {
                    "undefined" == typeof translate && (translate = s.translate || 0);
                    var translatesDiff = s.maxTranslate() - s.minTranslate(), wasBeginning = s.isBeginning, wasEnd = s.isEnd;
                    0 === translatesDiff ? (s.progress = 0, s.isBeginning = s.isEnd = !0) : (s.progress = (translate - s.minTranslate()) / translatesDiff, 
                    s.isBeginning = s.progress <= 0, s.isEnd = s.progress >= 1), s.isBeginning && !wasBeginning && s.emit("onReachBeginning", s), 
                    s.isEnd && !wasEnd && s.emit("onReachEnd", s), s.params.watchSlidesProgress && s.updateSlidesProgress(translate), 
                    s.emit("onProgress", s, s.progress);
                }, s.updateActiveIndex = function() {
                    var newActiveIndex, i, snapIndex, translate = s.rtl ? s.translate : -s.translate;
                    for (i = 0; i < s.slidesGrid.length; i++) "undefined" != typeof s.slidesGrid[i + 1] ? translate >= s.slidesGrid[i] && translate < s.slidesGrid[i + 1] - (s.slidesGrid[i + 1] - s.slidesGrid[i]) / 2 ? newActiveIndex = i : translate >= s.slidesGrid[i] && translate < s.slidesGrid[i + 1] && (newActiveIndex = i + 1) : translate >= s.slidesGrid[i] && (newActiveIndex = i);
                    (0 > newActiveIndex || "undefined" == typeof newActiveIndex) && (newActiveIndex = 0), 
                    snapIndex = Math.floor(newActiveIndex / s.params.slidesPerGroup), snapIndex >= s.snapGrid.length && (snapIndex = s.snapGrid.length - 1), 
                    newActiveIndex !== s.activeIndex && (s.snapIndex = snapIndex, s.previousIndex = s.activeIndex, 
                    s.activeIndex = newActiveIndex, s.updateClasses());
                }, s.updateClasses = function() {
                    s.slides.removeClass(s.params.slideActiveClass + " " + s.params.slideNextClass + " " + s.params.slidePrevClass);
                    var activeSlide = s.slides.eq(s.activeIndex);
                    if (activeSlide.addClass(s.params.slideActiveClass), activeSlide.next("." + s.params.slideClass).addClass(s.params.slideNextClass), 
                    activeSlide.prev("." + s.params.slideClass).addClass(s.params.slidePrevClass), s.bullets && s.bullets.length > 0) {
                        s.bullets.removeClass(s.params.bulletActiveClass);
                        var bulletIndex;
                        s.params.loop ? (bulletIndex = Math.ceil(s.activeIndex - s.loopedSlides) / s.params.slidesPerGroup, 
                        bulletIndex > s.slides.length - 1 - 2 * s.loopedSlides && (bulletIndex -= s.slides.length - 2 * s.loopedSlides), 
                        bulletIndex > s.bullets.length - 1 && (bulletIndex -= s.bullets.length)) : bulletIndex = "undefined" != typeof s.snapIndex ? s.snapIndex : s.activeIndex || 0, 
                        s.paginationContainer.length > 1 ? s.bullets.each(function() {
                            $(this).index() === bulletIndex && $(this).addClass(s.params.bulletActiveClass);
                        }) : s.bullets.eq(bulletIndex).addClass(s.params.bulletActiveClass);
                    }
                    s.params.loop || (s.params.prevButton && (s.isBeginning ? ($(s.params.prevButton).addClass(s.params.buttonDisabledClass), 
                    s.params.a11y && s.a11y && s.a11y.disable($(s.params.prevButton))) : ($(s.params.prevButton).removeClass(s.params.buttonDisabledClass), 
                    s.params.a11y && s.a11y && s.a11y.enable($(s.params.prevButton)))), s.params.nextButton && (s.isEnd ? ($(s.params.nextButton).addClass(s.params.buttonDisabledClass), 
                    s.params.a11y && s.a11y && s.a11y.disable($(s.params.nextButton))) : ($(s.params.nextButton).removeClass(s.params.buttonDisabledClass), 
                    s.params.a11y && s.a11y && s.a11y.enable($(s.params.nextButton)))));
                }, s.updatePagination = function() {
                    if (s.params.pagination && s.paginationContainer && s.paginationContainer.length > 0) {
                        for (var bulletsHTML = "", numberOfBullets = s.params.loop ? Math.ceil((s.slides.length - 2 * s.loopedSlides) / s.params.slidesPerGroup) : s.snapGrid.length, i = 0; numberOfBullets > i; i++) bulletsHTML += s.params.paginationBulletRender ? s.params.paginationBulletRender(i, s.params.bulletClass) : "<" + s.params.paginationElement + ' class="' + s.params.bulletClass + '"></' + s.params.paginationElement + ">";
                        s.paginationContainer.html(bulletsHTML), s.bullets = s.paginationContainer.find("." + s.params.bulletClass), 
                        s.params.paginationClickable && s.params.a11y && s.a11y && s.a11y.initPagination();
                    }
                }, s.update = function(updateTranslate) {
                    function forceSetTranslate() {
                        newTranslate = Math.min(Math.max(s.translate, s.maxTranslate()), s.minTranslate()), 
                        s.setWrapperTranslate(newTranslate), s.updateActiveIndex(), s.updateClasses();
                    }
                    if (s.updateContainerSize(), s.updateSlidesSize(), s.updateProgress(), s.updatePagination(), 
                    s.updateClasses(), s.params.scrollbar && s.scrollbar && s.scrollbar.set(), updateTranslate) {
                        var translated, newTranslate;
                        s.controller && s.controller.spline && (s.controller.spline = void 0), s.params.freeMode ? (forceSetTranslate(), 
                        s.params.autoHeight && s.updateAutoHeight()) : (translated = ("auto" === s.params.slidesPerView || s.params.slidesPerView > 1) && s.isEnd && !s.params.centeredSlides ? s.slideTo(s.slides.length - 1, 0, !1, !0) : s.slideTo(s.activeIndex, 0, !1, !0), 
                        translated || forceSetTranslate());
                    } else s.params.autoHeight && s.updateAutoHeight();
                }, s.onResize = function(forceUpdatePagination) {
                    s.params.breakpoints && s.setBreakpoint();
                    var allowSwipeToPrev = s.params.allowSwipeToPrev, allowSwipeToNext = s.params.allowSwipeToNext;
                    if (s.params.allowSwipeToPrev = s.params.allowSwipeToNext = !0, s.updateContainerSize(), 
                    s.updateSlidesSize(), ("auto" === s.params.slidesPerView || s.params.freeMode || forceUpdatePagination) && s.updatePagination(), 
                    s.params.scrollbar && s.scrollbar && s.scrollbar.set(), s.controller && s.controller.spline && (s.controller.spline = void 0), 
                    s.params.freeMode) {
                        var newTranslate = Math.min(Math.max(s.translate, s.maxTranslate()), s.minTranslate());
                        s.setWrapperTranslate(newTranslate), s.updateActiveIndex(), s.updateClasses(), s.params.autoHeight && s.updateAutoHeight();
                    } else s.updateClasses(), ("auto" === s.params.slidesPerView || s.params.slidesPerView > 1) && s.isEnd && !s.params.centeredSlides ? s.slideTo(s.slides.length - 1, 0, !1, !0) : s.slideTo(s.activeIndex, 0, !1, !0);
                    s.params.allowSwipeToPrev = allowSwipeToPrev, s.params.allowSwipeToNext = allowSwipeToNext;
                };
                var desktopEvents = [ "mousedown", "mousemove", "mouseup" ];
                window.navigator.pointerEnabled ? desktopEvents = [ "pointerdown", "pointermove", "pointerup" ] : window.navigator.msPointerEnabled && (desktopEvents = [ "MSPointerDown", "MSPointerMove", "MSPointerUp" ]), 
                s.touchEvents = {
                    start: s.support.touch || !s.params.simulateTouch ? "touchstart" : desktopEvents[0],
                    move: s.support.touch || !s.params.simulateTouch ? "touchmove" : desktopEvents[1],
                    end: s.support.touch || !s.params.simulateTouch ? "touchend" : desktopEvents[2]
                }, (window.navigator.pointerEnabled || window.navigator.msPointerEnabled) && ("container" === s.params.touchEventsTarget ? s.container : s.wrapper).addClass("swiper-wp8-" + s.params.direction), 
                s.initEvents = function(detach) {
                    var actionDom = detach ? "off" : "on", action = detach ? "removeEventListener" : "addEventListener", touchEventsTarget = "container" === s.params.touchEventsTarget ? s.container[0] : s.wrapper[0], target = s.support.touch ? touchEventsTarget : document, moveCapture = s.params.nested ? !0 : !1;
                    s.browser.ie ? (touchEventsTarget[action](s.touchEvents.start, s.onTouchStart, !1), 
                    target[action](s.touchEvents.move, s.onTouchMove, moveCapture), target[action](s.touchEvents.end, s.onTouchEnd, !1)) : (s.support.touch && (touchEventsTarget[action](s.touchEvents.start, s.onTouchStart, !1), 
                    touchEventsTarget[action](s.touchEvents.move, s.onTouchMove, moveCapture), touchEventsTarget[action](s.touchEvents.end, s.onTouchEnd, !1)), 
                    !params.simulateTouch || s.device.ios || s.device.android || (touchEventsTarget[action]("mousedown", s.onTouchStart, !1), 
                    document[action]("mousemove", s.onTouchMove, moveCapture), document[action]("mouseup", s.onTouchEnd, !1))), 
                    window[action]("resize", s.onResize), s.params.nextButton && ($(s.params.nextButton)[actionDom]("click", s.onClickNext), 
                    s.params.a11y && s.a11y && $(s.params.nextButton)[actionDom]("keydown", s.a11y.onEnterKey)), 
                    s.params.prevButton && ($(s.params.prevButton)[actionDom]("click", s.onClickPrev), 
                    s.params.a11y && s.a11y && $(s.params.prevButton)[actionDom]("keydown", s.a11y.onEnterKey)), 
                    s.params.pagination && s.params.paginationClickable && ($(s.paginationContainer)[actionDom]("click", "." + s.params.bulletClass, s.onClickIndex), 
                    s.params.a11y && s.a11y && $(s.paginationContainer)[actionDom]("keydown", "." + s.params.bulletClass, s.a11y.onEnterKey)), 
                    (s.params.preventClicks || s.params.preventClicksPropagation) && touchEventsTarget[action]("click", s.preventClicks, !0);
                }, s.attachEvents = function(detach) {
                    s.initEvents();
                }, s.detachEvents = function() {
                    s.initEvents(!0);
                }, s.allowClick = !0, s.preventClicks = function(e) {
                    s.allowClick || (s.params.preventClicks && e.preventDefault(), s.params.preventClicksPropagation && s.animating && (e.stopPropagation(), 
                    e.stopImmediatePropagation()));
                }, s.onClickNext = function(e) {
                    e.preventDefault(), (!s.isEnd || s.params.loop) && s.slideNext();
                }, s.onClickPrev = function(e) {
                    e.preventDefault(), (!s.isBeginning || s.params.loop) && s.slidePrev();
                }, s.onClickIndex = function(e) {
                    e.preventDefault();
                    var index = $(this).index() * s.params.slidesPerGroup;
                    s.params.loop && (index += s.loopedSlides), s.slideTo(index);
                }, s.updateClickedSlide = function(e) {
                    var slide = findElementInEvent(e, "." + s.params.slideClass), slideFound = !1;
                    if (slide) for (var i = 0; i < s.slides.length; i++) s.slides[i] === slide && (slideFound = !0);
                    if (!slide || !slideFound) return s.clickedSlide = void 0, void (s.clickedIndex = void 0);
                    if (s.clickedSlide = slide, s.clickedIndex = $(slide).index(), s.params.slideToClickedSlide && void 0 !== s.clickedIndex && s.clickedIndex !== s.activeIndex) {
                        var realIndex, slideToIndex = s.clickedIndex;
                        if (s.params.loop) {
                            if (s.animating) return;
                            realIndex = $(s.clickedSlide).attr("data-swiper-slide-index"), s.params.centeredSlides ? slideToIndex < s.loopedSlides - s.params.slidesPerView / 2 || slideToIndex > s.slides.length - s.loopedSlides + s.params.slidesPerView / 2 ? (s.fixLoop(), 
                            slideToIndex = s.wrapper.children("." + s.params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]:not(.swiper-slide-duplicate)').eq(0).index(), 
                            setTimeout(function() {
                                s.slideTo(slideToIndex);
                            }, 0)) : s.slideTo(slideToIndex) : slideToIndex > s.slides.length - s.params.slidesPerView ? (s.fixLoop(), 
                            slideToIndex = s.wrapper.children("." + s.params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]:not(.swiper-slide-duplicate)').eq(0).index(), 
                            setTimeout(function() {
                                s.slideTo(slideToIndex);
                            }, 0)) : s.slideTo(slideToIndex);
                        } else s.slideTo(slideToIndex);
                    }
                };
                var isTouched, isMoved, allowTouchCallbacks, touchStartTime, isScrolling, currentTranslate, startTranslate, allowThresholdMove, clickTimeout, allowMomentumBounce, formElements = "input, select, textarea, button", lastClickTime = Date.now(), velocities = [];
                s.animating = !1, s.touches = {
                    startX: 0,
                    startY: 0,
                    currentX: 0,
                    currentY: 0,
                    diff: 0
                };
                var isTouchEvent, startMoving;
                if (s.onTouchStart = function(e) {
                    if (e.originalEvent && (e = e.originalEvent), isTouchEvent = "touchstart" === e.type, 
                    isTouchEvent || !("which" in e) || 3 !== e.which) {
                        if (s.params.noSwiping && findElementInEvent(e, "." + s.params.noSwipingClass)) return void (s.allowClick = !0);
                        if (!s.params.swipeHandler || findElementInEvent(e, s.params.swipeHandler)) {
                            var startX = s.touches.currentX = "touchstart" === e.type ? e.targetTouches[0].pageX : e.pageX, startY = s.touches.currentY = "touchstart" === e.type ? e.targetTouches[0].pageY : e.pageY;
                            if (!(s.device.ios && s.params.iOSEdgeSwipeDetection && startX <= s.params.iOSEdgeSwipeThreshold)) {
                                if (isTouched = !0, isMoved = !1, allowTouchCallbacks = !0, isScrolling = void 0, 
                                startMoving = void 0, s.touches.startX = startX, s.touches.startY = startY, touchStartTime = Date.now(), 
                                s.allowClick = !0, s.updateContainerSize(), s.swipeDirection = void 0, s.params.threshold > 0 && (allowThresholdMove = !1), 
                                "touchstart" !== e.type) {
                                    var preventDefault = !0;
                                    $(e.target).is(formElements) && (preventDefault = !1), document.activeElement && $(document.activeElement).is(formElements) && document.activeElement.blur(), 
                                    preventDefault && e.preventDefault();
                                }
                                s.emit("onTouchStart", s, e);
                            }
                        }
                    }
                }, s.onTouchMove = function(e) {
                    if (e.originalEvent && (e = e.originalEvent), !(isTouchEvent && "mousemove" === e.type || e.preventedByNestedSwiper)) {
                        if (s.params.onlyExternal) return s.allowClick = !1, void (isTouched && (s.touches.startX = s.touches.currentX = "touchmove" === e.type ? e.targetTouches[0].pageX : e.pageX, 
                        s.touches.startY = s.touches.currentY = "touchmove" === e.type ? e.targetTouches[0].pageY : e.pageY, 
                        touchStartTime = Date.now()));
                        if (isTouchEvent && document.activeElement && e.target === document.activeElement && $(e.target).is(formElements)) return isMoved = !0, 
                        void (s.allowClick = !1);
                        if (allowTouchCallbacks && s.emit("onTouchMove", s, e), !(e.targetTouches && e.targetTouches.length > 1)) {
                            if (s.touches.currentX = "touchmove" === e.type ? e.targetTouches[0].pageX : e.pageX, 
                            s.touches.currentY = "touchmove" === e.type ? e.targetTouches[0].pageY : e.pageY, 
                            "undefined" == typeof isScrolling) {
                                var touchAngle = 180 * Math.atan2(Math.abs(s.touches.currentY - s.touches.startY), Math.abs(s.touches.currentX - s.touches.startX)) / Math.PI;
                                isScrolling = isH() ? touchAngle > s.params.touchAngle : 90 - touchAngle > s.params.touchAngle;
                            }
                            if (isScrolling && s.emit("onTouchMoveOpposite", s, e), "undefined" == typeof startMoving && s.browser.ieTouch && (s.touches.currentX !== s.touches.startX || s.touches.currentY !== s.touches.startY) && (startMoving = !0), 
                            isTouched) {
                                if (isScrolling) return void (isTouched = !1);
                                if (startMoving || !s.browser.ieTouch) {
                                    s.allowClick = !1, s.emit("onSliderMove", s, e), e.preventDefault(), s.params.touchMoveStopPropagation && !s.params.nested && e.stopPropagation(), 
                                    isMoved || (params.loop && s.fixLoop(), startTranslate = s.getWrapperTranslate(), 
                                    s.setWrapperTransition(0), s.animating && s.wrapper.trigger("webkitTransitionEnd transitionend oTransitionEnd MSTransitionEnd msTransitionEnd"), 
                                    s.params.autoplay && s.autoplaying && (s.params.autoplayDisableOnInteraction ? s.stopAutoplay() : s.pauseAutoplay()), 
                                    allowMomentumBounce = !1, s.params.grabCursor && (s.container[0].style.cursor = "move", 
                                    s.container[0].style.cursor = "-webkit-grabbing", s.container[0].style.cursor = "-moz-grabbin", 
                                    s.container[0].style.cursor = "grabbing")), isMoved = !0;
                                    var diff = s.touches.diff = isH() ? s.touches.currentX - s.touches.startX : s.touches.currentY - s.touches.startY;
                                    diff *= s.params.touchRatio, s.rtl && (diff = -diff), s.swipeDirection = diff > 0 ? "prev" : "next", 
                                    currentTranslate = diff + startTranslate;
                                    var disableParentSwiper = !0;
                                    if (diff > 0 && currentTranslate > s.minTranslate() ? (disableParentSwiper = !1, 
                                    s.params.resistance && (currentTranslate = s.minTranslate() - 1 + Math.pow(-s.minTranslate() + startTranslate + diff, s.params.resistanceRatio))) : 0 > diff && currentTranslate < s.maxTranslate() && (disableParentSwiper = !1, 
                                    s.params.resistance && (currentTranslate = s.maxTranslate() + 1 - Math.pow(s.maxTranslate() - startTranslate - diff, s.params.resistanceRatio))), 
                                    disableParentSwiper && (e.preventedByNestedSwiper = !0), !s.params.allowSwipeToNext && "next" === s.swipeDirection && startTranslate > currentTranslate && (currentTranslate = startTranslate), 
                                    !s.params.allowSwipeToPrev && "prev" === s.swipeDirection && currentTranslate > startTranslate && (currentTranslate = startTranslate), 
                                    s.params.followFinger) {
                                        if (s.params.threshold > 0) {
                                            if (!(Math.abs(diff) > s.params.threshold || allowThresholdMove)) return void (currentTranslate = startTranslate);
                                            if (!allowThresholdMove) return allowThresholdMove = !0, s.touches.startX = s.touches.currentX, 
                                            s.touches.startY = s.touches.currentY, currentTranslate = startTranslate, void (s.touches.diff = isH() ? s.touches.currentX - s.touches.startX : s.touches.currentY - s.touches.startY);
                                        }
                                        (s.params.freeMode || s.params.watchSlidesProgress) && s.updateActiveIndex(), s.params.freeMode && (0 === velocities.length && velocities.push({
                                            position: s.touches[isH() ? "startX" : "startY"],
                                            time: touchStartTime
                                        }), velocities.push({
                                            position: s.touches[isH() ? "currentX" : "currentY"],
                                            time: new window.Date().getTime()
                                        })), s.updateProgress(currentTranslate), s.setWrapperTranslate(currentTranslate);
                                    }
                                }
                            }
                        }
                    }
                }, s.onTouchEnd = function(e) {
                    if (e.originalEvent && (e = e.originalEvent), allowTouchCallbacks && s.emit("onTouchEnd", s, e), 
                    allowTouchCallbacks = !1, isTouched) {
                        s.params.grabCursor && isMoved && isTouched && (s.container[0].style.cursor = "move", 
                        s.container[0].style.cursor = "-webkit-grab", s.container[0].style.cursor = "-moz-grab", 
                        s.container[0].style.cursor = "grab");
                        var touchEndTime = Date.now(), timeDiff = touchEndTime - touchStartTime;
                        if (s.allowClick && (s.updateClickedSlide(e), s.emit("onTap", s, e), 300 > timeDiff && touchEndTime - lastClickTime > 300 && (clickTimeout && clearTimeout(clickTimeout), 
                        clickTimeout = setTimeout(function() {
                            s && (s.params.paginationHide && s.paginationContainer.length > 0 && !$(e.target).hasClass(s.params.bulletClass) && s.paginationContainer.toggleClass(s.params.paginationHiddenClass), 
                            s.emit("onClick", s, e));
                        }, 300)), 300 > timeDiff && 300 > touchEndTime - lastClickTime && (clickTimeout && clearTimeout(clickTimeout), 
                        s.emit("onDoubleTap", s, e))), lastClickTime = Date.now(), setTimeout(function() {
                            s && (s.allowClick = !0);
                        }, 0), !isTouched || !isMoved || !s.swipeDirection || 0 === s.touches.diff || currentTranslate === startTranslate) return void (isTouched = isMoved = !1);
                        isTouched = isMoved = !1;
                        var currentPos;
                        if (currentPos = s.params.followFinger ? s.rtl ? s.translate : -s.translate : -currentTranslate, 
                        s.params.freeMode) {
                            if (currentPos < -s.minTranslate()) return void s.slideTo(s.activeIndex);
                            if (currentPos > -s.maxTranslate()) return void (s.slides.length < s.snapGrid.length ? s.slideTo(s.snapGrid.length - 1) : s.slideTo(s.slides.length - 1));
                            if (s.params.freeModeMomentum) {
                                if (velocities.length > 1) {
                                    var lastMoveEvent = velocities.pop(), velocityEvent = velocities.pop(), distance = lastMoveEvent.position - velocityEvent.position, time = lastMoveEvent.time - velocityEvent.time;
                                    s.velocity = distance / time, s.velocity = s.velocity / 2, Math.abs(s.velocity) < s.params.freeModeMinimumVelocity && (s.velocity = 0), 
                                    (time > 150 || new window.Date().getTime() - lastMoveEvent.time > 300) && (s.velocity = 0);
                                } else s.velocity = 0;
                                velocities.length = 0;
                                var momentumDuration = 1e3 * s.params.freeModeMomentumRatio, momentumDistance = s.velocity * momentumDuration, newPosition = s.translate + momentumDistance;
                                s.rtl && (newPosition = -newPosition);
                                var afterBouncePosition, doBounce = !1, bounceAmount = 20 * Math.abs(s.velocity) * s.params.freeModeMomentumBounceRatio;
                                if (newPosition < s.maxTranslate()) s.params.freeModeMomentumBounce ? (newPosition + s.maxTranslate() < -bounceAmount && (newPosition = s.maxTranslate() - bounceAmount), 
                                afterBouncePosition = s.maxTranslate(), doBounce = !0, allowMomentumBounce = !0) : newPosition = s.maxTranslate(); else if (newPosition > s.minTranslate()) s.params.freeModeMomentumBounce ? (newPosition - s.minTranslate() > bounceAmount && (newPosition = s.minTranslate() + bounceAmount), 
                                afterBouncePosition = s.minTranslate(), doBounce = !0, allowMomentumBounce = !0) : newPosition = s.minTranslate(); else if (s.params.freeModeSticky) {
                                    var nextSlide, j = 0;
                                    for (j = 0; j < s.snapGrid.length; j += 1) if (s.snapGrid[j] > -newPosition) {
                                        nextSlide = j;
                                        break;
                                    }
                                    newPosition = Math.abs(s.snapGrid[nextSlide] - newPosition) < Math.abs(s.snapGrid[nextSlide - 1] - newPosition) || "next" === s.swipeDirection ? s.snapGrid[nextSlide] : s.snapGrid[nextSlide - 1], 
                                    s.rtl || (newPosition = -newPosition);
                                }
                                if (0 !== s.velocity) momentumDuration = s.rtl ? Math.abs((-newPosition - s.translate) / s.velocity) : Math.abs((newPosition - s.translate) / s.velocity); else if (s.params.freeModeSticky) return void s.slideReset();
                                s.params.freeModeMomentumBounce && doBounce ? (s.updateProgress(afterBouncePosition), 
                                s.setWrapperTransition(momentumDuration), s.setWrapperTranslate(newPosition), s.onTransitionStart(), 
                                s.animating = !0, s.wrapper.transitionEnd(function() {
                                    s && allowMomentumBounce && (s.emit("onMomentumBounce", s), s.setWrapperTransition(s.params.speed), 
                                    s.setWrapperTranslate(afterBouncePosition), s.wrapper.transitionEnd(function() {
                                        s && s.onTransitionEnd();
                                    }));
                                })) : s.velocity ? (s.updateProgress(newPosition), s.setWrapperTransition(momentumDuration), 
                                s.setWrapperTranslate(newPosition), s.onTransitionStart(), s.animating || (s.animating = !0, 
                                s.wrapper.transitionEnd(function() {
                                    s && s.onTransitionEnd();
                                }))) : s.updateProgress(newPosition), s.updateActiveIndex();
                            }
                            return void ((!s.params.freeModeMomentum || timeDiff >= s.params.longSwipesMs) && (s.updateProgress(), 
                            s.updateActiveIndex()));
                        }
                        var i, stopIndex = 0, groupSize = s.slidesSizesGrid[0];
                        for (i = 0; i < s.slidesGrid.length; i += s.params.slidesPerGroup) "undefined" != typeof s.slidesGrid[i + s.params.slidesPerGroup] ? currentPos >= s.slidesGrid[i] && currentPos < s.slidesGrid[i + s.params.slidesPerGroup] && (stopIndex = i, 
                        groupSize = s.slidesGrid[i + s.params.slidesPerGroup] - s.slidesGrid[i]) : currentPos >= s.slidesGrid[i] && (stopIndex = i, 
                        groupSize = s.slidesGrid[s.slidesGrid.length - 1] - s.slidesGrid[s.slidesGrid.length - 2]);
                        var ratio = (currentPos - s.slidesGrid[stopIndex]) / groupSize;
                        if (timeDiff > s.params.longSwipesMs) {
                            if (!s.params.longSwipes) return void s.slideTo(s.activeIndex);
                            "next" === s.swipeDirection && (ratio >= s.params.longSwipesRatio ? s.slideTo(stopIndex + s.params.slidesPerGroup) : s.slideTo(stopIndex)), 
                            "prev" === s.swipeDirection && (ratio > 1 - s.params.longSwipesRatio ? s.slideTo(stopIndex + s.params.slidesPerGroup) : s.slideTo(stopIndex));
                        } else {
                            if (!s.params.shortSwipes) return void s.slideTo(s.activeIndex);
                            "next" === s.swipeDirection && s.slideTo(stopIndex + s.params.slidesPerGroup), "prev" === s.swipeDirection && s.slideTo(stopIndex);
                        }
                    }
                }, s._slideTo = function(slideIndex, speed) {
                    return s.slideTo(slideIndex, speed, !0, !0);
                }, s.slideTo = function(slideIndex, speed, runCallbacks, internal) {
                    "undefined" == typeof runCallbacks && (runCallbacks = !0), "undefined" == typeof slideIndex && (slideIndex = 0), 
                    0 > slideIndex && (slideIndex = 0), s.snapIndex = Math.floor(slideIndex / s.params.slidesPerGroup), 
                    s.snapIndex >= s.snapGrid.length && (s.snapIndex = s.snapGrid.length - 1);
                    var translate = -s.snapGrid[s.snapIndex];
                    s.params.autoplay && s.autoplaying && (internal || !s.params.autoplayDisableOnInteraction ? s.pauseAutoplay(speed) : s.stopAutoplay()), 
                    s.updateProgress(translate);
                    for (var i = 0; i < s.slidesGrid.length; i++) -Math.floor(100 * translate) >= Math.floor(100 * s.slidesGrid[i]) && (slideIndex = i);
                    return !s.params.allowSwipeToNext && translate < s.translate && translate < s.minTranslate() ? !1 : !s.params.allowSwipeToPrev && translate > s.translate && translate > s.maxTranslate() && (s.activeIndex || 0) !== slideIndex ? !1 : ("undefined" == typeof speed && (speed = s.params.speed), 
                    s.previousIndex = s.activeIndex || 0, s.activeIndex = slideIndex, s.rtl && -translate === s.translate || !s.rtl && translate === s.translate ? (s.params.autoHeight && s.updateAutoHeight(), 
                    s.updateClasses(), "slide" !== s.params.effect && s.setWrapperTranslate(translate), 
                    !1) : (s.updateClasses(), s.onTransitionStart(runCallbacks), 0 === speed ? (s.setWrapperTranslate(translate), 
                    s.setWrapperTransition(0), s.onTransitionEnd(runCallbacks)) : (s.setWrapperTranslate(translate), 
                    s.setWrapperTransition(speed), s.animating || (s.animating = !0, s.wrapper.transitionEnd(function() {
                        s && s.onTransitionEnd(runCallbacks);
                    }))), !0));
                }, s.onTransitionStart = function(runCallbacks) {
                    "undefined" == typeof runCallbacks && (runCallbacks = !0), s.params.autoHeight && s.updateAutoHeight(), 
                    s.lazy && s.lazy.onTransitionStart(), runCallbacks && (s.emit("onTransitionStart", s), 
                    s.activeIndex !== s.previousIndex && (s.emit("onSlideChangeStart", s), s.activeIndex > s.previousIndex ? s.emit("onSlideNextStart", s) : s.emit("onSlidePrevStart", s)));
                }, s.onTransitionEnd = function(runCallbacks) {
                    s.animating = !1, s.setWrapperTransition(0), "undefined" == typeof runCallbacks && (runCallbacks = !0), 
                    s.lazy && s.lazy.onTransitionEnd(), runCallbacks && (s.emit("onTransitionEnd", s), 
                    s.activeIndex !== s.previousIndex && (s.emit("onSlideChangeEnd", s), s.activeIndex > s.previousIndex ? s.emit("onSlideNextEnd", s) : s.emit("onSlidePrevEnd", s))), 
                    s.params.hashnav && s.hashnav && s.hashnav.setHash();
                }, s.slideNext = function(runCallbacks, speed, internal) {
                    if (s.params.loop) {
                        if (s.animating) return !1;
                        s.fixLoop();
                        s.container[0].clientLeft;
                        return s.slideTo(s.activeIndex + s.params.slidesPerGroup, speed, runCallbacks, internal);
                    }
                    return s.slideTo(s.activeIndex + s.params.slidesPerGroup, speed, runCallbacks, internal);
                }, s._slideNext = function(speed) {
                    return s.slideNext(!0, speed, !0);
                }, s.slidePrev = function(runCallbacks, speed, internal) {
                    if (s.params.loop) {
                        if (s.animating) return !1;
                        s.fixLoop();
                        s.container[0].clientLeft;
                        return s.slideTo(s.activeIndex - 1, speed, runCallbacks, internal);
                    }
                    return s.slideTo(s.activeIndex - 1, speed, runCallbacks, internal);
                }, s._slidePrev = function(speed) {
                    return s.slidePrev(!0, speed, !0);
                }, s.slideReset = function(runCallbacks, speed, internal) {
                    return s.slideTo(s.activeIndex, speed, runCallbacks);
                }, s.setWrapperTransition = function(duration, byController) {
                    s.wrapper.transition(duration), "slide" !== s.params.effect && s.effects[s.params.effect] && s.effects[s.params.effect].setTransition(duration), 
                    s.params.parallax && s.parallax && s.parallax.setTransition(duration), s.params.scrollbar && s.scrollbar && s.scrollbar.setTransition(duration), 
                    s.params.control && s.controller && s.controller.setTransition(duration, byController), 
                    s.emit("onSetTransition", s, duration);
                }, s.setWrapperTranslate = function(translate, updateActiveIndex, byController) {
                    var x = 0, y = 0, z = 0;
                    isH() ? x = s.rtl ? -translate : translate : y = translate, s.params.roundLengths && (x = round(x), 
                    y = round(y)), s.params.virtualTranslate || (s.support.transforms3d ? s.wrapper.transform("translate3d(" + x + "px, " + y + "px, " + z + "px)") : s.wrapper.transform("translate(" + x + "px, " + y + "px)")), 
                    s.translate = isH() ? x : y;
                    var progress, translatesDiff = s.maxTranslate() - s.minTranslate();
                    progress = 0 === translatesDiff ? 0 : (translate - s.minTranslate()) / translatesDiff, 
                    progress !== s.progress && s.updateProgress(translate), updateActiveIndex && s.updateActiveIndex(), 
                    "slide" !== s.params.effect && s.effects[s.params.effect] && s.effects[s.params.effect].setTranslate(s.translate), 
                    s.params.parallax && s.parallax && s.parallax.setTranslate(s.translate), s.params.scrollbar && s.scrollbar && s.scrollbar.setTranslate(s.translate), 
                    s.params.control && s.controller && s.controller.setTranslate(s.translate, byController), 
                    s.emit("onSetTranslate", s, s.translate);
                }, s.getTranslate = function(el, axis) {
                    var matrix, curTransform, curStyle, transformMatrix;
                    return "undefined" == typeof axis && (axis = "x"), s.params.virtualTranslate ? s.rtl ? -s.translate : s.translate : (curStyle = window.getComputedStyle(el, null), 
                    window.WebKitCSSMatrix ? (curTransform = curStyle.transform || curStyle.webkitTransform, 
                    curTransform.split(",").length > 6 && (curTransform = curTransform.split(", ").map(function(a) {
                        return a.replace(",", ".");
                    }).join(", ")), transformMatrix = new window.WebKitCSSMatrix("none" === curTransform ? "" : curTransform)) : (transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), 
                    matrix = transformMatrix.toString().split(",")), "x" === axis && (curTransform = window.WebKitCSSMatrix ? transformMatrix.m41 : 16 === matrix.length ? parseFloat(matrix[12]) : parseFloat(matrix[4])), 
                    "y" === axis && (curTransform = window.WebKitCSSMatrix ? transformMatrix.m42 : 16 === matrix.length ? parseFloat(matrix[13]) : parseFloat(matrix[5])), 
                    s.rtl && curTransform && (curTransform = -curTransform), curTransform || 0);
                }, s.getWrapperTranslate = function(axis) {
                    return "undefined" == typeof axis && (axis = isH() ? "x" : "y"), s.getTranslate(s.wrapper[0], axis);
                }, s.observers = [], s.initObservers = function() {
                    if (s.params.observeParents) for (var containerParents = s.container.parents(), i = 0; i < containerParents.length; i++) initObserver(containerParents[i]);
                    initObserver(s.container[0], {
                        childList: !1
                    }), initObserver(s.wrapper[0], {
                        attributes: !1
                    });
                }, s.disconnectObservers = function() {
                    for (var i = 0; i < s.observers.length; i++) s.observers[i].disconnect();
                    s.observers = [];
                }, s.createLoop = function() {
                    var toRemove = s.wrapper.children("." + s.params.slideClass + "." + s.params.slideDuplicateClass);
                    angular.element(toRemove).remove();
                    var slides = s.wrapper.children("." + s.params.slideClass);
                    "auto" !== s.params.slidesPerView || s.params.loopedSlides || (s.params.loopedSlides = slides.length), 
                    s.loopedSlides = parseInt(s.params.loopedSlides || s.params.slidesPerView, 10), 
                    s.loopedSlides = s.loopedSlides + s.params.loopAdditionalSlides, s.loopedSlides > slides.length && (s.loopedSlides = slides.length);
                    var i, scope, newNode, prependSlides = [], appendSlides = [];
                    for (slides.each(function(index, el) {
                        var slide = $(this);
                        index < s.loopedSlides && appendSlides.push(el), index < slides.length && index >= slides.length - s.loopedSlides && prependSlides.push(el), 
                        slide.attr("data-swiper-slide-index", index);
                    }), i = 0; i < appendSlides.length; i++) newNode = angular.element(appendSlides[i]).clone().addClass(s.params.slideDuplicateClass), 
                    newNode.removeAttr("ng-transclude"), newNode.removeAttr("ng-repeat"), scope = angular.element(appendSlides[i]).scope(), 
                    newNode = $compile(newNode)(scope), angular.element(s.wrapper).append(newNode);
                    for (i = prependSlides.length - 1; i >= 0; i--) newNode = angular.element(prependSlides[i]).clone().addClass(s.params.slideDuplicateClass), 
                    newNode.removeAttr("ng-transclude"), newNode.removeAttr("ng-repeat"), scope = angular.element(prependSlides[i]).scope(), 
                    newNode = $compile(newNode)(scope), angular.element(s.wrapper).prepend(newNode);
                }, s.destroyLoop = function() {
                    s.wrapper.children("." + s.params.slideClass + "." + s.params.slideDuplicateClass).remove(), 
                    s.slides.removeAttr("data-swiper-slide-index");
                }, s.fixLoop = function() {
                    var newIndex;
                    s.activeIndex < s.loopedSlides ? (newIndex = s.slides.length - 3 * s.loopedSlides + s.activeIndex, 
                    newIndex += s.loopedSlides, s.slideTo(newIndex, 0, !1, !0)) : ("auto" === s.params.slidesPerView && s.activeIndex >= 2 * s.loopedSlides || s.activeIndex > s.slides.length - 2 * s.params.slidesPerView) && (newIndex = -s.slides.length + s.activeIndex + s.loopedSlides, 
                    newIndex += s.loopedSlides, s.slideTo(newIndex, 0, !1, !0));
                }, s.appendSlide = function(slides) {
                    if (s.params.loop && s.destroyLoop(), "object" == typeof slides && slides.length) for (var i = 0; i < slides.length; i++) slides[i] && s.wrapper.append(slides[i]); else s.wrapper.append(slides);
                    s.params.loop && s.createLoop(), s.params.observer && s.support.observer || s.update(!0);
                }, s.prependSlide = function(slides) {
                    s.params.loop && s.destroyLoop();
                    var newActiveIndex = s.activeIndex + 1;
                    if ("object" == typeof slides && slides.length) {
                        for (var i = 0; i < slides.length; i++) slides[i] && s.wrapper.prepend(slides[i]);
                        newActiveIndex = s.activeIndex + slides.length;
                    } else s.wrapper.prepend(slides);
                    s.params.loop && s.createLoop(), s.params.observer && s.support.observer || s.update(!0), 
                    s.slideTo(newActiveIndex, 0, !1);
                }, s.removeSlide = function(slidesIndexes) {
                    s.params.loop && (s.destroyLoop(), s.slides = s.wrapper.children("." + s.params.slideClass));
                    var indexToRemove, newActiveIndex = s.activeIndex;
                    if ("object" == typeof slidesIndexes && slidesIndexes.length) {
                        for (var i = 0; i < slidesIndexes.length; i++) indexToRemove = slidesIndexes[i], 
                        s.slides[indexToRemove] && s.slides.eq(indexToRemove).remove(), newActiveIndex > indexToRemove && newActiveIndex--;
                        newActiveIndex = Math.max(newActiveIndex, 0);
                    } else indexToRemove = slidesIndexes, s.slides[indexToRemove] && s.slides.eq(indexToRemove).remove(), 
                    newActiveIndex > indexToRemove && newActiveIndex--, newActiveIndex = Math.max(newActiveIndex, 0);
                    s.params.loop && s.createLoop(), s.params.observer && s.support.observer || s.update(!0), 
                    s.params.loop ? s.slideTo(newActiveIndex + s.loopedSlides, 0, !1) : s.slideTo(newActiveIndex, 0, !1);
                }, s.removeAllSlides = function() {
                    for (var slidesIndexes = [], i = 0; i < s.slides.length; i++) slidesIndexes.push(i);
                    s.removeSlide(slidesIndexes);
                }, s.effects = {
                    fade: {
                        setTranslate: function() {
                            for (var i = 0; i < s.slides.length; i++) {
                                var slide = s.slides.eq(i), offset = slide[0].swiperSlideOffset, tx = -offset;
                                s.params.virtualTranslate || (tx -= s.translate);
                                var ty = 0;
                                isH() || (ty = tx, tx = 0);
                                var slideOpacity = s.params.fade.crossFade ? Math.max(1 - Math.abs(slide[0].progress), 0) : 1 + Math.min(Math.max(slide[0].progress, -1), 0);
                                slide.css({
                                    opacity: slideOpacity
                                }).transform("translate3d(" + tx + "px, " + ty + "px, 0px)");
                            }
                        },
                        setTransition: function(duration) {
                            if (s.slides.transition(duration), s.params.virtualTranslate && 0 !== duration) {
                                var eventTriggered = !1;
                                s.slides.transitionEnd(function() {
                                    if (!eventTriggered && s) {
                                        eventTriggered = !0, s.animating = !1;
                                        for (var triggerEvents = [ "webkitTransitionEnd", "transitionend", "oTransitionEnd", "MSTransitionEnd", "msTransitionEnd" ], i = 0; i < triggerEvents.length; i++) s.wrapper.trigger(triggerEvents[i]);
                                    }
                                });
                            }
                        }
                    },
                    cube: {
                        setTranslate: function() {
                            var cubeShadow, wrapperRotate = 0;
                            s.params.cube.shadow && (isH() ? (cubeShadow = s.wrapper.find(".swiper-cube-shadow"), 
                            0 === cubeShadow.length && (cubeShadow = $('<div class="swiper-cube-shadow"></div>'), 
                            s.wrapper.append(cubeShadow)), cubeShadow.css({
                                height: s.width + "px"
                            })) : (cubeShadow = s.container.find(".swiper-cube-shadow"), 0 === cubeShadow.length && (cubeShadow = $('<div class="swiper-cube-shadow"></div>'), 
                            s.container.append(cubeShadow))));
                            for (var i = 0; i < s.slides.length; i++) {
                                var slide = s.slides.eq(i), slideAngle = 90 * i, round = Math.floor(slideAngle / 360);
                                s.rtl && (slideAngle = -slideAngle, round = Math.floor(-slideAngle / 360));
                                var progress = Math.max(Math.min(slide[0].progress, 1), -1), tx = 0, ty = 0, tz = 0;
                                i % 4 === 0 ? (tx = 4 * -round * s.size, tz = 0) : (i - 1) % 4 === 0 ? (tx = 0, 
                                tz = 4 * -round * s.size) : (i - 2) % 4 === 0 ? (tx = s.size + 4 * round * s.size, 
                                tz = s.size) : (i - 3) % 4 === 0 && (tx = -s.size, tz = 3 * s.size + 4 * s.size * round), 
                                s.rtl && (tx = -tx), isH() || (ty = tx, tx = 0);
                                var transform = "rotateX(" + (isH() ? 0 : -slideAngle) + "deg) rotateY(" + (isH() ? slideAngle : 0) + "deg) translate3d(" + tx + "px, " + ty + "px, " + tz + "px)";
                                if (1 >= progress && progress > -1 && (wrapperRotate = 90 * i + 90 * progress, s.rtl && (wrapperRotate = 90 * -i - 90 * progress)), 
                                slide.transform(transform), s.params.cube.slideShadows) {
                                    var shadowBefore = isH() ? slide.find(".swiper-slide-shadow-left") : slide.find(".swiper-slide-shadow-top"), shadowAfter = isH() ? slide.find(".swiper-slide-shadow-right") : slide.find(".swiper-slide-shadow-bottom");
                                    0 === shadowBefore.length && (shadowBefore = $('<div class="swiper-slide-shadow-' + (isH() ? "left" : "top") + '"></div>'), 
                                    slide.append(shadowBefore)), 0 === shadowAfter.length && (shadowAfter = $('<div class="swiper-slide-shadow-' + (isH() ? "right" : "bottom") + '"></div>'), 
                                    slide.append(shadowAfter));
                                    slide[0].progress;
                                    shadowBefore.length && (shadowBefore[0].style.opacity = -slide[0].progress), shadowAfter.length && (shadowAfter[0].style.opacity = slide[0].progress);
                                }
                            }
                            if (s.wrapper.css({
                                "-webkit-transform-origin": "50% 50% -" + s.size / 2 + "px",
                                "-moz-transform-origin": "50% 50% -" + s.size / 2 + "px",
                                "-ms-transform-origin": "50% 50% -" + s.size / 2 + "px",
                                "transform-origin": "50% 50% -" + s.size / 2 + "px"
                            }), s.params.cube.shadow) if (isH()) cubeShadow.transform("translate3d(0px, " + (s.width / 2 + s.params.cube.shadowOffset) + "px, " + -s.width / 2 + "px) rotateX(90deg) rotateZ(0deg) scale(" + s.params.cube.shadowScale + ")"); else {
                                var shadowAngle = Math.abs(wrapperRotate) - 90 * Math.floor(Math.abs(wrapperRotate) / 90), multiplier = 1.5 - (Math.sin(2 * shadowAngle * Math.PI / 360) / 2 + Math.cos(2 * shadowAngle * Math.PI / 360) / 2), scale1 = s.params.cube.shadowScale, scale2 = s.params.cube.shadowScale / multiplier, offset = s.params.cube.shadowOffset;
                                cubeShadow.transform("scale3d(" + scale1 + ", 1, " + scale2 + ") translate3d(0px, " + (s.height / 2 + offset) + "px, " + -s.height / 2 / scale2 + "px) rotateX(-90deg)");
                            }
                            var zFactor = s.isSafari || s.isUiWebView ? -s.size / 2 : 0;
                            s.wrapper.transform("translate3d(0px,0," + zFactor + "px) rotateX(" + (isH() ? 0 : wrapperRotate) + "deg) rotateY(" + (isH() ? -wrapperRotate : 0) + "deg)");
                        },
                        setTransition: function(duration) {
                            s.slides.transition(duration).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(duration), 
                            s.params.cube.shadow && !isH() && s.container.find(".swiper-cube-shadow").transition(duration);
                        }
                    },
                    coverflow: {
                        setTranslate: function() {
                            for (var transform = s.translate, center = isH() ? -transform + s.width / 2 : -transform + s.height / 2, rotate = isH() ? s.params.coverflow.rotate : -s.params.coverflow.rotate, translate = s.params.coverflow.depth, i = 0, length = s.slides.length; length > i; i++) {
                                var slide = s.slides.eq(i), slideSize = s.slidesSizesGrid[i], slideOffset = slide[0].swiperSlideOffset, offsetMultiplier = (center - slideOffset - slideSize / 2) / slideSize * s.params.coverflow.modifier, rotateY = isH() ? rotate * offsetMultiplier : 0, rotateX = isH() ? 0 : rotate * offsetMultiplier, translateZ = -translate * Math.abs(offsetMultiplier), translateY = isH() ? 0 : s.params.coverflow.stretch * offsetMultiplier, translateX = isH() ? s.params.coverflow.stretch * offsetMultiplier : 0;
                                Math.abs(translateX) < .001 && (translateX = 0), Math.abs(translateY) < .001 && (translateY = 0), 
                                Math.abs(translateZ) < .001 && (translateZ = 0), Math.abs(rotateY) < .001 && (rotateY = 0), 
                                Math.abs(rotateX) < .001 && (rotateX = 0);
                                var slideTransform = "translate3d(" + translateX + "px," + translateY + "px," + translateZ + "px)  rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg)";
                                if (slide.transform(slideTransform), slide[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1, 
                                s.params.coverflow.slideShadows) {
                                    var shadowBefore = isH() ? slide.find(".swiper-slide-shadow-left") : slide.find(".swiper-slide-shadow-top"), shadowAfter = isH() ? slide.find(".swiper-slide-shadow-right") : slide.find(".swiper-slide-shadow-bottom");
                                    0 === shadowBefore.length && (shadowBefore = $('<div class="swiper-slide-shadow-' + (isH() ? "left" : "top") + '"></div>'), 
                                    slide.append(shadowBefore)), 0 === shadowAfter.length && (shadowAfter = $('<div class="swiper-slide-shadow-' + (isH() ? "right" : "bottom") + '"></div>'), 
                                    slide.append(shadowAfter)), shadowBefore.length && (shadowBefore[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0), 
                                    shadowAfter.length && (shadowAfter[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0);
                                }
                            }
                            if (s.browser.ie) {
                                var ws = s.wrapper[0].style;
                                ws.perspectiveOrigin = center + "px 50%";
                            }
                        },
                        setTransition: function(duration) {
                            s.slides.transition(duration).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(duration);
                        }
                    }
                }, s.lazy = {
                    initialImageLoaded: !1,
                    loadImageInSlide: function(index, loadInDuplicate) {
                        if ("undefined" != typeof index && ("undefined" == typeof loadInDuplicate && (loadInDuplicate = !0), 
                        0 !== s.slides.length)) {
                            var slide = s.slides.eq(index), img = slide.find(".swiper-lazy:not(.swiper-lazy-loaded):not(.swiper-lazy-loading)");
                            !slide.hasClass("swiper-lazy") || slide.hasClass("swiper-lazy-loaded") || slide.hasClass("swiper-lazy-loading") || (img = img.add(slide[0])), 
                            0 !== img.length && img.each(function() {
                                var _img = $(this);
                                _img.addClass("swiper-lazy-loading");
                                var background = _img.attr("data-background"), src = _img.attr("data-src"), srcset = _img.attr("data-srcset");
                                s.loadImage(_img[0], src || background, srcset, !1, function() {
                                    if (background ? (_img.css("background-image", "url(" + background + ")"), _img.removeAttr("data-background")) : (srcset && (_img.attr("srcset", srcset), 
                                    _img.removeAttr("data-srcset")), src && (_img.attr("src", src), _img.removeAttr("data-src"))), 
                                    _img.addClass("swiper-lazy-loaded").removeClass("swiper-lazy-loading"), slide.find(".swiper-lazy-preloader, .preloader").remove(), 
                                    s.params.loop && loadInDuplicate) {
                                        var slideOriginalIndex = slide.attr("data-swiper-slide-index");
                                        if (slide.hasClass(s.params.slideDuplicateClass)) {
                                            var originalSlide = s.wrapper.children('[data-swiper-slide-index="' + slideOriginalIndex + '"]:not(.' + s.params.slideDuplicateClass + ")");
                                            s.lazy.loadImageInSlide(originalSlide.index(), !1);
                                        } else {
                                            var duplicatedSlide = s.wrapper.children("." + s.params.slideDuplicateClass + '[data-swiper-slide-index="' + slideOriginalIndex + '"]');
                                            s.lazy.loadImageInSlide(duplicatedSlide.index(), !1);
                                        }
                                    }
                                    s.emit("onLazyImageReady", s, slide[0], _img[0]);
                                }), s.emit("onLazyImageLoad", s, slide[0], _img[0]);
                            });
                        }
                    },
                    load: function() {
                        var i;
                        if (s.params.watchSlidesVisibility) s.wrapper.children("." + s.params.slideVisibleClass).each(function() {
                            s.lazy.loadImageInSlide($(this).index());
                        }); else if (s.params.slidesPerView > 1) for (i = s.activeIndex; i < s.activeIndex + s.params.slidesPerView; i++) s.slides[i] && s.lazy.loadImageInSlide(i); else s.lazy.loadImageInSlide(s.activeIndex);
                        if (s.params.lazyLoadingInPrevNext) if (s.params.slidesPerView > 1) {
                            for (i = s.activeIndex + s.params.slidesPerView; i < s.activeIndex + s.params.slidesPerView + s.params.slidesPerView; i++) s.slides[i] && s.lazy.loadImageInSlide(i);
                            for (i = s.activeIndex - s.params.slidesPerView; i < s.activeIndex; i++) s.slides[i] && s.lazy.loadImageInSlide(i);
                        } else {
                            var nextSlide = s.wrapper.children("." + s.params.slideNextClass);
                            nextSlide.length > 0 && s.lazy.loadImageInSlide(nextSlide.index());
                            var prevSlide = s.wrapper.children("." + s.params.slidePrevClass);
                            prevSlide.length > 0 && s.lazy.loadImageInSlide(prevSlide.index());
                        }
                    },
                    onTransitionStart: function() {
                        s.params.lazyLoading && (s.params.lazyLoadingOnTransitionStart || !s.params.lazyLoadingOnTransitionStart && !s.lazy.initialImageLoaded) && s.lazy.load();
                    },
                    onTransitionEnd: function() {
                        s.params.lazyLoading && !s.params.lazyLoadingOnTransitionStart && s.lazy.load();
                    }
                }, s.scrollbar = {
                    isTouched: !1,
                    setDragPosition: function(e) {
                        var sb = s.scrollbar, pointerPosition = isH() ? "touchstart" === e.type || "touchmove" === e.type ? e.targetTouches[0].pageX : e.pageX || e.clientX : "touchstart" === e.type || "touchmove" === e.type ? e.targetTouches[0].pageY : e.pageY || e.clientY, position = pointerPosition - sb.track.offset()[isH() ? "left" : "top"] - sb.dragSize / 2, positionMin = -s.minTranslate() * sb.moveDivider, positionMax = -s.maxTranslate() * sb.moveDivider;
                        positionMin > position ? position = positionMin : position > positionMax && (position = positionMax), 
                        position = -position / sb.moveDivider, s.updateProgress(position), s.setWrapperTranslate(position, !0);
                    },
                    dragStart: function(e) {
                        var sb = s.scrollbar;
                        sb.isTouched = !0, e.preventDefault(), e.stopPropagation(), sb.setDragPosition(e), 
                        clearTimeout(sb.dragTimeout), sb.track.transition(0), s.params.scrollbarHide && sb.track.css("opacity", 1), 
                        s.wrapper.transition(100), sb.drag.transition(100), s.emit("onScrollbarDragStart", s);
                    },
                    dragMove: function(e) {
                        var sb = s.scrollbar;
                        sb.isTouched && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, sb.setDragPosition(e), 
                        s.wrapper.transition(0), sb.track.transition(0), sb.drag.transition(0), s.emit("onScrollbarDragMove", s));
                    },
                    dragEnd: function(e) {
                        var sb = s.scrollbar;
                        sb.isTouched && (sb.isTouched = !1, s.params.scrollbarHide && (clearTimeout(sb.dragTimeout), 
                        sb.dragTimeout = setTimeout(function() {
                            sb.track.css("opacity", 0), sb.track.transition(400);
                        }, 1e3)), s.emit("onScrollbarDragEnd", s), s.params.scrollbarSnapOnRelease && s.slideReset());
                    },
                    enableDraggable: function() {
                        var sb = s.scrollbar, target = s.support.touch ? sb.track : document;
                        $(sb.track).on(s.touchEvents.start, sb.dragStart), $(target).on(s.touchEvents.move, sb.dragMove), 
                        $(target).on(s.touchEvents.end, sb.dragEnd);
                    },
                    disableDraggable: function() {
                        var sb = s.scrollbar, target = s.support.touch ? sb.track : document;
                        $(sb.track).off(s.touchEvents.start, sb.dragStart), $(target).off(s.touchEvents.move, sb.dragMove), 
                        $(target).off(s.touchEvents.end, sb.dragEnd);
                    },
                    set: function() {
                        if (s.params.scrollbar) {
                            var sb = s.scrollbar;
                            sb.track = $(s.params.scrollbar), sb.drag = sb.track.find(".swiper-scrollbar-drag"), 
                            0 === sb.drag.length && (sb.drag = $('<div class="swiper-scrollbar-drag"></div>'), 
                            sb.track.append(sb.drag)), sb.drag[0].style.width = "", sb.drag[0].style.height = "", 
                            sb.trackSize = isH() ? sb.track[0].offsetWidth : sb.track[0].offsetHeight, sb.divider = s.size / s.virtualSize, 
                            sb.moveDivider = sb.divider * (sb.trackSize / s.size), sb.dragSize = sb.trackSize * sb.divider, 
                            isH() ? sb.drag[0].style.width = sb.dragSize + "px" : sb.drag[0].style.height = sb.dragSize + "px", 
                            sb.divider >= 1 ? sb.track[0].style.display = "none" : sb.track[0].style.display = "", 
                            s.params.scrollbarHide && (sb.track[0].style.opacity = 0);
                        }
                    },
                    setTranslate: function() {
                        if (s.params.scrollbar) {
                            var newPos, sb = s.scrollbar, newSize = (s.translate || 0, sb.dragSize);
                            newPos = (sb.trackSize - sb.dragSize) * s.progress, s.rtl && isH() ? (newPos = -newPos, 
                            newPos > 0 ? (newSize = sb.dragSize - newPos, newPos = 0) : -newPos + sb.dragSize > sb.trackSize && (newSize = sb.trackSize + newPos)) : 0 > newPos ? (newSize = sb.dragSize + newPos, 
                            newPos = 0) : newPos + sb.dragSize > sb.trackSize && (newSize = sb.trackSize - newPos), 
                            isH() ? (s.support.transforms3d ? sb.drag.transform("translate3d(" + newPos + "px, 0, 0)") : sb.drag.transform("translateX(" + newPos + "px)"), 
                            sb.drag[0].style.width = newSize + "px") : (s.support.transforms3d ? sb.drag.transform("translate3d(0px, " + newPos + "px, 0)") : sb.drag.transform("translateY(" + newPos + "px)"), 
                            sb.drag[0].style.height = newSize + "px"), s.params.scrollbarHide && (clearTimeout(sb.timeout), 
                            sb.track[0].style.opacity = 1, sb.timeout = setTimeout(function() {
                                sb.track[0].style.opacity = 0, sb.track.transition(400);
                            }, 1e3));
                        }
                    },
                    setTransition: function(duration) {
                        s.params.scrollbar && s.scrollbar.drag.transition(duration);
                    }
                }, s.controller = {
                    LinearSpline: function(x, y) {
                        this.x = x, this.y = y, this.lastIndex = x.length - 1;
                        var i1, i3;
                        this.x.length;
                        this.interpolate = function(x2) {
                            return x2 ? (i3 = binarySearch(this.x, x2), i1 = i3 - 1, (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1]) : 0;
                        };
                        var binarySearch = function() {
                            var maxIndex, minIndex, guess;
                            return function(array, val) {
                                for (minIndex = -1, maxIndex = array.length; maxIndex - minIndex > 1; ) array[guess = maxIndex + minIndex >> 1] <= val ? minIndex = guess : maxIndex = guess;
                                return maxIndex;
                            };
                        }();
                    },
                    getInterpolateFunction: function(c) {
                        s.controller.spline || (s.controller.spline = s.params.loop ? new s.controller.LinearSpline(s.slidesGrid, c.slidesGrid) : new s.controller.LinearSpline(s.snapGrid, c.snapGrid));
                    },
                    setTranslate: function(translate, byController) {
                        function setControlledTranslate(c) {
                            translate = c.rtl && "horizontal" === c.params.direction ? -s.translate : s.translate, 
                            "slide" === s.params.controlBy && (s.controller.getInterpolateFunction(c), controlledTranslate = -s.controller.spline.interpolate(-translate)), 
                            controlledTranslate && "container" !== s.params.controlBy || (multiplier = (c.maxTranslate() - c.minTranslate()) / (s.maxTranslate() - s.minTranslate()), 
                            controlledTranslate = (translate - s.minTranslate()) * multiplier + c.minTranslate()), 
                            s.params.controlInverse && (controlledTranslate = c.maxTranslate() - controlledTranslate), 
                            c.updateProgress(controlledTranslate), c.setWrapperTranslate(controlledTranslate, !1, s), 
                            c.updateActiveIndex();
                        }
                        var multiplier, controlledTranslate, controlled = s.params.control;
                        if (s.isArray(controlled)) for (var i = 0; i < controlled.length; i++) controlled[i] !== byController && controlled[i] instanceof Swiper && setControlledTranslate(controlled[i]); else controlled instanceof Swiper && byController !== controlled && setControlledTranslate(controlled);
                    },
                    setTransition: function(duration, byController) {
                        function setControlledTransition(c) {
                            c.setWrapperTransition(duration, s), 0 !== duration && (c.onTransitionStart(), c.wrapper.transitionEnd(function() {
                                controlled && (c.params.loop && "slide" === s.params.controlBy && c.fixLoop(), c.onTransitionEnd());
                            }));
                        }
                        var i, controlled = s.params.control;
                        if (s.isArray(controlled)) for (i = 0; i < controlled.length; i++) controlled[i] !== byController && controlled[i] instanceof Swiper && setControlledTransition(controlled[i]); else controlled instanceof Swiper && byController !== controlled && setControlledTransition(controlled);
                    }
                }, s.hashnav = {
                    init: function() {
                        if (s.params.hashnav) {
                            s.hashnav.initialized = !0;
                            var hash = document.location.hash.replace("#", "");
                            if (hash) for (var speed = 0, i = 0, length = s.slides.length; length > i; i++) {
                                var slide = s.slides.eq(i), slideHash = slide.attr("data-hash");
                                if (slideHash === hash && !slide.hasClass(s.params.slideDuplicateClass)) {
                                    var index = slide.index();
                                    s.slideTo(index, speed, s.params.runCallbacksOnInit, !0);
                                }
                            }
                        }
                    },
                    setHash: function() {
                        s.hashnav.initialized && s.params.hashnav && (document.location.hash = s.slides.eq(s.activeIndex).attr("data-hash") || "");
                    }
                }, s.disableKeyboardControl = function() {
                    s.params.keyboardControl = !1, $(document).off("keydown", handleKeyboard);
                }, s.enableKeyboardControl = function() {
                    s.params.keyboardControl = !0, $(document).on("keydown", handleKeyboard);
                }, s.mousewheel = {
                    event: !1,
                    lastScrollTime: new window.Date().getTime()
                }, s.params.mousewheelControl) {
                    try {
                        new window.WheelEvent("wheel"), s.mousewheel.event = "wheel";
                    } catch (e) {}
                    s.mousewheel.event || void 0 === document.onmousewheel || (s.mousewheel.event = "mousewheel"), 
                    s.mousewheel.event || (s.mousewheel.event = "DOMMouseScroll");
                }
                s.disableMousewheelControl = function() {
                    return s.mousewheel.event ? (s.container.off(s.mousewheel.event, handleMousewheel), 
                    !0) : !1;
                }, s.enableMousewheelControl = function() {
                    return s.mousewheel.event ? (s.container.on(s.mousewheel.event, handleMousewheel), 
                    !0) : !1;
                }, s.parallax = {
                    setTranslate: function() {
                        s.container.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]").each(function() {
                            setParallaxTransform(this, s.progress);
                        }), s.slides.each(function() {
                            var slide = $(this);
                            slide.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]").each(function() {
                                var progress = Math.min(Math.max(slide[0].progress, -1), 1);
                                setParallaxTransform(this, progress);
                            });
                        });
                    },
                    setTransition: function(duration) {
                        "undefined" == typeof duration && (duration = s.params.speed), s.container.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]").each(function() {
                            var el = $(this), parallaxDuration = parseInt(el.attr("data-swiper-parallax-duration"), 10) || duration;
                            0 === duration && (parallaxDuration = 0), el.transition(parallaxDuration);
                        });
                    }
                }, s._plugins = [];
                for (var plugin in s.plugins) {
                    var p = s.plugins[plugin](s, s.params[plugin]);
                    p && s._plugins.push(p);
                }
                return s.callPlugins = function(eventName) {
                    for (var i = 0; i < s._plugins.length; i++) eventName in s._plugins[i] && s._plugins[i][eventName](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                }, s.emitterEventListeners = {}, s.emit = function(eventName) {
                    s.params[eventName] && s.params[eventName](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                    var i;
                    if (s.emitterEventListeners[eventName]) for (i = 0; i < s.emitterEventListeners[eventName].length; i++) s.emitterEventListeners[eventName][i](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                    s.callPlugins && s.callPlugins(eventName, arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                }, s.on = function(eventName, handler) {
                    return eventName = normalizeEventName(eventName), s.emitterEventListeners[eventName] || (s.emitterEventListeners[eventName] = []), 
                    s.emitterEventListeners[eventName].push(handler), s;
                }, s.off = function(eventName, handler) {
                    var i;
                    if (eventName = normalizeEventName(eventName), "undefined" == typeof handler) return s.emitterEventListeners[eventName] = [], 
                    s;
                    if (s.emitterEventListeners[eventName] && 0 !== s.emitterEventListeners[eventName].length) {
                        for (i = 0; i < s.emitterEventListeners[eventName].length; i++) s.emitterEventListeners[eventName][i] === handler && s.emitterEventListeners[eventName].splice(i, 1);
                        return s;
                    }
                }, s.once = function(eventName, handler) {
                    eventName = normalizeEventName(eventName);
                    var _handler = function() {
                        handler(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]), s.off(eventName, _handler);
                    };
                    return s.on(eventName, _handler), s;
                }, s.a11y = {
                    makeFocusable: function($el) {
                        return $el.attr("tabIndex", "0"), $el;
                    },
                    addRole: function($el, role) {
                        return $el.attr("role", role), $el;
                    },
                    addLabel: function($el, label) {
                        return $el.attr("aria-label", label), $el;
                    },
                    disable: function($el) {
                        return $el.attr("aria-disabled", !0), $el;
                    },
                    enable: function($el) {
                        return $el.attr("aria-disabled", !1), $el;
                    },
                    onEnterKey: function(event) {
                        13 === event.keyCode && ($(event.target).is(s.params.nextButton) ? (s.onClickNext(event), 
                        s.isEnd ? s.a11y.notify(s.params.lastSlideMessage) : s.a11y.notify(s.params.nextSlideMessage)) : $(event.target).is(s.params.prevButton) && (s.onClickPrev(event), 
                        s.isBeginning ? s.a11y.notify(s.params.firstSlideMessage) : s.a11y.notify(s.params.prevSlideMessage)), 
                        $(event.target).is("." + s.params.bulletClass) && $(event.target)[0].click());
                    },
                    liveRegion: $('<span class="swiper-notification" aria-live="assertive" aria-atomic="true"></span>'),
                    notify: function(message) {
                        var notification = s.a11y.liveRegion;
                        0 !== notification.length && (notification.html(""), notification.html(message));
                    },
                    init: function() {
                        if (s.params.nextButton) {
                            var nextButton = $(s.params.nextButton);
                            s.a11y.makeFocusable(nextButton), s.a11y.addRole(nextButton, "button"), s.a11y.addLabel(nextButton, s.params.nextSlideMessage);
                        }
                        if (s.params.prevButton) {
                            var prevButton = $(s.params.prevButton);
                            s.a11y.makeFocusable(prevButton), s.a11y.addRole(prevButton, "button"), s.a11y.addLabel(prevButton, s.params.prevSlideMessage);
                        }
                        $(s.container).append(s.a11y.liveRegion);
                    },
                    initPagination: function() {
                        s.params.pagination && s.params.paginationClickable && s.bullets && s.bullets.length && s.bullets.each(function() {
                            var bullet = $(this);
                            s.a11y.makeFocusable(bullet), s.a11y.addRole(bullet, "button"), s.a11y.addLabel(bullet, s.params.paginationBulletMessage.replace(/{{index}}/, bullet.index() + 1));
                        });
                    },
                    destroy: function() {
                        s.a11y.liveRegion && s.a11y.liveRegion.length > 0 && s.a11y.liveRegion.remove();
                    }
                }, s.init = function() {
                    s.params.loop && s.createLoop(), s.updateContainerSize(), s.updateSlidesSize(), 
                    s.updatePagination(), s.params.scrollbar && s.scrollbar && (s.scrollbar.set(), s.params.scrollbarDraggable && s.scrollbar.enableDraggable()), 
                    "slide" !== s.params.effect && s.effects[s.params.effect] && (s.params.loop || s.updateProgress(), 
                    s.effects[s.params.effect].setTranslate()), s.params.loop ? s.slideTo(s.params.initialSlide + s.loopedSlides, 0, s.params.runCallbacksOnInit) : (s.slideTo(s.params.initialSlide, 0, s.params.runCallbacksOnInit), 
                    0 === s.params.initialSlide && (s.parallax && s.params.parallax && s.parallax.setTranslate(), 
                    s.lazy && s.params.lazyLoading && (s.lazy.load(), s.lazy.initialImageLoaded = !0))), 
                    s.attachEvents(), s.params.observer && s.support.observer && s.initObservers(), 
                    s.params.preloadImages && !s.params.lazyLoading && s.preloadImages(), s.params.autoplay && s.startAutoplay(), 
                    s.params.keyboardControl && s.enableKeyboardControl && s.enableKeyboardControl(), 
                    s.params.mousewheelControl && s.enableMousewheelControl && s.enableMousewheelControl(), 
                    s.params.hashnav && s.hashnav && s.hashnav.init(), s.params.a11y && s.a11y && s.a11y.init(), 
                    s.emit("onInit", s);
                }, s.cleanupStyles = function() {
                    s.container.removeClass(s.classNames.join(" ")).removeAttr("style"), s.wrapper.removeAttr("style"), 
                    s.slides && s.slides.length && s.slides.removeClass([ s.params.slideVisibleClass, s.params.slideActiveClass, s.params.slideNextClass, s.params.slidePrevClass ].join(" ")).removeAttr("style").removeAttr("data-swiper-column").removeAttr("data-swiper-row"), 
                    s.paginationContainer && s.paginationContainer.length && s.paginationContainer.removeClass(s.params.paginationHiddenClass), 
                    s.bullets && s.bullets.length && s.bullets.removeClass(s.params.bulletActiveClass), 
                    s.params.prevButton && $(s.params.prevButton).removeClass(s.params.buttonDisabledClass), 
                    s.params.nextButton && $(s.params.nextButton).removeClass(s.params.buttonDisabledClass), 
                    s.params.scrollbar && s.scrollbar && (s.scrollbar.track && s.scrollbar.track.length && s.scrollbar.track.removeAttr("style"), 
                    s.scrollbar.drag && s.scrollbar.drag.length && s.scrollbar.drag.removeAttr("style"));
                }, s.destroy = function(deleteInstance, cleanupStyles) {
                    s.detachEvents(), s.stopAutoplay(), s.params.scrollbar && s.scrollbar && s.params.scrollbarDraggable && s.scrollbar.disableDraggable(), 
                    s.params.loop && s.destroyLoop(), cleanupStyles && s.cleanupStyles(), s.disconnectObservers(), 
                    s.params.keyboardControl && s.disableKeyboardControl && s.disableKeyboardControl(), 
                    s.params.mousewheelControl && s.disableMousewheelControl && s.disableMousewheelControl(), 
                    s.params.a11y && s.a11y && s.a11y.destroy(), s.emit("onDestroy"), deleteInstance !== !1 && (s = null);
                }, s.init(), s;
            }
        };
        Swiper.prototype = {
            isSafari: function() {
                var ua = navigator.userAgent.toLowerCase();
                return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
            }(),
            isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(navigator.userAgent),
            isArray: function(arr) {
                return "[object Array]" === Object.prototype.toString.apply(arr);
            },
            browser: {
                ie: window.navigator.pointerEnabled || window.navigator.msPointerEnabled,
                ieTouch: window.navigator.msPointerEnabled && window.navigator.msMaxTouchPoints > 1 || window.navigator.pointerEnabled && window.navigator.maxTouchPoints > 1
            },
            device: function() {
                var ua = navigator.userAgent, android = ua.match(/(Android);?[\s\/]+([\d.]+)?/), ipad = ua.match(/(iPad).*OS\s([\d_]+)/), ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/), iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
                return {
                    ios: ipad || iphone || ipod,
                    android: android
                };
            }(),
            support: {
                touch: window.Modernizr && Modernizr.touch === !0 || function() {
                    return !!("ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch);
                }(),
                transforms3d: window.Modernizr && Modernizr.csstransforms3d === !0 || function() {
                    var div = document.createElement("div").style;
                    return "webkitPerspective" in div || "MozPerspective" in div || "OPerspective" in div || "MsPerspective" in div || "perspective" in div;
                }(),
                flexbox: function() {
                    for (var div = document.createElement("div").style, styles = "alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient".split(" "), i = 0; i < styles.length; i++) if (styles[i] in div) return !0;
                }(),
                observer: function() {
                    return "MutationObserver" in window || "WebkitMutationObserver" in window;
                }()
            },
            plugins: {}
        };
        for (var Dom7 = (function() {
            var Dom7 = function(arr) {
                var _this = this, i = 0;
                for (i = 0; i < arr.length; i++) _this[i] = arr[i];
                return _this.length = arr.length, this;
            }, $ = function(selector, context) {
                var arr = [], i = 0;
                if (selector && !context && selector instanceof Dom7) return selector;
                if (selector) if ("string" == typeof selector) {
                    var els, tempParent, html = selector.trim();
                    if (html.indexOf("<") >= 0 && html.indexOf(">") >= 0) {
                        var toCreate = "div";
                        for (0 === html.indexOf("<li") && (toCreate = "ul"), 0 === html.indexOf("<tr") && (toCreate = "tbody"), 
                        (0 === html.indexOf("<td") || 0 === html.indexOf("<th")) && (toCreate = "tr"), 0 === html.indexOf("<tbody") && (toCreate = "table"), 
                        0 === html.indexOf("<option") && (toCreate = "select"), tempParent = document.createElement(toCreate), 
                        tempParent.innerHTML = selector, i = 0; i < tempParent.childNodes.length; i++) arr.push(tempParent.childNodes[i]);
                    } else for (els = context || "#" !== selector[0] || selector.match(/[ .<>:~]/) ? (context || document).querySelectorAll(selector) : [ document.getElementById(selector.split("#")[1]) ], 
                    i = 0; i < els.length; i++) els[i] && arr.push(els[i]);
                } else if (selector.nodeType || selector === window || selector === document) arr.push(selector); else if (selector.length > 0 && selector[0].nodeType) for (i = 0; i < selector.length; i++) arr.push(selector[i]);
                return new Dom7(arr);
            };
            return Dom7.prototype = {
                addClass: function(className) {
                    if ("undefined" == typeof className) return this;
                    for (var classes = className.split(" "), i = 0; i < classes.length; i++) for (var j = 0; j < this.length; j++) this[j].classList.add(classes[i]);
                    return this;
                },
                removeClass: function(className) {
                    for (var classes = className.split(" "), i = 0; i < classes.length; i++) for (var j = 0; j < this.length; j++) this[j].classList.remove(classes[i]);
                    return this;
                },
                hasClass: function(className) {
                    return this[0] ? this[0].classList.contains(className) : !1;
                },
                toggleClass: function(className) {
                    for (var classes = className.split(" "), i = 0; i < classes.length; i++) for (var j = 0; j < this.length; j++) this[j].classList.toggle(classes[i]);
                    return this;
                },
                attr: function(attrs, value) {
                    if (1 === arguments.length && "string" == typeof attrs) return this[0] ? this[0].getAttribute(attrs) : void 0;
                    for (var i = 0; i < this.length; i++) if (2 === arguments.length) this[i].setAttribute(attrs, value); else for (var attrName in attrs) this[i][attrName] = attrs[attrName], 
                    this[i].setAttribute(attrName, attrs[attrName]);
                    return this;
                },
                removeAttr: function(attr) {
                    for (var i = 0; i < this.length; i++) this[i].removeAttribute(attr);
                    return this;
                },
                data: function(key, value) {
                    if ("undefined" == typeof value) {
                        if (this[0]) {
                            var dataKey = this[0].getAttribute("data-" + key);
                            return dataKey ? dataKey : this[0].dom7ElementDataStorage && key in this[0].dom7ElementDataStorage ? this[0].dom7ElementDataStorage[key] : void 0;
                        }
                        return void 0;
                    }
                    for (var i = 0; i < this.length; i++) {
                        var el = this[i];
                        el.dom7ElementDataStorage || (el.dom7ElementDataStorage = {}), el.dom7ElementDataStorage[key] = value;
                    }
                    return this;
                },
                transform: function(transform) {
                    for (var i = 0; i < this.length; i++) {
                        var elStyle = this[i].style;
                        elStyle.webkitTransform = elStyle.MsTransform = elStyle.msTransform = elStyle.MozTransform = elStyle.OTransform = elStyle.transform = transform;
                    }
                    return this;
                },
                transition: function(duration) {
                    "string" != typeof duration && (duration += "ms");
                    for (var i = 0; i < this.length; i++) {
                        var elStyle = this[i].style;
                        elStyle.webkitTransitionDuration = elStyle.MsTransitionDuration = elStyle.msTransitionDuration = elStyle.MozTransitionDuration = elStyle.OTransitionDuration = elStyle.transitionDuration = duration;
                    }
                    return this;
                },
                on: function(eventName, targetSelector, listener, capture) {
                    function handleLiveEvent(e) {
                        var target = e.target;
                        if ($(target).is(targetSelector)) listener.call(target, e); else for (var parents = $(target).parents(), k = 0; k < parents.length; k++) $(parents[k]).is(targetSelector) && listener.call(parents[k], e);
                    }
                    var i, j, events = eventName.split(" ");
                    for (i = 0; i < this.length; i++) if ("function" == typeof targetSelector || targetSelector === !1) for ("function" == typeof targetSelector && (listener = arguments[1], 
                    capture = arguments[2] || !1), j = 0; j < events.length; j++) this[i].addEventListener(events[j], listener, capture); else for (j = 0; j < events.length; j++) this[i].dom7LiveListeners || (this[i].dom7LiveListeners = []), 
                    this[i].dom7LiveListeners.push({
                        listener: listener,
                        liveListener: handleLiveEvent
                    }), this[i].addEventListener(events[j], handleLiveEvent, capture);
                    return this;
                },
                off: function(eventName, targetSelector, listener, capture) {
                    for (var events = eventName.split(" "), i = 0; i < events.length; i++) for (var j = 0; j < this.length; j++) if ("function" == typeof targetSelector || targetSelector === !1) "function" == typeof targetSelector && (listener = arguments[1], 
                    capture = arguments[2] || !1), this[j].removeEventListener(events[i], listener, capture); else if (this[j].dom7LiveListeners) for (var k = 0; k < this[j].dom7LiveListeners.length; k++) this[j].dom7LiveListeners[k].listener === listener && this[j].removeEventListener(events[i], this[j].dom7LiveListeners[k].liveListener, capture);
                    return this;
                },
                once: function(eventName, targetSelector, listener, capture) {
                    function proxy(e) {
                        listener(e), dom.off(eventName, targetSelector, proxy, capture);
                    }
                    var dom = this;
                    "function" == typeof targetSelector && (targetSelector = !1, listener = arguments[1], 
                    capture = arguments[2]), dom.on(eventName, targetSelector, proxy, capture);
                },
                trigger: function(eventName, eventData) {
                    for (var i = 0; i < this.length; i++) {
                        var evt;
                        try {
                            evt = new window.CustomEvent(eventName, {
                                detail: eventData,
                                bubbles: !0,
                                cancelable: !0
                            });
                        } catch (e) {
                            evt = document.createEvent("Event"), evt.initEvent(eventName, !0, !0), evt.detail = eventData;
                        }
                        this[i].dispatchEvent(evt);
                    }
                    return this;
                },
                transitionEnd: function(callback) {
                    function fireCallBack(e) {
                        if (e.target === this) for (callback.call(this, e), i = 0; i < events.length; i++) dom.off(events[i], fireCallBack);
                    }
                    var i, events = [ "webkitTransitionEnd", "transitionend", "oTransitionEnd", "MSTransitionEnd", "msTransitionEnd" ], dom = this;
                    if (callback) for (i = 0; i < events.length; i++) dom.on(events[i], fireCallBack);
                    return this;
                },
                width: function() {
                    return this[0] === window ? window.innerWidth : this.length > 0 ? parseFloat(this.css("width")) : null;
                },
                outerWidth: function(includeMargins) {
                    return this.length > 0 ? includeMargins ? this[0].offsetWidth + parseFloat(this.css("margin-right")) + parseFloat(this.css("margin-left")) : this[0].offsetWidth : null;
                },
                height: function() {
                    return this[0] === window ? window.innerHeight : this.length > 0 ? parseFloat(this.css("height")) : null;
                },
                outerHeight: function(includeMargins) {
                    return this.length > 0 ? includeMargins ? this[0].offsetHeight + parseFloat(this.css("margin-top")) + parseFloat(this.css("margin-bottom")) : this[0].offsetHeight : null;
                },
                offset: function() {
                    if (this.length > 0) {
                        var el = this[0], box = el.getBoundingClientRect(), body = document.body, clientTop = el.clientTop || body.clientTop || 0, clientLeft = el.clientLeft || body.clientLeft || 0, scrollTop = window.pageYOffset || el.scrollTop, scrollLeft = window.pageXOffset || el.scrollLeft;
                        return {
                            top: box.top + scrollTop - clientTop,
                            left: box.left + scrollLeft - clientLeft
                        };
                    }
                    return null;
                },
                css: function(props, value) {
                    var i;
                    if (1 === arguments.length) {
                        if ("string" != typeof props) {
                            for (i = 0; i < this.length; i++) for (var prop in props) this[i].style[prop] = props[prop];
                            return this;
                        }
                        if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
                    }
                    if (2 === arguments.length && "string" == typeof props) {
                        for (i = 0; i < this.length; i++) this[i].style[props] = value;
                        return this;
                    }
                    return this;
                },
                each: function(callback) {
                    for (var i = 0; i < this.length; i++) callback.call(this[i], i, this[i]);
                    return this;
                },
                html: function(html) {
                    if ("undefined" == typeof html) return this[0] ? this[0].innerHTML : void 0;
                    for (var i = 0; i < this.length; i++) this[i].innerHTML = html;
                    return this;
                },
                is: function(selector) {
                    if (!this[0]) return !1;
                    var compareWith, i;
                    if ("string" == typeof selector) {
                        var el = this[0];
                        if (el === document) return selector === document;
                        if (el === window) return selector === window;
                        if (el.matches) return el.matches(selector);
                        if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
                        if (el.mozMatchesSelector) return el.mozMatchesSelector(selector);
                        if (el.msMatchesSelector) return el.msMatchesSelector(selector);
                        for (compareWith = $(selector), i = 0; i < compareWith.length; i++) if (compareWith[i] === this[0]) return !0;
                        return !1;
                    }
                    if (selector === document) return this[0] === document;
                    if (selector === window) return this[0] === window;
                    if (selector.nodeType || selector instanceof Dom7) {
                        for (compareWith = selector.nodeType ? [ selector ] : selector, i = 0; i < compareWith.length; i++) if (compareWith[i] === this[0]) return !0;
                        return !1;
                    }
                    return !1;
                },
                index: function() {
                    if (this[0]) {
                        for (var child = this[0], i = 0; null !== (child = child.previousSibling); ) 1 === child.nodeType && i++;
                        return i;
                    }
                    return void 0;
                },
                eq: function(index) {
                    if ("undefined" == typeof index) return this;
                    var returnIndex, length = this.length;
                    return index > length - 1 ? new Dom7([]) : 0 > index ? (returnIndex = length + index, 
                    new Dom7(0 > returnIndex ? [] : [ this[returnIndex] ])) : new Dom7([ this[index] ]);
                },
                append: function(newChild) {
                    var i, j;
                    for (i = 0; i < this.length; i++) if ("string" == typeof newChild) {
                        var tempDiv = document.createElement("div");
                        for (tempDiv.innerHTML = newChild; tempDiv.firstChild; ) this[i].appendChild(tempDiv.firstChild);
                    } else if (newChild instanceof Dom7) for (j = 0; j < newChild.length; j++) this[i].appendChild(newChild[j]); else this[i].appendChild(newChild);
                    return this;
                },
                prepend: function(newChild) {
                    var i, j;
                    for (i = 0; i < this.length; i++) if ("string" == typeof newChild) {
                        var tempDiv = document.createElement("div");
                        for (tempDiv.innerHTML = newChild, j = tempDiv.childNodes.length - 1; j >= 0; j--) this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
                    } else if (newChild instanceof Dom7) for (j = 0; j < newChild.length; j++) this[i].insertBefore(newChild[j], this[i].childNodes[0]); else this[i].insertBefore(newChild, this[i].childNodes[0]);
                    return this;
                },
                insertBefore: function(selector) {
                    for (var before = $(selector), i = 0; i < this.length; i++) if (1 === before.length) before[0].parentNode.insertBefore(this[i], before[0]); else if (before.length > 1) for (var j = 0; j < before.length; j++) before[j].parentNode.insertBefore(this[i].cloneNode(!0), before[j]);
                },
                insertAfter: function(selector) {
                    for (var after = $(selector), i = 0; i < this.length; i++) if (1 === after.length) after[0].parentNode.insertBefore(this[i], after[0].nextSibling); else if (after.length > 1) for (var j = 0; j < after.length; j++) after[j].parentNode.insertBefore(this[i].cloneNode(!0), after[j].nextSibling);
                },
                next: function(selector) {
                    return new Dom7(this.length > 0 ? selector ? this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector) ? [ this[0].nextElementSibling ] : [] : this[0].nextElementSibling ? [ this[0].nextElementSibling ] : [] : []);
                },
                nextAll: function(selector) {
                    var nextEls = [], el = this[0];
                    if (!el) return new Dom7([]);
                    for (;el.nextElementSibling; ) {
                        var next = el.nextElementSibling;
                        selector ? $(next).is(selector) && nextEls.push(next) : nextEls.push(next), el = next;
                    }
                    return new Dom7(nextEls);
                },
                prev: function(selector) {
                    return new Dom7(this.length > 0 ? selector ? this[0].previousElementSibling && $(this[0].previousElementSibling).is(selector) ? [ this[0].previousElementSibling ] : [] : this[0].previousElementSibling ? [ this[0].previousElementSibling ] : [] : []);
                },
                prevAll: function(selector) {
                    var prevEls = [], el = this[0];
                    if (!el) return new Dom7([]);
                    for (;el.previousElementSibling; ) {
                        var prev = el.previousElementSibling;
                        selector ? $(prev).is(selector) && prevEls.push(prev) : prevEls.push(prev), el = prev;
                    }
                    return new Dom7(prevEls);
                },
                parent: function(selector) {
                    for (var parents = [], i = 0; i < this.length; i++) selector ? $(this[i].parentNode).is(selector) && parents.push(this[i].parentNode) : parents.push(this[i].parentNode);
                    return $($.unique(parents));
                },
                parents: function(selector) {
                    for (var parents = [], i = 0; i < this.length; i++) for (var parent = this[i].parentNode; parent; ) selector ? $(parent).is(selector) && parents.push(parent) : parents.push(parent), 
                    parent = parent.parentNode;
                    return $($.unique(parents));
                },
                find: function(selector) {
                    for (var foundElements = [], i = 0; i < this.length; i++) for (var found = this[i].querySelectorAll(selector), j = 0; j < found.length; j++) foundElements.push(found[j]);
                    return new Dom7(foundElements);
                },
                children: function(selector) {
                    for (var children = [], i = 0; i < this.length; i++) for (var childNodes = this[i].childNodes, j = 0; j < childNodes.length; j++) selector ? 1 === childNodes[j].nodeType && $(childNodes[j]).is(selector) && children.push(childNodes[j]) : 1 === childNodes[j].nodeType && children.push(childNodes[j]);
                    return new Dom7($.unique(children));
                },
                remove: function() {
                    for (var i = 0; i < this.length; i++) this[i].parentNode && this[i].parentNode.removeChild(this[i]);
                    return this;
                },
                add: function() {
                    var i, j, dom = this;
                    for (i = 0; i < arguments.length; i++) {
                        var toAdd = $(arguments[i]);
                        for (j = 0; j < toAdd.length; j++) dom[dom.length] = toAdd[j], dom.length++;
                    }
                    return dom;
                }
            }, $.fn = Dom7.prototype, $.unique = function(arr) {
                for (var unique = [], i = 0; i < arr.length; i++) -1 === unique.indexOf(arr[i]) && unique.push(arr[i]);
                return unique;
            }, $;
        }()), swiperDomPlugins = [ "jQuery", "Zepto", "Dom7" ], i = 0; i < swiperDomPlugins.length; i++) window[swiperDomPlugins[i]] && addLibraryPlugin(window[swiperDomPlugins[i]]);
        var domLib;
        domLib = "undefined" == typeof Dom7 ? window.Dom7 || window.Zepto || window.jQuery : Dom7, 
        domLib && ("transitionEnd" in domLib.fn || (domLib.fn.transitionEnd = function(callback) {
            function fireCallBack(e) {
                if (e.target === this) for (callback.call(this, e), i = 0; i < events.length; i++) dom.off(events[i], fireCallBack);
            }
            var i, events = [ "webkitTransitionEnd", "transitionend", "oTransitionEnd", "MSTransitionEnd", "msTransitionEnd" ], dom = this;
            if (callback) for (i = 0; i < events.length; i++) dom.on(events[i], fireCallBack);
            return this;
        }), "transform" in domLib.fn || (domLib.fn.transform = function(transform) {
            for (var i = 0; i < this.length; i++) {
                var elStyle = this[i].style;
                elStyle.webkitTransform = elStyle.MsTransform = elStyle.msTransform = elStyle.MozTransform = elStyle.OTransform = elStyle.transform = transform;
            }
            return this;
        }), "transition" in domLib.fn || (domLib.fn.transition = function(duration) {
            "string" != typeof duration && (duration += "ms");
            for (var i = 0; i < this.length; i++) {
                var elStyle = this[i].style;
                elStyle.webkitTransitionDuration = elStyle.MsTransitionDuration = elStyle.msTransitionDuration = elStyle.MozTransitionDuration = elStyle.OTransitionDuration = elStyle.transitionDuration = duration;
            }
            return this;
        })), ionic.views.Swiper = Swiper;
    }(), function(ionic) {
        "use strict";
        ionic.views.Toggle = ionic.views.View.inherit({
            initialize: function(opts) {
                var self = this;
                this.el = opts.el, this.checkbox = opts.checkbox, this.track = opts.track, this.handle = opts.handle, 
                this.openPercent = -1, this.onChange = opts.onChange || function() {}, this.triggerThreshold = opts.triggerThreshold || 20, 
                this.dragStartHandler = function(e) {
                    self.dragStart(e);
                }, this.dragHandler = function(e) {
                    self.drag(e);
                }, this.holdHandler = function(e) {
                    self.hold(e);
                }, this.releaseHandler = function(e) {
                    self.release(e);
                }, this.dragStartGesture = ionic.onGesture("dragstart", this.dragStartHandler, this.el), 
                this.dragGesture = ionic.onGesture("drag", this.dragHandler, this.el), this.dragHoldGesture = ionic.onGesture("hold", this.holdHandler, this.el), 
                this.dragReleaseGesture = ionic.onGesture("release", this.releaseHandler, this.el);
            },
            destroy: function() {
                ionic.offGesture(this.dragStartGesture, "dragstart", this.dragStartGesture), ionic.offGesture(this.dragGesture, "drag", this.dragGesture), 
                ionic.offGesture(this.dragHoldGesture, "hold", this.holdHandler), ionic.offGesture(this.dragReleaseGesture, "release", this.releaseHandler);
            },
            tap: function() {
                "disabled" !== this.el.getAttribute("disabled") && this.val(!this.checkbox.checked);
            },
            dragStart: function(e) {
                this.checkbox.disabled || (this._dragInfo = {
                    width: this.el.offsetWidth,
                    left: this.el.offsetLeft,
                    right: this.el.offsetLeft + this.el.offsetWidth,
                    triggerX: this.el.offsetWidth / 2,
                    initialState: this.checkbox.checked
                }, e.gesture.srcEvent.preventDefault(), this.hold(e));
            },
            drag: function(e) {
                var self = this;
                this._dragInfo && (e.gesture.srcEvent.preventDefault(), ionic.requestAnimationFrame(function() {
                    if (self._dragInfo) {
                        var px = e.gesture.touches[0].pageX - self._dragInfo.left, mx = self._dragInfo.width - self.triggerThreshold;
                        self._dragInfo.initialState ? px < self.triggerThreshold ? self.setOpenPercent(0) : px > self._dragInfo.triggerX && self.setOpenPercent(100) : px < self._dragInfo.triggerX ? self.setOpenPercent(0) : px > mx && self.setOpenPercent(100);
                    }
                }));
            },
            endDrag: function() {
                this._dragInfo = null;
            },
            hold: function() {
                this.el.classList.add("dragging");
            },
            release: function(e) {
                this.el.classList.remove("dragging"), this.endDrag(e);
            },
            setOpenPercent: function(openPercent) {
                if (this.openPercent < 0 || openPercent < this.openPercent - 3 || openPercent > this.openPercent + 3) if (this.openPercent = openPercent, 
                0 === openPercent) this.val(!1); else if (100 === openPercent) this.val(!0); else {
                    var openPixel = Math.round(openPercent / 100 * this.track.offsetWidth - this.handle.offsetWidth);
                    openPixel = 1 > openPixel ? 0 : openPixel, this.handle.style[ionic.CSS.TRANSFORM] = "translate3d(" + openPixel + "px,0,0)";
                }
            },
            val: function(value) {
                return (value === !0 || value === !1) && ("" !== this.handle.style[ionic.CSS.TRANSFORM] && (this.handle.style[ionic.CSS.TRANSFORM] = ""), 
                this.checkbox.checked = value, this.openPercent = value ? 100 : 0, this.onChange && this.onChange()), 
                this.checkbox.checked;
            }
        });
    }(ionic);
}(), function(window, document, undefined) {
    "use strict";
    function minErr(module, ErrorConstructor) {
        return ErrorConstructor = ErrorConstructor || Error, function() {
            var paramPrefix, i, SKIP_INDEXES = 2, templateArgs = arguments, code = templateArgs[0], message = "[" + (module ? module + ":" : "") + code + "] ", template = templateArgs[1];
            for (message += template.replace(/\{\d+\}/g, function(match) {
                var index = +match.slice(1, -1), shiftedIndex = index + SKIP_INDEXES;
                return shiftedIndex < templateArgs.length ? toDebugString(templateArgs[shiftedIndex]) : match;
            }), message += "\nhttp://errors.angularjs.org/1.4.3/" + (module ? module + "/" : "") + code, 
            i = SKIP_INDEXES, paramPrefix = "?"; i < templateArgs.length; i++, paramPrefix = "&") message += paramPrefix + "p" + (i - SKIP_INDEXES) + "=" + encodeURIComponent(toDebugString(templateArgs[i]));
            return new ErrorConstructor(message);
        };
    }
    function isArrayLike(obj) {
        if (null == obj || isWindow(obj)) return !1;
        var length = "length" in Object(obj) && obj.length;
        return obj.nodeType === NODE_TYPE_ELEMENT && length ? !0 : isString(obj) || isArray(obj) || 0 === length || "number" == typeof length && length > 0 && length - 1 in obj;
    }
    function forEach(obj, iterator, context) {
        var key, length;
        if (obj) if (isFunction(obj)) for (key in obj) "prototype" == key || "length" == key || "name" == key || obj.hasOwnProperty && !obj.hasOwnProperty(key) || iterator.call(context, obj[key], key, obj); else if (isArray(obj) || isArrayLike(obj)) {
            var isPrimitive = "object" != typeof obj;
            for (key = 0, length = obj.length; length > key; key++) (isPrimitive || key in obj) && iterator.call(context, obj[key], key, obj);
        } else if (obj.forEach && obj.forEach !== forEach) obj.forEach(iterator, context, obj); else if (isBlankObject(obj)) for (key in obj) iterator.call(context, obj[key], key, obj); else if ("function" == typeof obj.hasOwnProperty) for (key in obj) obj.hasOwnProperty(key) && iterator.call(context, obj[key], key, obj); else for (key in obj) hasOwnProperty.call(obj, key) && iterator.call(context, obj[key], key, obj);
        return obj;
    }
    function forEachSorted(obj, iterator, context) {
        for (var keys = Object.keys(obj).sort(), i = 0; i < keys.length; i++) iterator.call(context, obj[keys[i]], keys[i]);
        return keys;
    }
    function reverseParams(iteratorFn) {
        return function(value, key) {
            iteratorFn(key, value);
        };
    }
    function nextUid() {
        return ++uid;
    }
    function setHashKey(obj, h) {
        h ? obj.$$hashKey = h : delete obj.$$hashKey;
    }
    function baseExtend(dst, objs, deep) {
        for (var h = dst.$$hashKey, i = 0, ii = objs.length; ii > i; ++i) {
            var obj = objs[i];
            if (isObject(obj) || isFunction(obj)) for (var keys = Object.keys(obj), j = 0, jj = keys.length; jj > j; j++) {
                var key = keys[j], src = obj[key];
                deep && isObject(src) ? isDate(src) ? dst[key] = new Date(src.valueOf()) : (isObject(dst[key]) || (dst[key] = isArray(src) ? [] : {}), 
                baseExtend(dst[key], [ src ], !0)) : dst[key] = src;
            }
        }
        return setHashKey(dst, h), dst;
    }
    function extend(dst) {
        return baseExtend(dst, slice.call(arguments, 1), !1);
    }
    function merge(dst) {
        return baseExtend(dst, slice.call(arguments, 1), !0);
    }
    function toInt(str) {
        return parseInt(str, 10);
    }
    function inherit(parent, extra) {
        return extend(Object.create(parent), extra);
    }
    function noop() {}
    function identity($) {
        return $;
    }
    function valueFn(value) {
        return function() {
            return value;
        };
    }
    function hasCustomToString(obj) {
        return isFunction(obj.toString) && obj.toString !== Object.prototype.toString;
    }
    function isUndefined(value) {
        return "undefined" == typeof value;
    }
    function isDefined(value) {
        return "undefined" != typeof value;
    }
    function isObject(value) {
        return null !== value && "object" == typeof value;
    }
    function isBlankObject(value) {
        return null !== value && "object" == typeof value && !getPrototypeOf(value);
    }
    function isString(value) {
        return "string" == typeof value;
    }
    function isNumber(value) {
        return "number" == typeof value;
    }
    function isDate(value) {
        return "[object Date]" === toString.call(value);
    }
    function isFunction(value) {
        return "function" == typeof value;
    }
    function isRegExp(value) {
        return "[object RegExp]" === toString.call(value);
    }
    function isWindow(obj) {
        return obj && obj.window === obj;
    }
    function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
    }
    function isFile(obj) {
        return "[object File]" === toString.call(obj);
    }
    function isFormData(obj) {
        return "[object FormData]" === toString.call(obj);
    }
    function isBlob(obj) {
        return "[object Blob]" === toString.call(obj);
    }
    function isBoolean(value) {
        return "boolean" == typeof value;
    }
    function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
    }
    function isTypedArray(value) {
        return TYPED_ARRAY_REGEXP.test(toString.call(value));
    }
    function isElement(node) {
        return !(!node || !(node.nodeName || node.prop && node.attr && node.find));
    }
    function makeMap(str) {
        var i, obj = {}, items = str.split(",");
        for (i = 0; i < items.length; i++) obj[items[i]] = !0;
        return obj;
    }
    function nodeName_(element) {
        return lowercase(element.nodeName || element[0] && element[0].nodeName);
    }
    function arrayRemove(array, value) {
        var index = array.indexOf(value);
        return index >= 0 && array.splice(index, 1), index;
    }
    function copy(source, destination, stackSource, stackDest) {
        if (isWindow(source) || isScope(source)) throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.");
        if (isTypedArray(destination)) throw ngMinErr("cpta", "Can't copy! TypedArray destination cannot be mutated.");
        if (destination) {
            if (source === destination) throw ngMinErr("cpi", "Can't copy! Source and destination are identical.");
            stackSource = stackSource || [], stackDest = stackDest || [], isObject(source) && (stackSource.push(source), 
            stackDest.push(destination));
            var key;
            if (isArray(source)) {
                destination.length = 0;
                for (var i = 0; i < source.length; i++) destination.push(copy(source[i], null, stackSource, stackDest));
            } else {
                var h = destination.$$hashKey;
                if (isArray(destination) ? destination.length = 0 : forEach(destination, function(value, key) {
                    delete destination[key];
                }), isBlankObject(source)) for (key in source) destination[key] = copy(source[key], null, stackSource, stackDest); else if (source && "function" == typeof source.hasOwnProperty) for (key in source) source.hasOwnProperty(key) && (destination[key] = copy(source[key], null, stackSource, stackDest)); else for (key in source) hasOwnProperty.call(source, key) && (destination[key] = copy(source[key], null, stackSource, stackDest));
                setHashKey(destination, h);
            }
        } else if (destination = source, isObject(source)) {
            var index;
            if (stackSource && -1 !== (index = stackSource.indexOf(source))) return stackDest[index];
            if (isArray(source)) return copy(source, [], stackSource, stackDest);
            if (isTypedArray(source)) destination = new source.constructor(source); else if (isDate(source)) destination = new Date(source.getTime()); else {
                if (!isRegExp(source)) {
                    var emptyObject = Object.create(getPrototypeOf(source));
                    return copy(source, emptyObject, stackSource, stackDest);
                }
                destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]), 
                destination.lastIndex = source.lastIndex;
            }
            stackDest && (stackSource.push(source), stackDest.push(destination));
        }
        return destination;
    }
    function shallowCopy(src, dst) {
        if (isArray(src)) {
            dst = dst || [];
            for (var i = 0, ii = src.length; ii > i; i++) dst[i] = src[i];
        } else if (isObject(src)) {
            dst = dst || {};
            for (var key in src) ("$" !== key.charAt(0) || "$" !== key.charAt(1)) && (dst[key] = src[key]);
        }
        return dst || src;
    }
    function equals(o1, o2) {
        if (o1 === o2) return !0;
        if (null === o1 || null === o2) return !1;
        if (o1 !== o1 && o2 !== o2) return !0;
        var length, key, keySet, t1 = typeof o1, t2 = typeof o2;
        if (t1 == t2 && "object" == t1) {
            if (!isArray(o1)) {
                if (isDate(o1)) return isDate(o2) ? equals(o1.getTime(), o2.getTime()) : !1;
                if (isRegExp(o1)) return isRegExp(o2) ? o1.toString() == o2.toString() : !1;
                if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2)) return !1;
                keySet = createMap();
                for (key in o1) if ("$" !== key.charAt(0) && !isFunction(o1[key])) {
                    if (!equals(o1[key], o2[key])) return !1;
                    keySet[key] = !0;
                }
                for (key in o2) if (!(key in keySet || "$" === key.charAt(0) || o2[key] === undefined || isFunction(o2[key]))) return !1;
                return !0;
            }
            if (!isArray(o2)) return !1;
            if ((length = o1.length) == o2.length) {
                for (key = 0; length > key; key++) if (!equals(o1[key], o2[key])) return !1;
                return !0;
            }
        }
        return !1;
    }
    function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
    }
    function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
    }
    function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        return !isFunction(fn) || fn instanceof RegExp ? fn : curryArgs.length ? function() {
            return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
        } : function() {
            return arguments.length ? fn.apply(self, arguments) : fn.call(self);
        };
    }
    function toJsonReplacer(key, value) {
        var val = value;
        return "string" == typeof key && "$" === key.charAt(0) && "$" === key.charAt(1) ? val = undefined : isWindow(value) ? val = "$WINDOW" : value && document === value ? val = "$DOCUMENT" : isScope(value) && (val = "$SCOPE"), 
        val;
    }
    function toJson(obj, pretty) {
        return "undefined" == typeof obj ? undefined : (isNumber(pretty) || (pretty = pretty ? 2 : null), 
        JSON.stringify(obj, toJsonReplacer, pretty));
    }
    function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
    }
    function timezoneToOffset(timezone, fallback) {
        var requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
        return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
    }
    function addDateMinutes(date, minutes) {
        return date = new Date(date.getTime()), date.setMinutes(date.getMinutes() + minutes), 
        date;
    }
    function convertTimezoneToLocal(date, timezone, reverse) {
        reverse = reverse ? -1 : 1;
        var timezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
        return addDateMinutes(date, reverse * (timezoneOffset - date.getTimezoneOffset()));
    }
    function startingTag(element) {
        element = jqLite(element).clone();
        try {
            element.empty();
        } catch (e) {}
        var elemHtml = jqLite("<div>").append(element).html();
        try {
            return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(match, nodeName) {
                return "<" + lowercase(nodeName);
            });
        } catch (e) {
            return lowercase(elemHtml);
        }
    }
    function tryDecodeURIComponent(value) {
        try {
            return decodeURIComponent(value);
        } catch (e) {}
    }
    function parseKeyValue(keyValue) {
        var key_value, key, obj = {};
        return forEach((keyValue || "").split("&"), function(keyValue) {
            if (keyValue && (key_value = keyValue.replace(/\+/g, "%20").split("="), key = tryDecodeURIComponent(key_value[0]), 
            isDefined(key))) {
                var val = isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : !0;
                hasOwnProperty.call(obj, key) ? isArray(obj[key]) ? obj[key].push(val) : obj[key] = [ obj[key], val ] : obj[key] = val;
            }
        }), obj;
    }
    function toKeyValue(obj) {
        var parts = [];
        return forEach(obj, function(value, key) {
            isArray(value) ? forEach(value, function(arrayValue) {
                parts.push(encodeUriQuery(key, !0) + (arrayValue === !0 ? "" : "=" + encodeUriQuery(arrayValue, !0)));
            }) : parts.push(encodeUriQuery(key, !0) + (value === !0 ? "" : "=" + encodeUriQuery(value, !0)));
        }), parts.length ? parts.join("&") : "";
    }
    function encodeUriSegment(val) {
        return encodeUriQuery(val, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+");
    }
    function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
    }
    function getNgAttribute(element, ngAttr) {
        var attr, i, ii = ngAttrPrefixes.length;
        for (i = 0; ii > i; ++i) if (attr = ngAttrPrefixes[i] + ngAttr, isString(attr = element.getAttribute(attr))) return attr;
        return null;
    }
    function angularInit(element, bootstrap) {
        var appElement, module, config = {};
        forEach(ngAttrPrefixes, function(prefix) {
            var name = prefix + "app";
            !appElement && element.hasAttribute && element.hasAttribute(name) && (appElement = element, 
            module = element.getAttribute(name));
        }), forEach(ngAttrPrefixes, function(prefix) {
            var candidate, name = prefix + "app";
            !appElement && (candidate = element.querySelector("[" + name.replace(":", "\\:") + "]")) && (appElement = candidate, 
            module = candidate.getAttribute(name));
        }), appElement && (config.strictDi = null !== getNgAttribute(appElement, "strict-di"), 
        bootstrap(appElement, module ? [ module ] : [], config));
    }
    function bootstrap(element, modules, config) {
        isObject(config) || (config = {});
        var defaultConfig = {
            strictDi: !1
        };
        config = extend(defaultConfig, config);
        var doBootstrap = function() {
            if (element = jqLite(element), element.injector()) {
                var tag = element[0] === document ? "document" : startingTag(element);
                throw ngMinErr("btstrpd", "App Already Bootstrapped with this Element '{0}'", tag.replace(/</, "&lt;").replace(/>/, "&gt;"));
            }
            modules = modules || [], modules.unshift([ "$provide", function($provide) {
                $provide.value("$rootElement", element);
            } ]), config.debugInfoEnabled && modules.push([ "$compileProvider", function($compileProvider) {
                $compileProvider.debugInfoEnabled(!0);
            } ]), modules.unshift("ng");
            var injector = createInjector(modules, config.strictDi);
            return injector.invoke([ "$rootScope", "$rootElement", "$compile", "$injector", function(scope, element, compile, injector) {
                scope.$apply(function() {
                    element.data("$injector", injector), compile(element)(scope);
                });
            } ]), injector;
        }, NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/, NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        return window && NG_ENABLE_DEBUG_INFO.test(window.name) && (config.debugInfoEnabled = !0, 
        window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, "")), window && !NG_DEFER_BOOTSTRAP.test(window.name) ? doBootstrap() : (window.name = window.name.replace(NG_DEFER_BOOTSTRAP, ""), 
        angular.resumeBootstrap = function(extraModules) {
            return forEach(extraModules, function(module) {
                modules.push(module);
            }), doBootstrap();
        }, void (isFunction(angular.resumeDeferredBootstrap) && angular.resumeDeferredBootstrap()));
    }
    function reloadWithDebugInfo() {
        window.name = "NG_ENABLE_DEBUG_INFO!" + window.name, window.location.reload();
    }
    function getTestability(rootElement) {
        var injector = angular.element(rootElement).injector();
        if (!injector) throw ngMinErr("test", "no injector found for element argument to getTestability");
        return injector.get("$$testability");
    }
    function snake_case(name, separator) {
        return separator = separator || "_", name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase();
        });
    }
    function bindJQuery() {
        var originalCleanData;
        if (!bindJQueryFired) {
            var jqName = jq();
            jQuery = window.jQuery, isDefined(jqName) && (jQuery = null === jqName ? undefined : window[jqName]), 
            jQuery && jQuery.fn.on ? (jqLite = jQuery, extend(jQuery.fn, {
                scope: JQLitePrototype.scope,
                isolateScope: JQLitePrototype.isolateScope,
                controller: JQLitePrototype.controller,
                injector: JQLitePrototype.injector,
                inheritedData: JQLitePrototype.inheritedData
            }), originalCleanData = jQuery.cleanData, jQuery.cleanData = function(elems) {
                var events;
                if (skipDestroyOnNextJQueryCleanData) skipDestroyOnNextJQueryCleanData = !1; else for (var elem, i = 0; null != (elem = elems[i]); i++) events = jQuery._data(elem, "events"), 
                events && events.$destroy && jQuery(elem).triggerHandler("$destroy");
                originalCleanData(elems);
            }) : jqLite = JQLite, angular.element = jqLite, bindJQueryFired = !0;
        }
    }
    function assertArg(arg, name, reason) {
        if (!arg) throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
        return arg;
    }
    function assertArgFn(arg, name, acceptArrayAnnotation) {
        return acceptArrayAnnotation && isArray(arg) && (arg = arg[arg.length - 1]), assertArg(isFunction(arg), name, "not a function, got " + (arg && "object" == typeof arg ? arg.constructor.name || "Object" : typeof arg)), 
        arg;
    }
    function assertNotHasOwnProperty(name, context) {
        if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
    }
    function getter(obj, path, bindFnToScope) {
        if (!path) return obj;
        for (var key, keys = path.split("."), lastInstance = obj, len = keys.length, i = 0; len > i; i++) key = keys[i], 
        obj && (obj = (lastInstance = obj)[key]);
        return !bindFnToScope && isFunction(obj) ? bind(lastInstance, obj) : obj;
    }
    function getBlockNodes(nodes) {
        var node = nodes[0], endNode = nodes[nodes.length - 1], blockNodes = [ node ];
        do {
            if (node = node.nextSibling, !node) break;
            blockNodes.push(node);
        } while (node !== endNode);
        return jqLite(blockNodes);
    }
    function createMap() {
        return Object.create(null);
    }
    function setupModuleLoader(window) {
        function ensure(obj, name, factory) {
            return obj[name] || (obj[name] = factory());
        }
        var $injectorMinErr = minErr("$injector"), ngMinErr = minErr("ng"), angular = ensure(window, "angular", Object);
        return angular.$$minErr = angular.$$minErr || minErr, ensure(angular, "module", function() {
            var modules = {};
            return function(name, requires, configFn) {
                var assertNotHasOwnProperty = function(name, context) {
                    if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
                };
                return assertNotHasOwnProperty(name, "module"), requires && modules.hasOwnProperty(name) && (modules[name] = null), 
                ensure(modules, name, function() {
                    function invokeLater(provider, method, insertMethod, queue) {
                        return queue || (queue = invokeQueue), function() {
                            return queue[insertMethod || "push"]([ provider, method, arguments ]), moduleInstance;
                        };
                    }
                    function invokeLaterAndSetModuleName(provider, method) {
                        return function(recipeName, factoryFunction) {
                            return factoryFunction && isFunction(factoryFunction) && (factoryFunction.$$moduleName = name), 
                            invokeQueue.push([ provider, method, arguments ]), moduleInstance;
                        };
                    }
                    if (!requires) throw $injectorMinErr("nomod", "Module '{0}' is not available! You either misspelled the module name or forgot to load it. If registering a module ensure that you specify the dependencies as the second argument.", name);
                    var invokeQueue = [], configBlocks = [], runBlocks = [], config = invokeLater("$injector", "invoke", "push", configBlocks), moduleInstance = {
                        _invokeQueue: invokeQueue,
                        _configBlocks: configBlocks,
                        _runBlocks: runBlocks,
                        requires: requires,
                        name: name,
                        provider: invokeLaterAndSetModuleName("$provide", "provider"),
                        factory: invokeLaterAndSetModuleName("$provide", "factory"),
                        service: invokeLaterAndSetModuleName("$provide", "service"),
                        value: invokeLater("$provide", "value"),
                        constant: invokeLater("$provide", "constant", "unshift"),
                        decorator: invokeLaterAndSetModuleName("$provide", "decorator"),
                        animation: invokeLaterAndSetModuleName("$animateProvider", "register"),
                        filter: invokeLaterAndSetModuleName("$filterProvider", "register"),
                        controller: invokeLaterAndSetModuleName("$controllerProvider", "register"),
                        directive: invokeLaterAndSetModuleName("$compileProvider", "directive"),
                        config: config,
                        run: function(block) {
                            return runBlocks.push(block), this;
                        }
                    };
                    return configFn && config(configFn), moduleInstance;
                });
            };
        });
    }
    function serializeObject(obj) {
        var seen = [];
        return JSON.stringify(obj, function(key, val) {
            if (val = toJsonReplacer(key, val), isObject(val)) {
                if (seen.indexOf(val) >= 0) return "<<already seen>>";
                seen.push(val);
            }
            return val;
        });
    }
    function toDebugString(obj) {
        return "function" == typeof obj ? obj.toString().replace(/ \{[\s\S]*$/, "") : "undefined" == typeof obj ? "undefined" : "string" != typeof obj ? serializeObject(obj) : obj;
    }
    function publishExternalAPI(angular) {
        extend(angular, {
            bootstrap: bootstrap,
            copy: copy,
            extend: extend,
            merge: merge,
            equals: equals,
            element: jqLite,
            forEach: forEach,
            injector: createInjector,
            noop: noop,
            bind: bind,
            toJson: toJson,
            fromJson: fromJson,
            identity: identity,
            isUndefined: isUndefined,
            isDefined: isDefined,
            isString: isString,
            isFunction: isFunction,
            isObject: isObject,
            isNumber: isNumber,
            isElement: isElement,
            isArray: isArray,
            version: version,
            isDate: isDate,
            lowercase: lowercase,
            uppercase: uppercase,
            callbacks: {
                counter: 0
            },
            getTestability: getTestability,
            $$minErr: minErr,
            $$csp: csp,
            reloadWithDebugInfo: reloadWithDebugInfo
        }), angularModule = setupModuleLoader(window);
        try {
            angularModule("ngLocale");
        } catch (e) {
            angularModule("ngLocale", []).provider("$locale", $LocaleProvider);
        }
        angularModule("ng", [ "ngLocale" ], [ "$provide", function($provide) {
            $provide.provider({
                $$sanitizeUri: $$SanitizeUriProvider
            }), $provide.provider("$compile", $CompileProvider).directive({
                a: htmlAnchorDirective,
                input: inputDirective,
                textarea: inputDirective,
                form: formDirective,
                script: scriptDirective,
                select: selectDirective,
                style: styleDirective,
                option: optionDirective,
                ngBind: ngBindDirective,
                ngBindHtml: ngBindHtmlDirective,
                ngBindTemplate: ngBindTemplateDirective,
                ngClass: ngClassDirective,
                ngClassEven: ngClassEvenDirective,
                ngClassOdd: ngClassOddDirective,
                ngCloak: ngCloakDirective,
                ngController: ngControllerDirective,
                ngForm: ngFormDirective,
                ngHide: ngHideDirective,
                ngIf: ngIfDirective,
                ngInclude: ngIncludeDirective,
                ngInit: ngInitDirective,
                ngNonBindable: ngNonBindableDirective,
                ngPluralize: ngPluralizeDirective,
                ngRepeat: ngRepeatDirective,
                ngShow: ngShowDirective,
                ngStyle: ngStyleDirective,
                ngSwitch: ngSwitchDirective,
                ngSwitchWhen: ngSwitchWhenDirective,
                ngSwitchDefault: ngSwitchDefaultDirective,
                ngOptions: ngOptionsDirective,
                ngTransclude: ngTranscludeDirective,
                ngModel: ngModelDirective,
                ngList: ngListDirective,
                ngChange: ngChangeDirective,
                pattern: patternDirective,
                ngPattern: patternDirective,
                required: requiredDirective,
                ngRequired: requiredDirective,
                minlength: minlengthDirective,
                ngMinlength: minlengthDirective,
                maxlength: maxlengthDirective,
                ngMaxlength: maxlengthDirective,
                ngValue: ngValueDirective,
                ngModelOptions: ngModelOptionsDirective
            }).directive({
                ngInclude: ngIncludeFillContentDirective
            }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives), $provide.provider({
                $anchorScroll: $AnchorScrollProvider,
                $animate: $AnimateProvider,
                $$animateQueue: $$CoreAnimateQueueProvider,
                $$AnimateRunner: $$CoreAnimateRunnerProvider,
                $browser: $BrowserProvider,
                $cacheFactory: $CacheFactoryProvider,
                $controller: $ControllerProvider,
                $document: $DocumentProvider,
                $exceptionHandler: $ExceptionHandlerProvider,
                $filter: $FilterProvider,
                $interpolate: $InterpolateProvider,
                $interval: $IntervalProvider,
                $http: $HttpProvider,
                $httpParamSerializer: $HttpParamSerializerProvider,
                $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
                $httpBackend: $HttpBackendProvider,
                $location: $LocationProvider,
                $log: $LogProvider,
                $parse: $ParseProvider,
                $rootScope: $RootScopeProvider,
                $q: $QProvider,
                $$q: $$QProvider,
                $sce: $SceProvider,
                $sceDelegate: $SceDelegateProvider,
                $sniffer: $SnifferProvider,
                $templateCache: $TemplateCacheProvider,
                $templateRequest: $TemplateRequestProvider,
                $$testability: $$TestabilityProvider,
                $timeout: $TimeoutProvider,
                $window: $WindowProvider,
                $$rAF: $$RAFProvider,
                $$jqLite: $$jqLiteProvider,
                $$HashMap: $$HashMapProvider,
                $$cookieReader: $$CookieReaderProvider
            });
        } ]);
    }
    function jqNextId() {
        return ++jqId;
    }
    function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
            return offset ? letter.toUpperCase() : letter;
        }).replace(MOZ_HACK_REGEXP, "Moz$1");
    }
    function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
    }
    function jqLiteAcceptsData(node) {
        var nodeType = node.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
    }
    function jqLiteHasData(node) {
        for (var key in jqCache[node.ng339]) return !0;
        return !1;
    }
    function jqLiteBuildFragment(html, context) {
        var tmp, tag, wrap, i, fragment = context.createDocumentFragment(), nodes = [];
        if (jqLiteIsTextNode(html)) nodes.push(context.createTextNode(html)); else {
            for (tmp = tmp || fragment.appendChild(context.createElement("div")), tag = (TAG_NAME_REGEXP.exec(html) || [ "", "" ])[1].toLowerCase(), 
            wrap = wrapMap[tag] || wrapMap._default, tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2], 
            i = wrap[0]; i--; ) tmp = tmp.lastChild;
            nodes = concat(nodes, tmp.childNodes), tmp = fragment.firstChild, tmp.textContent = "";
        }
        return fragment.textContent = "", fragment.innerHTML = "", forEach(nodes, function(node) {
            fragment.appendChild(node);
        }), fragment;
    }
    function jqLiteParseHTML(html, context) {
        context = context || document;
        var parsed;
        return (parsed = SINGLE_TAG_REGEXP.exec(html)) ? [ context.createElement(parsed[1]) ] : (parsed = jqLiteBuildFragment(html, context)) ? parsed.childNodes : [];
    }
    function JQLite(element) {
        if (element instanceof JQLite) return element;
        var argIsString;
        if (isString(element) && (element = trim(element), argIsString = !0), !(this instanceof JQLite)) {
            if (argIsString && "<" != element.charAt(0)) throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element");
            return new JQLite(element);
        }
        argIsString ? jqLiteAddNodes(this, jqLiteParseHTML(element)) : jqLiteAddNodes(this, element);
    }
    function jqLiteClone(element) {
        return element.cloneNode(!0);
    }
    function jqLiteDealoc(element, onlyDescendants) {
        if (onlyDescendants || jqLiteRemoveData(element), element.querySelectorAll) for (var descendants = element.querySelectorAll("*"), i = 0, l = descendants.length; l > i; i++) jqLiteRemoveData(descendants[i]);
    }
    function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported)) throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument");
        var expandoStore = jqLiteExpandoStore(element), events = expandoStore && expandoStore.events, handle = expandoStore && expandoStore.handle;
        if (handle) if (type) forEach(type.split(" "), function(type) {
            if (isDefined(fn)) {
                var listenerFns = events[type];
                if (arrayRemove(listenerFns || [], fn), listenerFns && listenerFns.length > 0) return;
            }
            removeEventListenerFn(element, type, handle), delete events[type];
        }); else for (type in events) "$destroy" !== type && removeEventListenerFn(element, type, handle), 
        delete events[type];
    }
    function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
        if (expandoStore) {
            if (name) return void delete expandoStore.data[name];
            expandoStore.handle && (expandoStore.events.$destroy && expandoStore.handle({}, "$destroy"), 
            jqLiteOff(element)), delete jqCache[expandoId], element.ng339 = undefined;
        }
    }
    function jqLiteExpandoStore(element, createIfNecessary) {
        var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
        return createIfNecessary && !expandoStore && (element.ng339 = expandoId = jqNextId(), 
        expandoStore = jqCache[expandoId] = {
            events: {},
            data: {},
            handle: undefined
        }), expandoStore;
    }
    function jqLiteData(element, key, value) {
        if (jqLiteAcceptsData(element)) {
            var isSimpleSetter = isDefined(value), isSimpleGetter = !isSimpleSetter && key && !isObject(key), massGetter = !key, expandoStore = jqLiteExpandoStore(element, !isSimpleGetter), data = expandoStore && expandoStore.data;
            if (isSimpleSetter) data[key] = value; else {
                if (massGetter) return data;
                if (isSimpleGetter) return data && data[key];
                extend(data, key);
            }
        }
    }
    function jqLiteHasClass(element, selector) {
        return element.getAttribute ? (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1 : !1;
    }
    function jqLiteRemoveClass(element, cssClasses) {
        cssClasses && element.setAttribute && forEach(cssClasses.split(" "), function(cssClass) {
            element.setAttribute("class", trim((" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
        });
    }
    function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
            var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
            forEach(cssClasses.split(" "), function(cssClass) {
                cssClass = trim(cssClass), -1 === existingClasses.indexOf(" " + cssClass + " ") && (existingClasses += cssClass + " ");
            }), element.setAttribute("class", trim(existingClasses));
        }
    }
    function jqLiteAddNodes(root, elements) {
        if (elements) if (elements.nodeType) root[root.length++] = elements; else {
            var length = elements.length;
            if ("number" == typeof length && elements.window !== elements) {
                if (length) for (var i = 0; length > i; i++) root[root.length++] = elements[i];
            } else root[root.length++] = elements;
        }
    }
    function jqLiteController(element, name) {
        return jqLiteInheritedData(element, "$" + (name || "ngController") + "Controller");
    }
    function jqLiteInheritedData(element, name, value) {
        element.nodeType == NODE_TYPE_DOCUMENT && (element = element.documentElement);
        for (var names = isArray(name) ? name : [ name ]; element; ) {
            for (var i = 0, ii = names.length; ii > i; i++) if ((value = jqLite.data(element, names[i])) !== undefined) return value;
            element = element.parentNode || element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host;
        }
    }
    function jqLiteEmpty(element) {
        for (jqLiteDealoc(element, !0); element.firstChild; ) element.removeChild(element.firstChild);
    }
    function jqLiteRemove(element, keepData) {
        keepData || jqLiteDealoc(element);
        var parent = element.parentNode;
        parent && parent.removeChild(element);
    }
    function jqLiteDocumentLoaded(action, win) {
        win = win || window, "complete" === win.document.readyState ? win.setTimeout(action) : jqLite(win).on("load", action);
    }
    function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
    }
    function getAliasedAttrName(element, name) {
        var nodeName = element.nodeName;
        return ("INPUT" === nodeName || "TEXTAREA" === nodeName) && ALIASED_ATTR[name];
    }
    function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
            event.isDefaultPrevented = function() {
                return event.defaultPrevented;
            };
            var eventFns = events[type || event.type], eventFnsLength = eventFns ? eventFns.length : 0;
            if (eventFnsLength) {
                if (isUndefined(event.immediatePropagationStopped)) {
                    var originalStopImmediatePropagation = event.stopImmediatePropagation;
                    event.stopImmediatePropagation = function() {
                        event.immediatePropagationStopped = !0, event.stopPropagation && event.stopPropagation(), 
                        originalStopImmediatePropagation && originalStopImmediatePropagation.call(event);
                    };
                }
                event.isImmediatePropagationStopped = function() {
                    return event.immediatePropagationStopped === !0;
                }, eventFnsLength > 1 && (eventFns = shallowCopy(eventFns));
                for (var i = 0; eventFnsLength > i; i++) event.isImmediatePropagationStopped() || eventFns[i].call(element, event);
            }
        };
        return eventHandler.elem = element, eventHandler;
    }
    function $$jqLiteProvider() {
        this.$get = function() {
            return extend(JQLite, {
                hasClass: function(node, classes) {
                    return node.attr && (node = node[0]), jqLiteHasClass(node, classes);
                },
                addClass: function(node, classes) {
                    return node.attr && (node = node[0]), jqLiteAddClass(node, classes);
                },
                removeClass: function(node, classes) {
                    return node.attr && (node = node[0]), jqLiteRemoveClass(node, classes);
                }
            });
        };
    }
    function hashKey(obj, nextUidFn) {
        var key = obj && obj.$$hashKey;
        if (key) return "function" == typeof key && (key = obj.$$hashKey()), key;
        var objType = typeof obj;
        return key = "function" == objType || "object" == objType && null !== obj ? obj.$$hashKey = objType + ":" + (nextUidFn || nextUid)() : objType + ":" + obj;
    }
    function HashMap(array, isolatedUid) {
        if (isolatedUid) {
            var uid = 0;
            this.nextUid = function() {
                return ++uid;
            };
        }
        forEach(array, this.put, this);
    }
    function anonFn(fn) {
        var fnText = fn.toString().replace(STRIP_COMMENTS, ""), args = fnText.match(FN_ARGS);
        return args ? "function(" + (args[1] || "").replace(/[\s\r\n]+/, " ") + ")" : "fn";
    }
    function annotate(fn, strictDi, name) {
        var $inject, fnText, argDecl, last;
        if ("function" == typeof fn) {
            if (!($inject = fn.$inject)) {
                if ($inject = [], fn.length) {
                    if (strictDi) throw isString(name) && name || (name = fn.name || anonFn(fn)), $injectorMinErr("strictdi", "{0} is not using explicit annotation and cannot be invoked in strict mode", name);
                    fnText = fn.toString().replace(STRIP_COMMENTS, ""), argDecl = fnText.match(FN_ARGS), 
                    forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                        arg.replace(FN_ARG, function(all, underscore, name) {
                            $inject.push(name);
                        });
                    });
                }
                fn.$inject = $inject;
            }
        } else isArray(fn) ? (last = fn.length - 1, assertArgFn(fn[last], "fn"), $inject = fn.slice(0, last)) : assertArgFn(fn, "fn", !0);
        return $inject;
    }
    function createInjector(modulesToLoad, strictDi) {
        function supportObject(delegate) {
            return function(key, value) {
                return isObject(key) ? void forEach(key, reverseParams(delegate)) : delegate(key, value);
            };
        }
        function provider(name, provider_) {
            if (assertNotHasOwnProperty(name, "service"), (isFunction(provider_) || isArray(provider_)) && (provider_ = providerInjector.instantiate(provider_)), 
            !provider_.$get) throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name);
            return providerCache[name + providerSuffix] = provider_;
        }
        function enforceReturnValue(name, factory) {
            return function() {
                var result = instanceInjector.invoke(factory, this);
                if (isUndefined(result)) throw $injectorMinErr("undef", "Provider '{0}' must return a value from $get factory method.", name);
                return result;
            };
        }
        function factory(name, factoryFn, enforce) {
            return provider(name, {
                $get: enforce !== !1 ? enforceReturnValue(name, factoryFn) : factoryFn
            });
        }
        function service(name, constructor) {
            return factory(name, [ "$injector", function($injector) {
                return $injector.instantiate(constructor);
            } ]);
        }
        function value(name, val) {
            return factory(name, valueFn(val), !1);
        }
        function constant(name, value) {
            assertNotHasOwnProperty(name, "constant"), providerCache[name] = value, instanceCache[name] = value;
        }
        function decorator(serviceName, decorFn) {
            var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
            origProvider.$get = function() {
                var origInstance = instanceInjector.invoke(orig$get, origProvider);
                return instanceInjector.invoke(decorFn, null, {
                    $delegate: origInstance
                });
            };
        }
        function loadModules(modulesToLoad) {
            var moduleFn, runBlocks = [];
            return forEach(modulesToLoad, function(module) {
                function runInvokeQueue(queue) {
                    var i, ii;
                    for (i = 0, ii = queue.length; ii > i; i++) {
                        var invokeArgs = queue[i], provider = providerInjector.get(invokeArgs[0]);
                        provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
                    }
                }
                if (!loadedModules.get(module)) {
                    loadedModules.put(module, !0);
                    try {
                        isString(module) ? (moduleFn = angularModule(module), runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks), 
                        runInvokeQueue(moduleFn._invokeQueue), runInvokeQueue(moduleFn._configBlocks)) : isFunction(module) ? runBlocks.push(providerInjector.invoke(module)) : isArray(module) ? runBlocks.push(providerInjector.invoke(module)) : assertArgFn(module, "module");
                    } catch (e) {
                        throw isArray(module) && (module = module[module.length - 1]), e.message && e.stack && -1 == e.stack.indexOf(e.message) && (e = e.message + "\n" + e.stack), 
                        $injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
                    }
                }
            }), runBlocks;
        }
        function createInternalInjector(cache, factory) {
            function getService(serviceName, caller) {
                if (cache.hasOwnProperty(serviceName)) {
                    if (cache[serviceName] === INSTANTIATING) throw $injectorMinErr("cdep", "Circular dependency found: {0}", serviceName + " <- " + path.join(" <- "));
                    return cache[serviceName];
                }
                try {
                    return path.unshift(serviceName), cache[serviceName] = INSTANTIATING, cache[serviceName] = factory(serviceName, caller);
                } catch (err) {
                    throw cache[serviceName] === INSTANTIATING && delete cache[serviceName], err;
                } finally {
                    path.shift();
                }
            }
            function invoke(fn, self, locals, serviceName) {
                "string" == typeof locals && (serviceName = locals, locals = null);
                var length, i, key, args = [], $inject = createInjector.$$annotate(fn, strictDi, serviceName);
                for (i = 0, length = $inject.length; length > i; i++) {
                    if (key = $inject[i], "string" != typeof key) throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key);
                    args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
                }
                return isArray(fn) && (fn = fn[length]), fn.apply(self, args);
            }
            function instantiate(Type, locals, serviceName) {
                var instance = Object.create((isArray(Type) ? Type[Type.length - 1] : Type).prototype || null), returnedValue = invoke(Type, instance, locals, serviceName);
                return isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;
            }
            return {
                invoke: invoke,
                instantiate: instantiate,
                get: getService,
                annotate: createInjector.$$annotate,
                has: function(name) {
                    return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
                }
            };
        }
        strictDi = strictDi === !0;
        var INSTANTIATING = {}, providerSuffix = "Provider", path = [], loadedModules = new HashMap([], !0), providerCache = {
            $provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
            }
        }, providerInjector = providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
            throw angular.isString(caller) && path.push(caller), $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "));
        }), instanceCache = {}, instanceInjector = instanceCache.$injector = createInternalInjector(instanceCache, function(serviceName, caller) {
            var provider = providerInjector.get(serviceName + providerSuffix, caller);
            return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
        });
        return forEach(loadModules(modulesToLoad), function(fn) {
            fn && instanceInjector.invoke(fn);
        }), instanceInjector;
    }
    function $AnchorScrollProvider() {
        var autoScrollingEnabled = !0;
        this.disableAutoScrolling = function() {
            autoScrollingEnabled = !1;
        }, this.$get = [ "$window", "$location", "$rootScope", function($window, $location, $rootScope) {
            function getFirstAnchor(list) {
                var result = null;
                return Array.prototype.some.call(list, function(element) {
                    return "a" === nodeName_(element) ? (result = element, !0) : void 0;
                }), result;
            }
            function getYOffset() {
                var offset = scroll.yOffset;
                if (isFunction(offset)) offset = offset(); else if (isElement(offset)) {
                    var elem = offset[0], style = $window.getComputedStyle(elem);
                    offset = "fixed" !== style.position ? 0 : elem.getBoundingClientRect().bottom;
                } else isNumber(offset) || (offset = 0);
                return offset;
            }
            function scrollTo(elem) {
                if (elem) {
                    elem.scrollIntoView();
                    var offset = getYOffset();
                    if (offset) {
                        var elemTop = elem.getBoundingClientRect().top;
                        $window.scrollBy(0, elemTop - offset);
                    }
                } else $window.scrollTo(0, 0);
            }
            function scroll(hash) {
                hash = isString(hash) ? hash : $location.hash();
                var elm;
                hash ? (elm = document.getElementById(hash)) ? scrollTo(elm) : (elm = getFirstAnchor(document.getElementsByName(hash))) ? scrollTo(elm) : "top" === hash && scrollTo(null) : scrollTo(null);
            }
            var document = $window.document;
            return autoScrollingEnabled && $rootScope.$watch(function() {
                return $location.hash();
            }, function(newVal, oldVal) {
                (newVal !== oldVal || "" !== newVal) && jqLiteDocumentLoaded(function() {
                    $rootScope.$evalAsync(scroll);
                });
            }), scroll;
        } ];
    }
    function mergeClasses(a, b) {
        return a || b ? a ? b ? (isArray(a) && (a = a.join(" ")), isArray(b) && (b = b.join(" ")), 
        a + " " + b) : a : b : "";
    }
    function extractElementNode(element) {
        for (var i = 0; i < element.length; i++) {
            var elm = element[i];
            if (elm.nodeType === ELEMENT_NODE) return elm;
        }
    }
    function splitClasses(classes) {
        isString(classes) && (classes = classes.split(" "));
        var obj = createMap();
        return forEach(classes, function(klass) {
            klass.length && (obj[klass] = !0);
        }), obj;
    }
    function prepareAnimateOptions(options) {
        return isObject(options) ? options : {};
    }
    function Browser(window, document, $log, $sniffer) {
        function completeOutstandingRequest(fn) {
            try {
                fn.apply(null, sliceArgs(arguments, 1));
            } finally {
                if (outstandingRequestCount--, 0 === outstandingRequestCount) for (;outstandingRequestCallbacks.length; ) try {
                    outstandingRequestCallbacks.pop()();
                } catch (e) {
                    $log.error(e);
                }
            }
        }
        function getHash(url) {
            var index = url.indexOf("#");
            return -1 === index ? "" : url.substr(index);
        }
        function cacheStateAndFireUrlChange() {
            cacheState(), fireUrlChange();
        }
        function getCurrentState() {
            try {
                return history.state;
            } catch (e) {}
        }
        function cacheState() {
            cachedState = getCurrentState(), cachedState = isUndefined(cachedState) ? null : cachedState, 
            equals(cachedState, lastCachedState) && (cachedState = lastCachedState), lastCachedState = cachedState;
        }
        function fireUrlChange() {
            (lastBrowserUrl !== self.url() || lastHistoryState !== cachedState) && (lastBrowserUrl = self.url(), 
            lastHistoryState = cachedState, forEach(urlChangeListeners, function(listener) {
                listener(self.url(), cachedState);
            }));
        }
        var self = this, location = (document[0], window.location), history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {};
        self.isMock = !1;
        var outstandingRequestCount = 0, outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest, self.$$incOutstandingRequestCount = function() {
            outstandingRequestCount++;
        }, self.notifyWhenNoOutstandingRequests = function(callback) {
            0 === outstandingRequestCount ? callback() : outstandingRequestCallbacks.push(callback);
        };
        var cachedState, lastHistoryState, lastBrowserUrl = location.href, baseElement = document.find("base"), reloadLocation = null;
        cacheState(), lastHistoryState = cachedState, self.url = function(url, replace, state) {
            if (isUndefined(state) && (state = null), location !== window.location && (location = window.location), 
            history !== window.history && (history = window.history), url) {
                var sameState = lastHistoryState === state;
                if (lastBrowserUrl === url && (!$sniffer.history || sameState)) return self;
                var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
                return lastBrowserUrl = url, lastHistoryState = state, !$sniffer.history || sameBase && sameState ? ((!sameBase || reloadLocation) && (reloadLocation = url), 
                replace ? location.replace(url) : sameBase ? location.hash = getHash(url) : location.href = url) : (history[replace ? "replaceState" : "pushState"](state, "", url), 
                cacheState(), lastHistoryState = cachedState), self;
            }
            return reloadLocation || location.href.replace(/%27/g, "'");
        }, self.state = function() {
            return cachedState;
        };
        var urlChangeListeners = [], urlChangeInit = !1, lastCachedState = null;
        self.onUrlChange = function(callback) {
            return urlChangeInit || ($sniffer.history && jqLite(window).on("popstate", cacheStateAndFireUrlChange), 
            jqLite(window).on("hashchange", cacheStateAndFireUrlChange), urlChangeInit = !0), 
            urlChangeListeners.push(callback), callback;
        }, self.$$applicationDestroyed = function() {
            jqLite(window).off("hashchange popstate", cacheStateAndFireUrlChange);
        }, self.$$checkUrlChange = fireUrlChange, self.baseHref = function() {
            var href = baseElement.attr("href");
            return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, "") : "";
        }, self.defer = function(fn, delay) {
            var timeoutId;
            return outstandingRequestCount++, timeoutId = setTimeout(function() {
                delete pendingDeferIds[timeoutId], completeOutstandingRequest(fn);
            }, delay || 0), pendingDeferIds[timeoutId] = !0, timeoutId;
        }, self.defer.cancel = function(deferId) {
            return pendingDeferIds[deferId] ? (delete pendingDeferIds[deferId], clearTimeout(deferId), 
            completeOutstandingRequest(noop), !0) : !1;
        };
    }
    function $BrowserProvider() {
        this.$get = [ "$window", "$log", "$sniffer", "$document", function($window, $log, $sniffer, $document) {
            return new Browser($window, $document, $log, $sniffer);
        } ];
    }
    function $CacheFactoryProvider() {
        this.$get = function() {
            function cacheFactory(cacheId, options) {
                function refresh(entry) {
                    entry != freshEnd && (staleEnd ? staleEnd == entry && (staleEnd = entry.n) : staleEnd = entry, 
                    link(entry.n, entry.p), link(entry, freshEnd), freshEnd = entry, freshEnd.n = null);
                }
                function link(nextEntry, prevEntry) {
                    nextEntry != prevEntry && (nextEntry && (nextEntry.p = prevEntry), prevEntry && (prevEntry.n = nextEntry));
                }
                if (cacheId in caches) throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId);
                var size = 0, stats = extend({}, options, {
                    id: cacheId
                }), data = {}, capacity = options && options.capacity || Number.MAX_VALUE, lruHash = {}, freshEnd = null, staleEnd = null;
                return caches[cacheId] = {
                    put: function(key, value) {
                        if (!isUndefined(value)) {
                            if (capacity < Number.MAX_VALUE) {
                                var lruEntry = lruHash[key] || (lruHash[key] = {
                                    key: key
                                });
                                refresh(lruEntry);
                            }
                            return key in data || size++, data[key] = value, size > capacity && this.remove(staleEnd.key), 
                            value;
                        }
                    },
                    get: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            refresh(lruEntry);
                        }
                        return data[key];
                    },
                    remove: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            lruEntry == freshEnd && (freshEnd = lruEntry.p), lruEntry == staleEnd && (staleEnd = lruEntry.n), 
                            link(lruEntry.n, lruEntry.p), delete lruHash[key];
                        }
                        delete data[key], size--;
                    },
                    removeAll: function() {
                        data = {}, size = 0, lruHash = {}, freshEnd = staleEnd = null;
                    },
                    destroy: function() {
                        data = null, stats = null, lruHash = null, delete caches[cacheId];
                    },
                    info: function() {
                        return extend({}, stats, {
                            size: size
                        });
                    }
                };
            }
            var caches = {};
            return cacheFactory.info = function() {
                var info = {};
                return forEach(caches, function(cache, cacheId) {
                    info[cacheId] = cache.info();
                }), info;
            }, cacheFactory.get = function(cacheId) {
                return caches[cacheId];
            }, cacheFactory;
        };
    }
    function $TemplateCacheProvider() {
        this.$get = [ "$cacheFactory", function($cacheFactory) {
            return $cacheFactory("templates");
        } ];
    }
    function $CompileProvider($provide, $$sanitizeUriProvider) {
        function parseIsolateBindings(scope, directiveName, isController) {
            var LOCAL_REGEXP = /^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/, bindings = {};
            return forEach(scope, function(definition, scopeName) {
                var match = definition.match(LOCAL_REGEXP);
                if (!match) throw $compileMinErr("iscp", "Invalid {3} for directive '{0}'. Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, isController ? "controller bindings definition" : "isolate scope definition");
                bindings[scopeName] = {
                    mode: match[1][0],
                    collection: "*" === match[2],
                    optional: "?" === match[3],
                    attrName: match[4] || scopeName
                };
            }), bindings;
        }
        function parseDirectiveBindings(directive, directiveName) {
            var bindings = {
                isolateScope: null,
                bindToController: null
            };
            if (isObject(directive.scope) && (directive.bindToController === !0 ? (bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, !0), 
            bindings.isolateScope = {}) : bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, !1)), 
            isObject(directive.bindToController) && (bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, !0)), 
            isObject(bindings.bindToController)) {
                var controller = directive.controller, controllerAs = directive.controllerAs;
                if (!controller) throw $compileMinErr("noctrl", "Cannot bind to controller without directive '{0}'s controller.", directiveName);
                if (!identifierForController(controller, controllerAs)) throw $compileMinErr("noident", "Cannot bind to controller without identifier for directive '{0}'.", directiveName);
            }
            return bindings;
        }
        function assertValidDirectiveName(name) {
            var letter = name.charAt(0);
            if (!letter || letter !== lowercase(letter)) throw $compileMinErr("baddir", "Directive name '{0}' is invalid. The first character must be a lowercase letter", name);
            if (name !== name.trim()) throw $compileMinErr("baddir", "Directive name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name);
        }
        var hasDirectives = {}, Suffix = "Directive", COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/, ALL_OR_NOTHING_ATTRS = makeMap("ngSrc,ngSrcset,src,srcset"), REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/, EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        this.directive = function registerDirective(name, directiveFactory) {
            return assertNotHasOwnProperty(name, "directive"), isString(name) ? (assertValidDirectiveName(name), 
            assertArg(directiveFactory, "directiveFactory"), hasDirectives.hasOwnProperty(name) || (hasDirectives[name] = [], 
            $provide.factory(name + Suffix, [ "$injector", "$exceptionHandler", function($injector, $exceptionHandler) {
                var directives = [];
                return forEach(hasDirectives[name], function(directiveFactory, index) {
                    try {
                        var directive = $injector.invoke(directiveFactory);
                        isFunction(directive) ? directive = {
                            compile: valueFn(directive)
                        } : !directive.compile && directive.link && (directive.compile = valueFn(directive.link)), 
                        directive.priority = directive.priority || 0, directive.index = index, directive.name = directive.name || name, 
                        directive.require = directive.require || directive.controller && directive.name, 
                        directive.restrict = directive.restrict || "EA";
                        var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                        isObject(bindings.isolateScope) && (directive.$$isolateBindings = bindings.isolateScope), 
                        directive.$$moduleName = directiveFactory.$$moduleName, directives.push(directive);
                    } catch (e) {
                        $exceptionHandler(e);
                    }
                }), directives;
            } ])), hasDirectives[name].push(directiveFactory)) : forEach(name, reverseParams(registerDirective)), 
            this;
        }, this.aHrefSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? ($$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp), 
            this) : $$sanitizeUriProvider.aHrefSanitizationWhitelist();
        }, this.imgSrcSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? ($$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp), 
            this) : $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
        };
        var debugInfoEnabled = !0;
        this.debugInfoEnabled = function(enabled) {
            return isDefined(enabled) ? (debugInfoEnabled = enabled, this) : debugInfoEnabled;
        }, this.$get = [ "$injector", "$interpolate", "$exceptionHandler", "$templateRequest", "$parse", "$controller", "$rootScope", "$document", "$sce", "$animate", "$$sanitizeUri", function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $document, $sce, $animate, $$sanitizeUri) {
            function safeAddClass($element, className) {
                try {
                    $element.addClass(className);
                } catch (e) {}
            }
            function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                $compileNodes instanceof jqLite || ($compileNodes = jqLite($compileNodes)), forEach($compileNodes, function(node, index) {
                    node.nodeType == NODE_TYPE_TEXT && node.nodeValue.match(/\S+/) && ($compileNodes[index] = jqLite(node).wrap("<span></span>").parent()[0]);
                });
                var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                compile.$$addScopeClass($compileNodes);
                var namespace = null;
                return function(scope, cloneConnectFn, options) {
                    assertArg(scope, "scope"), options = options || {};
                    var parentBoundTranscludeFn = options.parentBoundTranscludeFn, transcludeControllers = options.transcludeControllers, futureParentElement = options.futureParentElement;
                    parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude && (parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude), 
                    namespace || (namespace = detectNamespaceForChildElements(futureParentElement));
                    var $linkNode;
                    if ($linkNode = "html" !== namespace ? jqLite(wrapTemplate(namespace, jqLite("<div>").append($compileNodes).html())) : cloneConnectFn ? JQLitePrototype.clone.call($compileNodes) : $compileNodes, 
                    transcludeControllers) for (var controllerName in transcludeControllers) $linkNode.data("$" + controllerName + "Controller", transcludeControllers[controllerName].instance);
                    return compile.$$addScopeInfo($linkNode, scope), cloneConnectFn && cloneConnectFn($linkNode, scope), 
                    compositeLinkFn && compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn), 
                    $linkNode;
                };
            }
            function detectNamespaceForChildElements(parentElement) {
                var node = parentElement && parentElement[0];
                return node && "foreignobject" !== nodeName_(node) && node.toString().match(/SVG/) ? "svg" : "html";
            }
            function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                    var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn, stableNodeList;
                    if (nodeLinkFnFound) {
                        var nodeListLength = nodeList.length;
                        for (stableNodeList = new Array(nodeListLength), i = 0; i < linkFns.length; i += 3) idx = linkFns[i], 
                        stableNodeList[idx] = nodeList[idx];
                    } else stableNodeList = nodeList;
                    for (i = 0, ii = linkFns.length; ii > i; ) if (node = stableNodeList[linkFns[i++]], 
                    nodeLinkFn = linkFns[i++], childLinkFn = linkFns[i++], nodeLinkFn) {
                        if (nodeLinkFn.scope) {
                            childScope = scope.$new(), compile.$$addScopeInfo(jqLite(node), childScope);
                            var destroyBindings = nodeLinkFn.$$destroyBindings;
                            destroyBindings && (nodeLinkFn.$$destroyBindings = null, childScope.$on("$destroyed", destroyBindings));
                        } else childScope = scope;
                        childBoundTranscludeFn = nodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn) : !nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn ? parentBoundTranscludeFn : !parentBoundTranscludeFn && transcludeFn ? createBoundTranscludeFn(scope, transcludeFn) : null, 
                        nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn, nodeLinkFn);
                    } else childLinkFn && childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                }
                for (var attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound, linkFns = [], i = 0; i < nodeList.length; i++) attrs = new Attributes(), 
                directives = collectDirectives(nodeList[i], [], attrs, 0 === i ? maxPriority : undefined, ignoreDirective), 
                nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null, 
                nodeLinkFn && nodeLinkFn.scope && compile.$$addScopeClass(attrs.$$element), childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn), 
                (nodeLinkFn || childLinkFn) && (linkFns.push(i, nodeLinkFn, childLinkFn), linkFnFound = !0, 
                nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn), previousCompileContext = null;
                return linkFnFound ? compositeLinkFn : null;
            }
            function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
                var boundTranscludeFn = function(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
                    return transcludedScope || (transcludedScope = scope.$new(!1, containingScope), 
                    transcludedScope.$$transcluded = !0), transcludeFn(transcludedScope, cloneFn, {
                        parentBoundTranscludeFn: previousBoundTranscludeFn,
                        transcludeControllers: controllers,
                        futureParentElement: futureParentElement
                    });
                };
                return boundTranscludeFn;
            }
            function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                var match, className, nodeType = node.nodeType, attrsMap = attrs.$attr;
                switch (nodeType) {
                  case NODE_TYPE_ELEMENT:
                    addDirective(directives, directiveNormalize(nodeName_(node)), "E", maxPriority, ignoreDirective);
                    for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; jj > j; j++) {
                        var attrStartName = !1, attrEndName = !1;
                        attr = nAttrs[j], name = attr.name, value = trim(attr.value), ngAttrName = directiveNormalize(name), 
                        (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) && (name = name.replace(PREFIX_REGEXP, "").substr(8).replace(/_(.)/g, function(match, letter) {
                            return letter.toUpperCase();
                        }));
                        var directiveNName = ngAttrName.replace(/(Start|End)$/, "");
                        directiveIsMultiElement(directiveNName) && ngAttrName === directiveNName + "Start" && (attrStartName = name, 
                        attrEndName = name.substr(0, name.length - 5) + "end", name = name.substr(0, name.length - 6)), 
                        nName = directiveNormalize(name.toLowerCase()), attrsMap[nName] = name, (isNgAttr || !attrs.hasOwnProperty(nName)) && (attrs[nName] = value, 
                        getBooleanAttrName(node, nName) && (attrs[nName] = !0)), addAttrInterpolateDirective(node, directives, value, nName, isNgAttr), 
                        addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName);
                    }
                    if (className = node.className, isObject(className) && (className = className.animVal), 
                    isString(className) && "" !== className) for (;match = CLASS_DIRECTIVE_REGEXP.exec(className); ) nName = directiveNormalize(match[2]), 
                    addDirective(directives, nName, "C", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[3])), 
                    className = className.substr(match.index + match[0].length);
                    break;

                  case NODE_TYPE_TEXT:
                    if (11 === msie) for (;node.parentNode && node.nextSibling && node.nextSibling.nodeType === NODE_TYPE_TEXT; ) node.nodeValue = node.nodeValue + node.nextSibling.nodeValue, 
                    node.parentNode.removeChild(node.nextSibling);
                    addTextInterpolateDirective(directives, node.nodeValue);
                    break;

                  case NODE_TYPE_COMMENT:
                    try {
                        match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue), match && (nName = directiveNormalize(match[1]), 
                        addDirective(directives, nName, "M", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[2])));
                    } catch (e) {}
                }
                return directives.sort(byPriority), directives;
            }
            function groupScan(node, attrStart, attrEnd) {
                var nodes = [], depth = 0;
                if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
                    do {
                        if (!node) throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                        node.nodeType == NODE_TYPE_ELEMENT && (node.hasAttribute(attrStart) && depth++, 
                        node.hasAttribute(attrEnd) && depth--), nodes.push(node), node = node.nextSibling;
                    } while (depth > 0);
                } else nodes.push(node);
                return jqLite(nodes);
            }
            function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                return function(scope, element, attrs, controllers, transcludeFn) {
                    return element = groupScan(element[0], attrStart, attrEnd), linkFn(scope, element, attrs, controllers, transcludeFn);
                };
            }
            function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                function addLinkFns(pre, post, attrStart, attrEnd) {
                    pre && (attrStart && (pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd)), 
                    pre.require = directive.require, pre.directiveName = directiveName, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (pre = cloneAndAnnotateFn(pre, {
                        isolateScope: !0
                    })), preLinkFns.push(pre)), post && (attrStart && (post = groupElementsLinkFnWrapper(post, attrStart, attrEnd)), 
                    post.require = directive.require, post.directiveName = directiveName, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (post = cloneAndAnnotateFn(post, {
                        isolateScope: !0
                    })), postLinkFns.push(post));
                }
                function getControllers(directiveName, require, $element, elementControllers) {
                    var value;
                    if (isString(require)) {
                        var match = require.match(REQUIRE_PREFIX_REGEXP), name = require.substring(match[0].length), inheritType = match[1] || match[3], optional = "?" === match[2];
                        if ("^^" === inheritType ? $element = $element.parent() : (value = elementControllers && elementControllers[name], 
                        value = value && value.instance), !value) {
                            var dataName = "$" + name + "Controller";
                            value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
                        }
                        if (!value && !optional) throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);
                    } else if (isArray(require)) {
                        value = [];
                        for (var i = 0, ii = require.length; ii > i; i++) value[i] = getControllers(directiveName, require[i], $element, elementControllers);
                    }
                    return value || null;
                }
                function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope) {
                    var elementControllers = createMap();
                    for (var controllerKey in controllerDirectives) {
                        var directive = controllerDirectives[controllerKey], locals = {
                            $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                            $element: $element,
                            $attrs: attrs,
                            $transclude: transcludeFn
                        }, controller = directive.controller;
                        "@" == controller && (controller = attrs[directive.name]);
                        var controllerInstance = $controller(controller, locals, !0, directive.controllerAs);
                        elementControllers[directive.name] = controllerInstance, hasElementTranscludeDirective || $element.data("$" + directive.name + "Controller", controllerInstance.instance);
                    }
                    return elementControllers;
                }
                function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn, thisLinkFn) {
                    function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement) {
                        var transcludeControllers;
                        return isScope(scope) || (futureParentElement = cloneAttachFn, cloneAttachFn = scope, 
                        scope = undefined), hasElementTranscludeDirective && (transcludeControllers = elementControllers), 
                        futureParentElement || (futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element), 
                        boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                    }
                    var i, ii, linkFn, controller, isolateScope, elementControllers, transcludeFn, $element, attrs;
                    if (compileNode === linkNode ? (attrs = templateAttrs, $element = templateAttrs.$$element) : ($element = jqLite(linkNode), 
                    attrs = new Attributes($element, templateAttrs)), newIsolateScopeDirective && (isolateScope = scope.$new(!0)), 
                    boundTranscludeFn && (transcludeFn = controllersBoundTransclude, transcludeFn.$$boundTransclude = boundTranscludeFn), 
                    controllerDirectives && (elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope)), 
                    newIsolateScopeDirective && (compile.$$addScopeInfo($element, isolateScope, !0, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective))), 
                    compile.$$addScopeClass($element, !0), isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings, 
                    initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective, isolateScope)), 
                    elementControllers) {
                        var bindings, controllerForBindings, scopeDirective = newIsolateScopeDirective || newScopeDirective;
                        scopeDirective && elementControllers[scopeDirective.name] && (bindings = scopeDirective.$$bindings.bindToController, 
                        controller = elementControllers[scopeDirective.name], controller && controller.identifier && bindings && (controllerForBindings = controller, 
                        thisLinkFn.$$destroyBindings = initializeDirectiveBindings(scope, attrs, controller.instance, bindings, scopeDirective)));
                        for (i in elementControllers) {
                            controller = elementControllers[i];
                            var controllerResult = controller();
                            controllerResult !== controller.instance && (controller.instance = controllerResult, 
                            $element.data("$" + i + "Controller", controllerResult), controller === controllerForBindings && (thisLinkFn.$$destroyBindings(), 
                            thisLinkFn.$$destroyBindings = initializeDirectiveBindings(scope, attrs, controllerResult, bindings, scopeDirective)));
                        }
                    }
                    for (i = 0, ii = preLinkFns.length; ii > i; i++) linkFn = preLinkFns[i], invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                    var scopeToChild = scope;
                    for (newIsolateScopeDirective && (newIsolateScopeDirective.template || null === newIsolateScopeDirective.templateUrl) && (scopeToChild = isolateScope), 
                    childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn), 
                    i = postLinkFns.length - 1; i >= 0; i--) linkFn = postLinkFns[i], invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                }
                previousCompileContext = previousCompileContext || {};
                for (var directive, directiveName, $template, linkFn, directiveValue, terminalPriority = -Number.MAX_VALUE, newScopeDirective = previousCompileContext.newScopeDirective, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = !1, hasTemplate = !1, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, i = 0, ii = directives.length; ii > i; i++) {
                    directive = directives[i];
                    var attrStart = directive.$$start, attrEnd = directive.$$end;
                    if (attrStart && ($compileNode = groupScan(compileNode, attrStart, attrEnd)), $template = undefined, 
                    terminalPriority > directive.priority) break;
                    if ((directiveValue = directive.scope) && (directive.templateUrl || (isObject(directiveValue) ? (assertNoDuplicate("new/isolated scope", newIsolateScopeDirective || newScopeDirective, directive, $compileNode), 
                    newIsolateScopeDirective = directive) : assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode)), 
                    newScopeDirective = newScopeDirective || directive), directiveName = directive.name, 
                    !directive.templateUrl && directive.controller && (directiveValue = directive.controller, 
                    controllerDirectives = controllerDirectives || createMap(), assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode), 
                    controllerDirectives[directiveName] = directive), (directiveValue = directive.transclude) && (hasTranscludeDirective = !0, 
                    directive.$$tlb || (assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode), 
                    nonTlbTranscludeDirective = directive), "element" == directiveValue ? (hasElementTranscludeDirective = !0, 
                    terminalPriority = directive.priority, $template = $compileNode, $compileNode = templateAttrs.$$element = jqLite(document.createComment(" " + directiveName + ": " + templateAttrs[directiveName] + " ")), 
                    compileNode = $compileNode[0], replaceWith(jqCollection, sliceArgs($template), compileNode), 
                    childTranscludeFn = compile($template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {
                        nonTlbTranscludeDirective: nonTlbTranscludeDirective
                    })) : ($template = jqLite(jqLiteClone(compileNode)).contents(), $compileNode.empty(), 
                    childTranscludeFn = compile($template, transcludeFn))), directive.template) if (hasTemplate = !0, 
                    assertNoDuplicate("template", templateDirective, directive, $compileNode), templateDirective = directive, 
                    directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template, 
                    directiveValue = denormalizeTemplate(directiveValue), directive.replace) {
                        if (replaceDirective = directive, $template = jqLiteIsTextNode(directiveValue) ? [] : removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue))), 
                        compileNode = $template[0], 1 != $template.length || compileNode.nodeType !== NODE_TYPE_ELEMENT) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "");
                        replaceWith(jqCollection, $compileNode, compileNode);
                        var newTemplateAttrs = {
                            $attr: {}
                        }, templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs), unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                        newIsolateScopeDirective && markDirectivesAsIsolate(templateDirectives), directives = directives.concat(templateDirectives).concat(unprocessedDirectives), 
                        mergeTemplateAttributes(templateAttrs, newTemplateAttrs), ii = directives.length;
                    } else $compileNode.html(directiveValue);
                    if (directive.templateUrl) hasTemplate = !0, assertNoDuplicate("template", templateDirective, directive, $compileNode), 
                    templateDirective = directive, directive.replace && (replaceDirective = directive), 
                    nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                        controllerDirectives: controllerDirectives,
                        newScopeDirective: newScopeDirective !== directive && newScopeDirective,
                        newIsolateScopeDirective: newIsolateScopeDirective,
                        templateDirective: templateDirective,
                        nonTlbTranscludeDirective: nonTlbTranscludeDirective
                    }), ii = directives.length; else if (directive.compile) try {
                        linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn), isFunction(linkFn) ? addLinkFns(null, linkFn, attrStart, attrEnd) : linkFn && addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
                    } catch (e) {
                        $exceptionHandler(e, startingTag($compileNode));
                    }
                    directive.terminal && (nodeLinkFn.terminal = !0, terminalPriority = Math.max(terminalPriority, directive.priority));
                }
                return nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === !0, nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective, 
                nodeLinkFn.templateOnThisElement = hasTemplate, nodeLinkFn.transclude = childTranscludeFn, 
                previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective, 
                nodeLinkFn;
            }
            function markDirectivesAsIsolate(directives) {
                for (var j = 0, jj = directives.length; jj > j; j++) directives[j] = inherit(directives[j], {
                    $$isolateScope: !0
                });
            }
            function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                if (name === ignoreDirective) return null;
                var match = null;
                if (hasDirectives.hasOwnProperty(name)) for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; ii > i; i++) try {
                    directive = directives[i], (maxPriority === undefined || maxPriority > directive.priority) && -1 != directive.restrict.indexOf(location) && (startAttrName && (directive = inherit(directive, {
                        $$start: startAttrName,
                        $$end: endAttrName
                    })), tDirectives.push(directive), match = directive);
                } catch (e) {
                    $exceptionHandler(e);
                }
                return match;
            }
            function directiveIsMultiElement(name) {
                if (hasDirectives.hasOwnProperty(name)) for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; ii > i; i++) if (directive = directives[i], 
                directive.multiElement) return !0;
                return !1;
            }
            function mergeTemplateAttributes(dst, src) {
                var srcAttr = src.$attr, dstAttr = dst.$attr, $element = dst.$$element;
                forEach(dst, function(value, key) {
                    "$" != key.charAt(0) && (src[key] && src[key] !== value && (value += ("style" === key ? ";" : " ") + src[key]), 
                    dst.$set(key, value, !0, srcAttr[key]));
                }), forEach(src, function(value, key) {
                    "class" == key ? (safeAddClass($element, value), dst["class"] = (dst["class"] ? dst["class"] + " " : "") + value) : "style" == key ? ($element.attr("style", $element.attr("style") + ";" + value), 
                    dst.style = (dst.style ? dst.style + ";" : "") + value) : "$" == key.charAt(0) || dst.hasOwnProperty(key) || (dst[key] = value, 
                    dstAttr[key] = srcAttr[key]);
                });
            }
            function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                var afterTemplateNodeLinkFn, afterTemplateChildLinkFn, linkQueue = [], beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = inherit(origAsyncDirective, {
                    templateUrl: null,
                    transclude: null,
                    replace: null,
                    $$originalDirective: origAsyncDirective
                }), templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl, templateNamespace = origAsyncDirective.templateNamespace;
                return $compileNode.empty(), $templateRequest(templateUrl).then(function(content) {
                    var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                    if (content = denormalizeTemplate(content), origAsyncDirective.replace) {
                        if ($template = jqLiteIsTextNode(content) ? [] : removeComments(wrapTemplate(templateNamespace, trim(content))), 
                        compileNode = $template[0], 1 != $template.length || compileNode.nodeType !== NODE_TYPE_ELEMENT) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                        tempTemplateAttrs = {
                            $attr: {}
                        }, replaceWith($rootElement, $compileNode, compileNode);
                        var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                        isObject(origAsyncDirective.scope) && markDirectivesAsIsolate(templateDirectives), 
                        directives = templateDirectives.concat(directives), mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                    } else compileNode = beforeTemplateCompileNode, $compileNode.html(content);
                    for (directives.unshift(derivedSyncDirective), afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext), 
                    forEach($rootElement, function(node, i) {
                        node == compileNode && ($rootElement[i] = $compileNode[0]);
                    }), afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn); linkQueue.length; ) {
                        var scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(), linkRootElement = linkQueue.shift(), boundTranscludeFn = linkQueue.shift(), linkNode = $compileNode[0];
                        if (!scope.$$destroyed) {
                            if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                                var oldClasses = beforeTemplateLinkNode.className;
                                previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace || (linkNode = jqLiteClone(compileNode)), 
                                replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode), safeAddClass(jqLite(linkNode), oldClasses);
                            }
                            childBoundTranscludeFn = afterTemplateNodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn) : boundTranscludeFn, 
                            afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn, afterTemplateNodeLinkFn);
                        }
                    }
                    linkQueue = null;
                }), function(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                    var childBoundTranscludeFn = boundTranscludeFn;
                    scope.$$destroyed || (linkQueue ? linkQueue.push(scope, node, rootElement, childBoundTranscludeFn) : (afterTemplateNodeLinkFn.transcludeOnThisElement && (childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn)), 
                    afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn, afterTemplateNodeLinkFn)));
                };
            }
            function byPriority(a, b) {
                var diff = b.priority - a.priority;
                return 0 !== diff ? diff : a.name !== b.name ? a.name < b.name ? -1 : 1 : a.index - b.index;
            }
            function assertNoDuplicate(what, previousDirective, directive, element) {
                function wrapModuleNameIfDefined(moduleName) {
                    return moduleName ? " (module: " + moduleName + ")" : "";
                }
                if (previousDirective) throw $compileMinErr("multidir", "Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}", previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
            }
            function addTextInterpolateDirective(directives, text) {
                var interpolateFn = $interpolate(text, !0);
                interpolateFn && directives.push({
                    priority: 0,
                    compile: function(templateNode) {
                        var templateNodeParent = templateNode.parent(), hasCompileParent = !!templateNodeParent.length;
                        return hasCompileParent && compile.$$addBindingClass(templateNodeParent), function(scope, node) {
                            var parent = node.parent();
                            hasCompileParent || compile.$$addBindingClass(parent), compile.$$addBindingInfo(parent, interpolateFn.expressions), 
                            scope.$watch(interpolateFn, function(value) {
                                node[0].nodeValue = value;
                            });
                        };
                    }
                });
            }
            function wrapTemplate(type, template) {
                switch (type = lowercase(type || "html")) {
                  case "svg":
                  case "math":
                    var wrapper = document.createElement("div");
                    return wrapper.innerHTML = "<" + type + ">" + template + "</" + type + ">", wrapper.childNodes[0].childNodes;

                  default:
                    return template;
                }
            }
            function getTrustedContext(node, attrNormalizedName) {
                if ("srcdoc" == attrNormalizedName) return $sce.HTML;
                var tag = nodeName_(node);
                return "xlinkHref" == attrNormalizedName || "form" == tag && "action" == attrNormalizedName || "img" != tag && ("src" == attrNormalizedName || "ngSrc" == attrNormalizedName) ? $sce.RESOURCE_URL : void 0;
            }
            function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
                var trustedContext = getTrustedContext(node, name);
                allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
                var interpolateFn = $interpolate(value, !0, trustedContext, allOrNothing);
                if (interpolateFn) {
                    if ("multiple" === name && "select" === nodeName_(node)) throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
                    directives.push({
                        priority: 100,
                        compile: function() {
                            return {
                                pre: function(scope, element, attr) {
                                    var $$observers = attr.$$observers || (attr.$$observers = {});
                                    if (EVENT_HANDLER_ATTR_REGEXP.test(name)) throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed.  Please use the ng- versions (such as ng-click instead of onclick) instead.");
                                    var newValue = attr[name];
                                    newValue !== value && (interpolateFn = newValue && $interpolate(newValue, !0, trustedContext, allOrNothing), 
                                    value = newValue), interpolateFn && (attr[name] = interpolateFn(scope), ($$observers[name] || ($$observers[name] = [])).$$inter = !0, 
                                    (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function(newValue, oldValue) {
                                        "class" === name && newValue != oldValue ? attr.$updateClass(newValue, oldValue) : attr.$set(name, newValue);
                                    }));
                                }
                            };
                        }
                    });
                }
            }
            function replaceWith($rootElement, elementsToRemove, newNode) {
                var i, ii, firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode;
                if ($rootElement) for (i = 0, ii = $rootElement.length; ii > i; i++) if ($rootElement[i] == firstElementToRemove) {
                    $rootElement[i++] = newNode;
                    for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; jj > j; j++, 
                    j2++) jj > j2 ? $rootElement[j] = $rootElement[j2] : delete $rootElement[j];
                    $rootElement.length -= removeCount - 1, $rootElement.context === firstElementToRemove && ($rootElement.context = newNode);
                    break;
                }
                parent && parent.replaceChild(newNode, firstElementToRemove);
                var fragment = document.createDocumentFragment();
                fragment.appendChild(firstElementToRemove), jqLite.hasData(firstElementToRemove) && (jqLite(newNode).data(jqLite(firstElementToRemove).data()), 
                jQuery ? (skipDestroyOnNextJQueryCleanData = !0, jQuery.cleanData([ firstElementToRemove ])) : delete jqLite.cache[firstElementToRemove[jqLite.expando]]);
                for (var k = 1, kk = elementsToRemove.length; kk > k; k++) {
                    var element = elementsToRemove[k];
                    jqLite(element).remove(), fragment.appendChild(element), delete elementsToRemove[k];
                }
                elementsToRemove[0] = newNode, elementsToRemove.length = 1;
            }
            function cloneAndAnnotateFn(fn, annotation) {
                return extend(function() {
                    return fn.apply(null, arguments);
                }, fn, annotation);
            }
            function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
                try {
                    linkFn(scope, $element, attrs, controllers, transcludeFn);
                } catch (e) {
                    $exceptionHandler(e, startingTag($element));
                }
            }
            function initializeDirectiveBindings(scope, attrs, destination, bindings, directive, newScope) {
                var onNewScopeDestroyed;
                forEach(bindings, function(definition, scopeName) {
                    var lastValue, parentGet, parentSet, compare, attrName = definition.attrName, optional = definition.optional, mode = definition.mode;
                    switch (hasOwnProperty.call(attrs, attrName) || (attrs[attrName] = undefined), mode) {
                      case "@":
                        attrs[attrName] || optional || (destination[scopeName] = undefined), attrs.$observe(attrName, function(value) {
                            destination[scopeName] = value;
                        }), attrs.$$observers[attrName].$$scope = scope, attrs[attrName] && (destination[scopeName] = $interpolate(attrs[attrName])(scope));
                        break;

                      case "=":
                        if (optional && !attrs[attrName]) return;
                        parentGet = $parse(attrs[attrName]), compare = parentGet.literal ? equals : function(a, b) {
                            return a === b || a !== a && b !== b;
                        }, parentSet = parentGet.assign || function() {
                            throw lastValue = destination[scopeName] = parentGet(scope), $compileMinErr("nonassign", "Expression '{0}' used with directive '{1}' is non-assignable!", attrs[attrName], directive.name);
                        }, lastValue = destination[scopeName] = parentGet(scope);
                        var parentValueWatch = function(parentValue) {
                            return compare(parentValue, destination[scopeName]) || (compare(parentValue, lastValue) ? parentSet(scope, parentValue = destination[scopeName]) : destination[scopeName] = parentValue), 
                            lastValue = parentValue;
                        };
                        parentValueWatch.$stateful = !0;
                        var unwatch;
                        unwatch = definition.collection ? scope.$watchCollection(attrs[attrName], parentValueWatch) : scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal), 
                        onNewScopeDestroyed = onNewScopeDestroyed || [], onNewScopeDestroyed.push(unwatch);
                        break;

                      case "&":
                        if (parentGet = $parse(attrs[attrName]), parentGet === noop && optional) break;
                        destination[scopeName] = function(locals) {
                            return parentGet(scope, locals);
                        };
                    }
                });
                var destroyBindings = onNewScopeDestroyed ? function() {
                    for (var i = 0, ii = onNewScopeDestroyed.length; ii > i; ++i) onNewScopeDestroyed[i]();
                } : noop;
                return newScope && destroyBindings !== noop ? (newScope.$on("$destroy", destroyBindings), 
                noop) : destroyBindings;
            }
            var Attributes = function(element, attributesToCopy) {
                if (attributesToCopy) {
                    var i, l, key, keys = Object.keys(attributesToCopy);
                    for (i = 0, l = keys.length; l > i; i++) key = keys[i], this[key] = attributesToCopy[key];
                } else this.$attr = {};
                this.$$element = element;
            };
            Attributes.prototype = {
                $normalize: directiveNormalize,
                $addClass: function(classVal) {
                    classVal && classVal.length > 0 && $animate.addClass(this.$$element, classVal);
                },
                $removeClass: function(classVal) {
                    classVal && classVal.length > 0 && $animate.removeClass(this.$$element, classVal);
                },
                $updateClass: function(newClasses, oldClasses) {
                    var toAdd = tokenDifference(newClasses, oldClasses);
                    toAdd && toAdd.length && $animate.addClass(this.$$element, toAdd);
                    var toRemove = tokenDifference(oldClasses, newClasses);
                    toRemove && toRemove.length && $animate.removeClass(this.$$element, toRemove);
                },
                $set: function(key, value, writeAttr, attrName) {
                    var nodeName, node = this.$$element[0], booleanKey = getBooleanAttrName(node, key), aliasedKey = getAliasedAttrName(node, key), observer = key;
                    if (booleanKey ? (this.$$element.prop(key, value), attrName = booleanKey) : aliasedKey && (this[aliasedKey] = value, 
                    observer = aliasedKey), this[key] = value, attrName ? this.$attr[key] = attrName : (attrName = this.$attr[key], 
                    attrName || (this.$attr[key] = attrName = snake_case(key, "-"))), nodeName = nodeName_(this.$$element), 
                    "a" === nodeName && "href" === key || "img" === nodeName && "src" === key) this[key] = value = $$sanitizeUri(value, "src" === key); else if ("img" === nodeName && "srcset" === key) {
                        for (var result = "", trimmedSrcset = trim(value), srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/, pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/, rawUris = trimmedSrcset.split(pattern), nbrUrisWith2parts = Math.floor(rawUris.length / 2), i = 0; nbrUrisWith2parts > i; i++) {
                            var innerIdx = 2 * i;
                            result += $$sanitizeUri(trim(rawUris[innerIdx]), !0), result += " " + trim(rawUris[innerIdx + 1]);
                        }
                        var lastTuple = trim(rawUris[2 * i]).split(/\s/);
                        result += $$sanitizeUri(trim(lastTuple[0]), !0), 2 === lastTuple.length && (result += " " + trim(lastTuple[1])), 
                        this[key] = value = result;
                    }
                    writeAttr !== !1 && (null === value || value === undefined ? this.$$element.removeAttr(attrName) : this.$$element.attr(attrName, value));
                    var $$observers = this.$$observers;
                    $$observers && forEach($$observers[observer], function(fn) {
                        try {
                            fn(value);
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    });
                },
                $observe: function(key, fn) {
                    var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = createMap()), listeners = $$observers[key] || ($$observers[key] = []);
                    return listeners.push(fn), $rootScope.$evalAsync(function() {
                        !listeners.$$inter && attrs.hasOwnProperty(key) && fn(attrs[key]);
                    }), function() {
                        arrayRemove(listeners, fn);
                    };
                }
            };
            var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = "{{" == startSymbol || "}}" == endSymbol ? identity : function(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
            }, NG_ATTR_BINDING = /^ngAttr[A-Z]/;
            return compile.$$addBindingInfo = debugInfoEnabled ? function($element, binding) {
                var bindings = $element.data("$binding") || [];
                isArray(binding) ? bindings = bindings.concat(binding) : bindings.push(binding), 
                $element.data("$binding", bindings);
            } : noop, compile.$$addBindingClass = debugInfoEnabled ? function($element) {
                safeAddClass($element, "ng-binding");
            } : noop, compile.$$addScopeInfo = debugInfoEnabled ? function($element, scope, isolated, noTemplate) {
                var dataName = isolated ? noTemplate ? "$isolateScopeNoTemplate" : "$isolateScope" : "$scope";
                $element.data(dataName, scope);
            } : noop, compile.$$addScopeClass = debugInfoEnabled ? function($element, isolated) {
                safeAddClass($element, isolated ? "ng-isolate-scope" : "ng-scope");
            } : noop, compile;
        } ];
    }
    function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ""));
    }
    function tokenDifference(str1, str2) {
        var values = "", tokens1 = str1.split(/\s+/), tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
            for (var token = tokens1[i], j = 0; j < tokens2.length; j++) if (token == tokens2[j]) continue outer;
            values += (values.length > 0 ? " " : "") + token;
        }
        return values;
    }
    function removeComments(jqNodes) {
        jqNodes = jqLite(jqNodes);
        var i = jqNodes.length;
        if (1 >= i) return jqNodes;
        for (;i--; ) {
            var node = jqNodes[i];
            node.nodeType === NODE_TYPE_COMMENT && splice.call(jqNodes, i, 1);
        }
        return jqNodes;
    }
    function identifierForController(controller, ident) {
        if (ident && isString(ident)) return ident;
        if (isString(controller)) {
            var match = CNTRL_REG.exec(controller);
            if (match) return match[3];
        }
    }
    function $ControllerProvider() {
        var controllers = {}, globals = !1;
        this.register = function(name, constructor) {
            assertNotHasOwnProperty(name, "controller"), isObject(name) ? extend(controllers, name) : controllers[name] = constructor;
        }, this.allowGlobals = function() {
            globals = !0;
        }, this.$get = [ "$injector", "$window", function($injector, $window) {
            function addIdentifier(locals, identifier, instance, name) {
                if (!locals || !isObject(locals.$scope)) throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
                locals.$scope[identifier] = instance;
            }
            return function(expression, locals, later, ident) {
                var instance, match, constructor, identifier;
                if (later = later === !0, ident && isString(ident) && (identifier = ident), isString(expression)) {
                    if (match = expression.match(CNTRL_REG), !match) throw $controllerMinErr("ctrlfmt", "Badly formed controller string '{0}'. Must match `__name__ as __id__` or `__name__`.", expression);
                    constructor = match[1], identifier = identifier || match[3], expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, !0) || (globals ? getter($window, constructor, !0) : undefined), 
                    assertArgFn(expression, constructor, !0);
                }
                if (later) {
                    var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
                    instance = Object.create(controllerPrototype || null), identifier && addIdentifier(locals, identifier, instance, constructor || expression.name);
                    var instantiate;
                    return instantiate = extend(function() {
                        var result = $injector.invoke(expression, instance, locals, constructor);
                        return result !== instance && (isObject(result) || isFunction(result)) && (instance = result, 
                        identifier && addIdentifier(locals, identifier, instance, constructor || expression.name)), 
                        instance;
                    }, {
                        instance: instance,
                        identifier: identifier
                    });
                }
                return instance = $injector.instantiate(expression, locals, constructor), identifier && addIdentifier(locals, identifier, instance, constructor || expression.name), 
                instance;
            };
        } ];
    }
    function $DocumentProvider() {
        this.$get = [ "$window", function(window) {
            return jqLite(window.document);
        } ];
    }
    function $ExceptionHandlerProvider() {
        this.$get = [ "$log", function($log) {
            return function(exception, cause) {
                $log.error.apply($log, arguments);
            };
        } ];
    }
    function serializeValue(v) {
        return isObject(v) ? isDate(v) ? v.toISOString() : toJson(v) : v;
    }
    function $HttpParamSerializerProvider() {
        this.$get = function() {
            return function(params) {
                if (!params) return "";
                var parts = [];
                return forEachSorted(params, function(value, key) {
                    null === value || isUndefined(value) || (isArray(value) ? forEach(value, function(v, k) {
                        parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(v)));
                    }) : parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(value))));
                }), parts.join("&");
            };
        };
    }
    function $HttpParamSerializerJQLikeProvider() {
        this.$get = function() {
            return function(params) {
                function serialize(toSerialize, prefix, topLevel) {
                    null === toSerialize || isUndefined(toSerialize) || (isArray(toSerialize) ? forEach(toSerialize, function(value) {
                        serialize(value, prefix + "[]");
                    }) : isObject(toSerialize) && !isDate(toSerialize) ? forEachSorted(toSerialize, function(value, key) {
                        serialize(value, prefix + (topLevel ? "" : "[") + key + (topLevel ? "" : "]"));
                    }) : parts.push(encodeUriQuery(prefix) + "=" + encodeUriQuery(serializeValue(toSerialize))));
                }
                if (!params) return "";
                var parts = [];
                return serialize(params, "", !0), parts.join("&");
            };
        };
    }
    function defaultHttpResponseTransform(data, headers) {
        if (isString(data)) {
            var tempData = data.replace(JSON_PROTECTION_PREFIX, "").trim();
            if (tempData) {
                var contentType = headers("Content-Type");
                (contentType && 0 === contentType.indexOf(APPLICATION_JSON) || isJsonLike(tempData)) && (data = fromJson(tempData));
            }
        }
        return data;
    }
    function isJsonLike(str) {
        var jsonStart = str.match(JSON_START);
        return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
    }
    function parseHeaders(headers) {
        function fillInParsed(key, val) {
            key && (parsed[key] = parsed[key] ? parsed[key] + ", " + val : val);
        }
        var i, parsed = createMap();
        return isString(headers) ? forEach(headers.split("\n"), function(line) {
            i = line.indexOf(":"), fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
        }) : isObject(headers) && forEach(headers, function(headerVal, headerKey) {
            fillInParsed(lowercase(headerKey), trim(headerVal));
        }), parsed;
    }
    function headersGetter(headers) {
        var headersObj;
        return function(name) {
            if (headersObj || (headersObj = parseHeaders(headers)), name) {
                var value = headersObj[lowercase(name)];
                return void 0 === value && (value = null), value;
            }
            return headersObj;
        };
    }
    function transformData(data, headers, status, fns) {
        return isFunction(fns) ? fns(data, headers, status) : (forEach(fns, function(fn) {
            data = fn(data, headers, status);
        }), data);
    }
    function isSuccess(status) {
        return status >= 200 && 300 > status;
    }
    function $HttpProvider() {
        var defaults = this.defaults = {
            transformResponse: [ defaultHttpResponseTransform ],
            transformRequest: [ function(d) {
                return !isObject(d) || isFile(d) || isBlob(d) || isFormData(d) ? d : toJson(d);
            } ],
            headers: {
                common: {
                    Accept: "application/json, text/plain, */*"
                },
                post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
            },
            xsrfCookieName: "XSRF-TOKEN",
            xsrfHeaderName: "X-XSRF-TOKEN",
            paramSerializer: "$httpParamSerializer"
        }, useApplyAsync = !1;
        this.useApplyAsync = function(value) {
            return isDefined(value) ? (useApplyAsync = !!value, this) : useApplyAsync;
        };
        var interceptorFactories = this.interceptors = [];
        this.$get = [ "$httpBackend", "$$cookieReader", "$cacheFactory", "$rootScope", "$q", "$injector", function($httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) {
            function $http(requestConfig) {
                function transformResponse(response) {
                    var resp = extend({}, response);
                    return response.data ? resp.data = transformData(response.data, response.headers, response.status, config.transformResponse) : resp.data = response.data, 
                    isSuccess(response.status) ? resp : $q.reject(resp);
                }
                function executeHeaderFns(headers, config) {
                    var headerContent, processedHeaders = {};
                    return forEach(headers, function(headerFn, header) {
                        isFunction(headerFn) ? (headerContent = headerFn(config), null != headerContent && (processedHeaders[header] = headerContent)) : processedHeaders[header] = headerFn;
                    }), processedHeaders;
                }
                function mergeHeaders(config) {
                    var defHeaderName, lowercaseDefHeaderName, reqHeaderName, defHeaders = defaults.headers, reqHeaders = extend({}, config.headers);
                    defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
                    defaultHeadersIteration: for (defHeaderName in defHeaders) {
                        lowercaseDefHeaderName = lowercase(defHeaderName);
                        for (reqHeaderName in reqHeaders) if (lowercase(reqHeaderName) === lowercaseDefHeaderName) continue defaultHeadersIteration;
                        reqHeaders[defHeaderName] = defHeaders[defHeaderName];
                    }
                    return executeHeaderFns(reqHeaders, shallowCopy(config));
                }
                if (!angular.isObject(requestConfig)) throw minErr("$http")("badreq", "Http request configuration must be an object.  Received: {0}", requestConfig);
                var config = extend({
                    method: "get",
                    transformRequest: defaults.transformRequest,
                    transformResponse: defaults.transformResponse,
                    paramSerializer: defaults.paramSerializer
                }, requestConfig);
                config.headers = mergeHeaders(requestConfig), config.method = uppercase(config.method), 
                config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer;
                var serverRequest = function(config) {
                    var headers = config.headers, reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
                    return isUndefined(reqData) && forEach(headers, function(value, header) {
                        "content-type" === lowercase(header) && delete headers[header];
                    }), isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials) && (config.withCredentials = defaults.withCredentials), 
                    sendReq(config, reqData).then(transformResponse, transformResponse);
                }, chain = [ serverRequest, undefined ], promise = $q.when(config);
                for (forEach(reversedInterceptors, function(interceptor) {
                    (interceptor.request || interceptor.requestError) && chain.unshift(interceptor.request, interceptor.requestError), 
                    (interceptor.response || interceptor.responseError) && chain.push(interceptor.response, interceptor.responseError);
                }); chain.length; ) {
                    var thenFn = chain.shift(), rejectFn = chain.shift();
                    promise = promise.then(thenFn, rejectFn);
                }
                return promise.success = function(fn) {
                    return assertArgFn(fn, "fn"), promise.then(function(response) {
                        fn(response.data, response.status, response.headers, config);
                    }), promise;
                }, promise.error = function(fn) {
                    return assertArgFn(fn, "fn"), promise.then(null, function(response) {
                        fn(response.data, response.status, response.headers, config);
                    }), promise;
                }, promise;
            }
            function createShortMethods(names) {
                forEach(arguments, function(name) {
                    $http[name] = function(url, config) {
                        return $http(extend({}, config || {}, {
                            method: name,
                            url: url
                        }));
                    };
                });
            }
            function createShortMethodsWithData(name) {
                forEach(arguments, function(name) {
                    $http[name] = function(url, data, config) {
                        return $http(extend({}, config || {}, {
                            method: name,
                            url: url,
                            data: data
                        }));
                    };
                });
            }
            function sendReq(config, reqData) {
                function done(status, response, headersString, statusText) {
                    function resolveHttpPromise() {
                        resolvePromise(response, status, headersString, statusText);
                    }
                    cache && (isSuccess(status) ? cache.put(url, [ status, response, parseHeaders(headersString), statusText ]) : cache.remove(url)), 
                    useApplyAsync ? $rootScope.$applyAsync(resolveHttpPromise) : (resolveHttpPromise(), 
                    $rootScope.$$phase || $rootScope.$apply());
                }
                function resolvePromise(response, status, headers, statusText) {
                    status = Math.max(status, 0), (isSuccess(status) ? deferred.resolve : deferred.reject)({
                        data: response,
                        status: status,
                        headers: headersGetter(headers),
                        config: config,
                        statusText: statusText
                    });
                }
                function resolvePromiseWithResult(result) {
                    resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
                }
                function removePendingReq() {
                    var idx = $http.pendingRequests.indexOf(config);
                    -1 !== idx && $http.pendingRequests.splice(idx, 1);
                }
                var cache, cachedResp, deferred = $q.defer(), promise = deferred.promise, reqHeaders = config.headers, url = buildUrl(config.url, config.paramSerializer(config.params));
                if ($http.pendingRequests.push(config), promise.then(removePendingReq, removePendingReq), 
                !config.cache && !defaults.cache || config.cache === !1 || "GET" !== config.method && "JSONP" !== config.method || (cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache), 
                cache && (cachedResp = cache.get(url), isDefined(cachedResp) ? isPromiseLike(cachedResp) ? cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult) : isArray(cachedResp) ? resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]) : resolvePromise(cachedResp, 200, {}, "OK") : cache.put(url, promise)), 
                isUndefined(cachedResp)) {
                    var xsrfValue = urlIsSameOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
                    xsrfValue && (reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue), 
                    $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType);
                }
                return promise;
            }
            function buildUrl(url, serializedParams) {
                return serializedParams.length > 0 && (url += (-1 == url.indexOf("?") ? "?" : "&") + serializedParams), 
                url;
            }
            var defaultCache = $cacheFactory("$http");
            defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
            var reversedInterceptors = [];
            return forEach(interceptorFactories, function(interceptorFactory) {
                reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
            }), $http.pendingRequests = [], createShortMethods("get", "delete", "head", "jsonp"), 
            createShortMethodsWithData("post", "put", "patch"), $http.defaults = defaults, $http;
        } ];
    }
    function createXhr() {
        return new window.XMLHttpRequest();
    }
    function $HttpBackendProvider() {
        this.$get = [ "$browser", "$window", "$document", function($browser, $window, $document) {
            return createHttpBackend($browser, createXhr, $browser.defer, $window.angular.callbacks, $document[0]);
        } ];
    }
    function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        function jsonpReq(url, callbackId, done) {
            var script = rawDocument.createElement("script"), callback = null;
            return script.type = "text/javascript", script.src = url, script.async = !0, callback = function(event) {
                removeEventListenerFn(script, "load", callback), removeEventListenerFn(script, "error", callback), 
                rawDocument.body.removeChild(script), script = null;
                var status = -1, text = "unknown";
                event && ("load" !== event.type || callbacks[callbackId].called || (event = {
                    type: "error"
                }), text = event.type, status = "error" === event.type ? 404 : 200), done && done(status, text);
            }, addEventListenerFn(script, "load", callback), addEventListenerFn(script, "error", callback), 
            rawDocument.body.appendChild(script), callback;
        }
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
            function timeoutRequest() {
                jsonpDone && jsonpDone(), xhr && xhr.abort();
            }
            function completeRequest(callback, status, response, headersString, statusText) {
                timeoutId !== undefined && $browserDefer.cancel(timeoutId), jsonpDone = xhr = null, 
                callback(status, response, headersString, statusText), $browser.$$completeOutstandingRequest(noop);
            }
            if ($browser.$$incOutstandingRequestCount(), url = url || $browser.url(), "jsonp" == lowercase(method)) {
                var callbackId = "_" + (callbacks.counter++).toString(36);
                callbacks[callbackId] = function(data) {
                    callbacks[callbackId].data = data, callbacks[callbackId].called = !0;
                };
                var jsonpDone = jsonpReq(url.replace("JSON_CALLBACK", "angular.callbacks." + callbackId), callbackId, function(status, text) {
                    completeRequest(callback, status, callbacks[callbackId].data, "", text), callbacks[callbackId] = noop;
                });
            } else {
                var xhr = createXhr();
                xhr.open(method, url, !0), forEach(headers, function(value, key) {
                    isDefined(value) && xhr.setRequestHeader(key, value);
                }), xhr.onload = function() {
                    var statusText = xhr.statusText || "", response = "response" in xhr ? xhr.response : xhr.responseText, status = 1223 === xhr.status ? 204 : xhr.status;
                    0 === status && (status = response ? 200 : "file" == urlResolve(url).protocol ? 404 : 0), 
                    completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
                };
                var requestError = function() {
                    completeRequest(callback, -1, null, null, "");
                };
                if (xhr.onerror = requestError, xhr.onabort = requestError, withCredentials && (xhr.withCredentials = !0), 
                responseType) try {
                    xhr.responseType = responseType;
                } catch (e) {
                    if ("json" !== responseType) throw e;
                }
                xhr.send(post);
            }
            if (timeout > 0) var timeoutId = $browserDefer(timeoutRequest, timeout); else isPromiseLike(timeout) && timeout.then(timeoutRequest);
        };
    }
    function $InterpolateProvider() {
        var startSymbol = "{{", endSymbol = "}}";
        this.startSymbol = function(value) {
            return value ? (startSymbol = value, this) : startSymbol;
        }, this.endSymbol = function(value) {
            return value ? (endSymbol = value, this) : endSymbol;
        }, this.$get = [ "$parse", "$exceptionHandler", "$sce", function($parse, $exceptionHandler, $sce) {
            function escape(ch) {
                return "\\\\\\" + ch;
            }
            function unescapeText(text) {
                return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
            }
            function stringify(value) {
                if (null == value) return "";
                switch (typeof value) {
                  case "string":
                    break;

                  case "number":
                    value = "" + value;
                    break;

                  default:
                    value = toJson(value);
                }
                return value;
            }
            function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
                function parseStringifyInterceptor(value) {
                    try {
                        return value = getValue(value), allOrNothing && !isDefined(value) ? value : stringify(value);
                    } catch (err) {
                        $exceptionHandler($interpolateMinErr.interr(text, err));
                    }
                }
                allOrNothing = !!allOrNothing;
                for (var startIndex, endIndex, exp, index = 0, expressions = [], parseFns = [], textLength = text.length, concat = [], expressionPositions = []; textLength > index; ) {
                    if (-1 == (startIndex = text.indexOf(startSymbol, index)) || -1 == (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength))) {
                        index !== textLength && concat.push(unescapeText(text.substring(index)));
                        break;
                    }
                    index !== startIndex && concat.push(unescapeText(text.substring(index, startIndex))), 
                    exp = text.substring(startIndex + startSymbolLength, endIndex), expressions.push(exp), 
                    parseFns.push($parse(exp, parseStringifyInterceptor)), index = endIndex + endSymbolLength, 
                    expressionPositions.push(concat.length), concat.push("");
                }
                if (trustedContext && concat.length > 1 && $interpolateMinErr.throwNoconcat(text), 
                !mustHaveExpression || expressions.length) {
                    var compute = function(values) {
                        for (var i = 0, ii = expressions.length; ii > i; i++) {
                            if (allOrNothing && isUndefined(values[i])) return;
                            concat[expressionPositions[i]] = values[i];
                        }
                        return concat.join("");
                    }, getValue = function(value) {
                        return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
                    };
                    return extend(function(context) {
                        var i = 0, ii = expressions.length, values = new Array(ii);
                        try {
                            for (;ii > i; i++) values[i] = parseFns[i](context);
                            return compute(values);
                        } catch (err) {
                            $exceptionHandler($interpolateMinErr.interr(text, err));
                        }
                    }, {
                        exp: text,
                        expressions: expressions,
                        $$watchDelegate: function(scope, listener) {
                            var lastValue;
                            return scope.$watchGroup(parseFns, function(values, oldValues) {
                                var currValue = compute(values);
                                isFunction(listener) && listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope), 
                                lastValue = currValue;
                            });
                        }
                    });
                }
            }
            var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length, escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), "g"), escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), "g");
            return $interpolate.startSymbol = function() {
                return startSymbol;
            }, $interpolate.endSymbol = function() {
                return endSymbol;
            }, $interpolate;
        } ];
    }
    function $IntervalProvider() {
        this.$get = [ "$rootScope", "$window", "$q", "$$q", function($rootScope, $window, $q, $$q) {
            function interval(fn, delay, count, invokeApply) {
                var hasParams = arguments.length > 4, args = hasParams ? sliceArgs(arguments, 4) : [], setInterval = $window.setInterval, clearInterval = $window.clearInterval, iteration = 0, skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                return count = isDefined(count) ? count : 0, promise.then(null, null, hasParams ? function() {
                    fn.apply(null, args);
                } : fn), promise.$$intervalId = setInterval(function() {
                    deferred.notify(iteration++), count > 0 && iteration >= count && (deferred.resolve(iteration), 
                    clearInterval(promise.$$intervalId), delete intervals[promise.$$intervalId]), skipApply || $rootScope.$apply();
                }, delay), intervals[promise.$$intervalId] = deferred, promise;
            }
            var intervals = {};
            return interval.cancel = function(promise) {
                return promise && promise.$$intervalId in intervals ? (intervals[promise.$$intervalId].reject("canceled"), 
                $window.clearInterval(promise.$$intervalId), delete intervals[promise.$$intervalId], 
                !0) : !1;
            }, interval;
        } ];
    }
    function $LocaleProvider() {
        this.$get = function() {
            return {
                id: "en-us",
                NUMBER_FORMATS: {
                    DECIMAL_SEP: ".",
                    GROUP_SEP: ",",
                    PATTERNS: [ {
                        minInt: 1,
                        minFrac: 0,
                        maxFrac: 3,
                        posPre: "",
                        posSuf: "",
                        negPre: "-",
                        negSuf: "",
                        gSize: 3,
                        lgSize: 3
                    }, {
                        minInt: 1,
                        minFrac: 2,
                        maxFrac: 2,
                        posPre: "¤",
                        posSuf: "",
                        negPre: "(¤",
                        negSuf: ")",
                        gSize: 3,
                        lgSize: 3
                    } ],
                    CURRENCY_SYM: "$"
                },
                DATETIME_FORMATS: {
                    MONTH: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
                    SHORTMONTH: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
                    DAY: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
                    SHORTDAY: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(","),
                    AMPMS: [ "AM", "PM" ],
                    medium: "MMM d, y h:mm:ss a",
                    "short": "M/d/yy h:mm a",
                    fullDate: "EEEE, MMMM d, y",
                    longDate: "MMMM d, y",
                    mediumDate: "MMM d, y",
                    shortDate: "M/d/yy",
                    mediumTime: "h:mm:ss a",
                    shortTime: "h:mm a",
                    ERANAMES: [ "Before Christ", "Anno Domini" ],
                    ERAS: [ "BC", "AD" ]
                },
                pluralCat: function(num) {
                    return 1 === num ? "one" : "other";
                }
            };
        };
    }
    function encodePath(path) {
        for (var segments = path.split("/"), i = segments.length; i--; ) segments[i] = encodeUriSegment(segments[i]);
        return segments.join("/");
    }
    function parseAbsoluteUrl(absoluteUrl, locationObj) {
        var parsedUrl = urlResolve(absoluteUrl);
        locationObj.$$protocol = parsedUrl.protocol, locationObj.$$host = parsedUrl.hostname, 
        locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
    }
    function parseAppUrl(relativeUrl, locationObj) {
        var prefixed = "/" !== relativeUrl.charAt(0);
        prefixed && (relativeUrl = "/" + relativeUrl);
        var match = urlResolve(relativeUrl);
        locationObj.$$path = decodeURIComponent(prefixed && "/" === match.pathname.charAt(0) ? match.pathname.substring(1) : match.pathname), 
        locationObj.$$search = parseKeyValue(match.search), locationObj.$$hash = decodeURIComponent(match.hash), 
        locationObj.$$path && "/" != locationObj.$$path.charAt(0) && (locationObj.$$path = "/" + locationObj.$$path);
    }
    function beginsWith(begin, whole) {
        return 0 === whole.indexOf(begin) ? whole.substr(begin.length) : void 0;
    }
    function stripHash(url) {
        var index = url.indexOf("#");
        return -1 == index ? url : url.substr(0, index);
    }
    function trimEmptyHash(url) {
        return url.replace(/(#.+)|#$/, "$1");
    }
    function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf("/") + 1);
    }
    function serverBase(url) {
        return url.substring(0, url.indexOf("/", url.indexOf("//") + 2));
    }
    function LocationHtml5Url(appBase, basePrefix) {
        this.$$html5 = !0, basePrefix = basePrefix || "";
        var appBaseNoFile = stripFile(appBase);
        parseAbsoluteUrl(appBase, this), this.$$parse = function(url) {
            var pathUrl = beginsWith(appBaseNoFile, url);
            if (!isString(pathUrl)) throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
            parseAppUrl(pathUrl, this), this.$$path || (this.$$path = "/"), this.$$compose();
        }, this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
        }, this.$$parseLinkUrl = function(url, relHref) {
            if (relHref && "#" === relHref[0]) return this.hash(relHref.slice(1)), !0;
            var appUrl, prevAppUrl, rewrittenUrl;
            return (appUrl = beginsWith(appBase, url)) !== undefined ? (prevAppUrl = appUrl, 
            rewrittenUrl = (appUrl = beginsWith(basePrefix, appUrl)) !== undefined ? appBaseNoFile + (beginsWith("/", appUrl) || appUrl) : appBase + prevAppUrl) : (appUrl = beginsWith(appBaseNoFile, url)) !== undefined ? rewrittenUrl = appBaseNoFile + appUrl : appBaseNoFile == url + "/" && (rewrittenUrl = appBaseNoFile), 
            rewrittenUrl && this.$$parse(rewrittenUrl), !!rewrittenUrl;
        };
    }
    function LocationHashbangUrl(appBase, hashPrefix) {
        var appBaseNoFile = stripFile(appBase);
        parseAbsoluteUrl(appBase, this), this.$$parse = function(url) {
            function removeWindowsDriveName(path, url, base) {
                var firstPathSegmentMatch, windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
                return 0 === url.indexOf(base) && (url = url.replace(base, "")), windowsFilePathExp.exec(url) ? path : (firstPathSegmentMatch = windowsFilePathExp.exec(path), 
                firstPathSegmentMatch ? firstPathSegmentMatch[1] : path);
            }
            var withoutHashUrl, withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
            isUndefined(withoutBaseUrl) || "#" !== withoutBaseUrl.charAt(0) ? this.$$html5 ? withoutHashUrl = withoutBaseUrl : (withoutHashUrl = "", 
            isUndefined(withoutBaseUrl) && (appBase = url, this.replace())) : (withoutHashUrl = beginsWith(hashPrefix, withoutBaseUrl), 
            isUndefined(withoutHashUrl) && (withoutHashUrl = withoutBaseUrl)), parseAppUrl(withoutHashUrl, this), 
            this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase), this.$$compose();
        }, this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : "");
        }, this.$$parseLinkUrl = function(url, relHref) {
            return stripHash(appBase) == stripHash(url) ? (this.$$parse(url), !0) : !1;
        };
    }
    function LocationHashbangInHtml5Url(appBase, hashPrefix) {
        this.$$html5 = !0, LocationHashbangUrl.apply(this, arguments);
        var appBaseNoFile = stripFile(appBase);
        this.$$parseLinkUrl = function(url, relHref) {
            if (relHref && "#" === relHref[0]) return this.hash(relHref.slice(1)), !0;
            var rewrittenUrl, appUrl;
            return appBase == stripHash(url) ? rewrittenUrl = url : (appUrl = beginsWith(appBaseNoFile, url)) ? rewrittenUrl = appBase + hashPrefix + appUrl : appBaseNoFile === url + "/" && (rewrittenUrl = appBaseNoFile), 
            rewrittenUrl && this.$$parse(rewrittenUrl), !!rewrittenUrl;
        }, this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBase + hashPrefix + this.$$url;
        };
    }
    function locationGetter(property) {
        return function() {
            return this[property];
        };
    }
    function locationGetterSetter(property, preprocess) {
        return function(value) {
            return isUndefined(value) ? this[property] : (this[property] = preprocess(value), 
            this.$$compose(), this);
        };
    }
    function $LocationProvider() {
        var hashPrefix = "", html5Mode = {
            enabled: !1,
            requireBase: !0,
            rewriteLinks: !0
        };
        this.hashPrefix = function(prefix) {
            return isDefined(prefix) ? (hashPrefix = prefix, this) : hashPrefix;
        }, this.html5Mode = function(mode) {
            return isBoolean(mode) ? (html5Mode.enabled = mode, this) : isObject(mode) ? (isBoolean(mode.enabled) && (html5Mode.enabled = mode.enabled), 
            isBoolean(mode.requireBase) && (html5Mode.requireBase = mode.requireBase), isBoolean(mode.rewriteLinks) && (html5Mode.rewriteLinks = mode.rewriteLinks), 
            this) : html5Mode;
        }, this.$get = [ "$rootScope", "$browser", "$sniffer", "$rootElement", "$window", function($rootScope, $browser, $sniffer, $rootElement, $window) {
            function setBrowserUrlWithFallback(url, replace, state) {
                var oldUrl = $location.url(), oldState = $location.$$state;
                try {
                    $browser.url(url, replace, state), $location.$$state = $browser.state();
                } catch (e) {
                    throw $location.url(oldUrl), $location.$$state = oldState, e;
                }
            }
            function afterLocationChange(oldUrl, oldState) {
                $rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl, $location.$$state, oldState);
            }
            var $location, LocationMode, appBase, baseHref = $browser.baseHref(), initialUrl = $browser.url();
            if (html5Mode.enabled) {
                if (!baseHref && html5Mode.requireBase) throw $locationMinErr("nobase", "$location in HTML5 mode requires a <base> tag to be present!");
                appBase = serverBase(initialUrl) + (baseHref || "/"), LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
            } else appBase = stripHash(initialUrl), LocationMode = LocationHashbangUrl;
            $location = new LocationMode(appBase, "#" + hashPrefix), $location.$$parseLinkUrl(initialUrl, initialUrl), 
            $location.$$state = $browser.state();
            var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
            $rootElement.on("click", function(event) {
                if (html5Mode.rewriteLinks && !event.ctrlKey && !event.metaKey && !event.shiftKey && 2 != event.which && 2 != event.button) {
                    for (var elm = jqLite(event.target); "a" !== nodeName_(elm[0]); ) if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
                    var absHref = elm.prop("href"), relHref = elm.attr("href") || elm.attr("xlink:href");
                    isObject(absHref) && "[object SVGAnimatedString]" === absHref.toString() && (absHref = urlResolve(absHref.animVal).href), 
                    IGNORE_URI_REGEXP.test(absHref) || !absHref || elm.attr("target") || event.isDefaultPrevented() || $location.$$parseLinkUrl(absHref, relHref) && (event.preventDefault(), 
                    $location.absUrl() != $browser.url() && ($rootScope.$apply(), $window.angular["ff-684208-preventDefault"] = !0));
                }
            }), trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl) && $browser.url($location.absUrl(), !0);
            var initializing = !0;
            return $browser.onUrlChange(function(newUrl, newState) {
                $rootScope.$evalAsync(function() {
                    var defaultPrevented, oldUrl = $location.absUrl(), oldState = $location.$$state;
                    $location.$$parse(newUrl), $location.$$state = newState, defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, newState, oldState).defaultPrevented, 
                    $location.absUrl() === newUrl && (defaultPrevented ? ($location.$$parse(oldUrl), 
                    $location.$$state = oldState, setBrowserUrlWithFallback(oldUrl, !1, oldState)) : (initializing = !1, 
                    afterLocationChange(oldUrl, oldState)));
                }), $rootScope.$$phase || $rootScope.$digest();
            }), $rootScope.$watch(function() {
                var oldUrl = trimEmptyHash($browser.url()), newUrl = trimEmptyHash($location.absUrl()), oldState = $browser.state(), currentReplace = $location.$$replace, urlOrStateChanged = oldUrl !== newUrl || $location.$$html5 && $sniffer.history && oldState !== $location.$$state;
                (initializing || urlOrStateChanged) && (initializing = !1, $rootScope.$evalAsync(function() {
                    var newUrl = $location.absUrl(), defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                    $location.absUrl() === newUrl && (defaultPrevented ? ($location.$$parse(oldUrl), 
                    $location.$$state = oldState) : (urlOrStateChanged && setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state), 
                    afterLocationChange(oldUrl, oldState)));
                })), $location.$$replace = !1;
            }), $location;
        } ];
    }
    function $LogProvider() {
        var debug = !0, self = this;
        this.debugEnabled = function(flag) {
            return isDefined(flag) ? (debug = flag, this) : debug;
        }, this.$get = [ "$window", function($window) {
            function formatError(arg) {
                return arg instanceof Error && (arg.stack ? arg = arg.message && -1 === arg.stack.indexOf(arg.message) ? "Error: " + arg.message + "\n" + arg.stack : arg.stack : arg.sourceURL && (arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line)), 
                arg;
            }
            function consoleLog(type) {
                var console = $window.console || {}, logFn = console[type] || console.log || noop, hasApply = !1;
                try {
                    hasApply = !!logFn.apply;
                } catch (e) {}
                return hasApply ? function() {
                    var args = [];
                    return forEach(arguments, function(arg) {
                        args.push(formatError(arg));
                    }), logFn.apply(console, args);
                } : function(arg1, arg2) {
                    logFn(arg1, null == arg2 ? "" : arg2);
                };
            }
            return {
                log: consoleLog("log"),
                info: consoleLog("info"),
                warn: consoleLog("warn"),
                error: consoleLog("error"),
                debug: function() {
                    var fn = consoleLog("debug");
                    return function() {
                        debug && fn.apply(self, arguments);
                    };
                }()
            };
        } ];
    }
    function ensureSafeMemberName(name, fullExpression) {
        if ("__defineGetter__" === name || "__defineSetter__" === name || "__lookupGetter__" === name || "__lookupSetter__" === name || "__proto__" === name) throw $parseMinErr("isecfld", "Attempting to access a disallowed field in Angular expressions! Expression: {0}", fullExpression);
        return name;
    }
    function ensureSafeObject(obj, fullExpression) {
        if (obj) {
            if (obj.constructor === obj) throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
            if (obj.window === obj) throw $parseMinErr("isecwindow", "Referencing the Window in Angular expressions is disallowed! Expression: {0}", fullExpression);
            if (obj.children && (obj.nodeName || obj.prop && obj.attr && obj.find)) throw $parseMinErr("isecdom", "Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}", fullExpression);
            if (obj === Object) throw $parseMinErr("isecobj", "Referencing Object in Angular expressions is disallowed! Expression: {0}", fullExpression);
        }
        return obj;
    }
    function ensureSafeFunction(obj, fullExpression) {
        if (obj) {
            if (obj.constructor === obj) throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
            if (obj === CALL || obj === APPLY || obj === BIND) throw $parseMinErr("isecff", "Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}", fullExpression);
        }
    }
    function ifDefined(v, d) {
        return "undefined" != typeof v ? v : d;
    }
    function plusFn(l, r) {
        return "undefined" == typeof l ? r : "undefined" == typeof r ? l : l + r;
    }
    function isStateless($filter, filterName) {
        var fn = $filter(filterName);
        return !fn.$stateful;
    }
    function findConstantAndWatchExpressions(ast, $filter) {
        var allConstants, argsToWatch;
        switch (ast.type) {
          case AST.Program:
            allConstants = !0, forEach(ast.body, function(expr) {
                findConstantAndWatchExpressions(expr.expression, $filter), allConstants = allConstants && expr.expression.constant;
            }), ast.constant = allConstants;
            break;

          case AST.Literal:
            ast.constant = !0, ast.toWatch = [];
            break;

          case AST.UnaryExpression:
            findConstantAndWatchExpressions(ast.argument, $filter), ast.constant = ast.argument.constant, 
            ast.toWatch = ast.argument.toWatch;
            break;

          case AST.BinaryExpression:
            findConstantAndWatchExpressions(ast.left, $filter), findConstantAndWatchExpressions(ast.right, $filter), 
            ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
            break;

          case AST.LogicalExpression:
            findConstantAndWatchExpressions(ast.left, $filter), findConstantAndWatchExpressions(ast.right, $filter), 
            ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = ast.constant ? [] : [ ast ];
            break;

          case AST.ConditionalExpression:
            findConstantAndWatchExpressions(ast.test, $filter), findConstantAndWatchExpressions(ast.alternate, $filter), 
            findConstantAndWatchExpressions(ast.consequent, $filter), ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant, 
            ast.toWatch = ast.constant ? [] : [ ast ];
            break;

          case AST.Identifier:
            ast.constant = !1, ast.toWatch = [ ast ];
            break;

          case AST.MemberExpression:
            findConstantAndWatchExpressions(ast.object, $filter), ast.computed && findConstantAndWatchExpressions(ast.property, $filter), 
            ast.constant = ast.object.constant && (!ast.computed || ast.property.constant), 
            ast.toWatch = [ ast ];
            break;

          case AST.CallExpression:
            allConstants = ast.filter ? isStateless($filter, ast.callee.name) : !1, argsToWatch = [], 
            forEach(ast.arguments, function(expr) {
                findConstantAndWatchExpressions(expr, $filter), allConstants = allConstants && expr.constant, 
                expr.constant || argsToWatch.push.apply(argsToWatch, expr.toWatch);
            }), ast.constant = allConstants, ast.toWatch = ast.filter && isStateless($filter, ast.callee.name) ? argsToWatch : [ ast ];
            break;

          case AST.AssignmentExpression:
            findConstantAndWatchExpressions(ast.left, $filter), findConstantAndWatchExpressions(ast.right, $filter), 
            ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = [ ast ];
            break;

          case AST.ArrayExpression:
            allConstants = !0, argsToWatch = [], forEach(ast.elements, function(expr) {
                findConstantAndWatchExpressions(expr, $filter), allConstants = allConstants && expr.constant, 
                expr.constant || argsToWatch.push.apply(argsToWatch, expr.toWatch);
            }), ast.constant = allConstants, ast.toWatch = argsToWatch;
            break;

          case AST.ObjectExpression:
            allConstants = !0, argsToWatch = [], forEach(ast.properties, function(property) {
                findConstantAndWatchExpressions(property.value, $filter), allConstants = allConstants && property.value.constant, 
                property.value.constant || argsToWatch.push.apply(argsToWatch, property.value.toWatch);
            }), ast.constant = allConstants, ast.toWatch = argsToWatch;
            break;

          case AST.ThisExpression:
            ast.constant = !1, ast.toWatch = [];
        }
    }
    function getInputs(body) {
        if (1 == body.length) {
            var lastExpression = body[0].expression, candidate = lastExpression.toWatch;
            return 1 !== candidate.length ? candidate : candidate[0] !== lastExpression ? candidate : undefined;
        }
    }
    function isAssignable(ast) {
        return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
    }
    function assignableAST(ast) {
        return 1 === ast.body.length && isAssignable(ast.body[0].expression) ? {
            type: AST.AssignmentExpression,
            left: ast.body[0].expression,
            right: {
                type: AST.NGValueParameter
            },
            operator: "="
        } : void 0;
    }
    function isLiteral(ast) {
        return 0 === ast.body.length || 1 === ast.body.length && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
    }
    function isConstant(ast) {
        return ast.constant;
    }
    function ASTCompiler(astBuilder, $filter) {
        this.astBuilder = astBuilder, this.$filter = $filter;
    }
    function ASTInterpreter(astBuilder, $filter) {
        this.astBuilder = astBuilder, this.$filter = $filter;
    }
    function setter(obj, path, setValue, fullExp) {
        ensureSafeObject(obj, fullExp);
        for (var key, element = path.split("."), i = 0; element.length > 1; i++) {
            key = ensureSafeMemberName(element.shift(), fullExp);
            var propertyObj = ensureSafeObject(obj[key], fullExp);
            propertyObj || (propertyObj = {}, obj[key] = propertyObj), obj = propertyObj;
        }
        return key = ensureSafeMemberName(element.shift(), fullExp), ensureSafeObject(obj[key], fullExp), 
        obj[key] = setValue, setValue;
    }
    function isPossiblyDangerousMemberName(name) {
        return "constructor" == name;
    }
    function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
    }
    function $ParseProvider() {
        var cacheDefault = createMap(), cacheExpensive = createMap();
        this.$get = [ "$filter", "$sniffer", function($filter, $sniffer) {
            function expressionInputDirtyCheck(newValue, oldValueOfValue) {
                return null == newValue || null == oldValueOfValue ? newValue === oldValueOfValue : "object" == typeof newValue && (newValue = getValueOf(newValue), 
                "object" == typeof newValue) ? !1 : newValue === oldValueOfValue || newValue !== newValue && oldValueOfValue !== oldValueOfValue;
            }
            function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                var lastResult, inputExpressions = parsedExpression.inputs;
                if (1 === inputExpressions.length) {
                    var oldInputValueOf = expressionInputDirtyCheck;
                    return inputExpressions = inputExpressions[0], scope.$watch(function(scope) {
                        var newInputValue = inputExpressions(scope);
                        return expressionInputDirtyCheck(newInputValue, oldInputValueOf) || (lastResult = parsedExpression(scope, undefined, undefined, [ newInputValue ]), 
                        oldInputValueOf = newInputValue && getValueOf(newInputValue)), lastResult;
                    }, listener, objectEquality, prettyPrintExpression);
                }
                for (var oldInputValueOfValues = [], oldInputValues = [], i = 0, ii = inputExpressions.length; ii > i; i++) oldInputValueOfValues[i] = expressionInputDirtyCheck, 
                oldInputValues[i] = null;
                return scope.$watch(function(scope) {
                    for (var changed = !1, i = 0, ii = inputExpressions.length; ii > i; i++) {
                        var newInputValue = inputExpressions[i](scope);
                        (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) && (oldInputValues[i] = newInputValue, 
                        oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue));
                    }
                    return changed && (lastResult = parsedExpression(scope, undefined, undefined, oldInputValues)), 
                    lastResult;
                }, listener, objectEquality, prettyPrintExpression);
            }
            function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var unwatch, lastValue;
                return unwatch = scope.$watch(function(scope) {
                    return parsedExpression(scope);
                }, function(value, old, scope) {
                    lastValue = value, isFunction(listener) && listener.apply(this, arguments), isDefined(value) && scope.$$postDigest(function() {
                        isDefined(lastValue) && unwatch();
                    });
                }, objectEquality);
            }
            function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                function isAllDefined(value) {
                    var allDefined = !0;
                    return forEach(value, function(val) {
                        isDefined(val) || (allDefined = !1);
                    }), allDefined;
                }
                var unwatch, lastValue;
                return unwatch = scope.$watch(function(scope) {
                    return parsedExpression(scope);
                }, function(value, old, scope) {
                    lastValue = value, isFunction(listener) && listener.call(this, value, old, scope), 
                    isAllDefined(value) && scope.$$postDigest(function() {
                        isAllDefined(lastValue) && unwatch();
                    });
                }, objectEquality);
            }
            function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var unwatch;
                return unwatch = scope.$watch(function(scope) {
                    return parsedExpression(scope);
                }, function(value, old, scope) {
                    isFunction(listener) && listener.apply(this, arguments), unwatch();
                }, objectEquality);
            }
            function addInterceptor(parsedExpression, interceptorFn) {
                if (!interceptorFn) return parsedExpression;
                var watchDelegate = parsedExpression.$$watchDelegate, regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate, fn = regularWatch ? function(scope, locals, assign, inputs) {
                    var value = parsedExpression(scope, locals, assign, inputs);
                    return interceptorFn(value, scope, locals);
                } : function(scope, locals, assign, inputs) {
                    var value = parsedExpression(scope, locals, assign, inputs), result = interceptorFn(value, scope, locals);
                    return isDefined(value) ? result : value;
                };
                return parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate ? fn.$$watchDelegate = parsedExpression.$$watchDelegate : interceptorFn.$stateful || (fn.$$watchDelegate = inputsWatchDelegate, 
                fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [ parsedExpression ]), 
                fn;
            }
            var $parseOptions = {
                csp: $sniffer.csp,
                expensiveChecks: !1
            }, $parseOptionsExpensive = {
                csp: $sniffer.csp,
                expensiveChecks: !0
            };
            return function(exp, interceptorFn, expensiveChecks) {
                var parsedExpression, oneTime, cacheKey;
                switch (typeof exp) {
                  case "string":
                    exp = exp.trim(), cacheKey = exp;
                    var cache = expensiveChecks ? cacheExpensive : cacheDefault;
                    if (parsedExpression = cache[cacheKey], !parsedExpression) {
                        ":" === exp.charAt(0) && ":" === exp.charAt(1) && (oneTime = !0, exp = exp.substring(2));
                        var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions, lexer = new Lexer(parseOptions), parser = new Parser(lexer, $filter, parseOptions);
                        parsedExpression = parser.parse(exp), parsedExpression.constant ? parsedExpression.$$watchDelegate = constantWatchDelegate : oneTime ? parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate : parsedExpression.inputs && (parsedExpression.$$watchDelegate = inputsWatchDelegate), 
                        cache[cacheKey] = parsedExpression;
                    }
                    return addInterceptor(parsedExpression, interceptorFn);

                  case "function":
                    return addInterceptor(exp, interceptorFn);

                  default:
                    return noop;
                }
            };
        } ];
    }
    function $QProvider() {
        this.$get = [ "$rootScope", "$exceptionHandler", function($rootScope, $exceptionHandler) {
            return qFactory(function(callback) {
                $rootScope.$evalAsync(callback);
            }, $exceptionHandler);
        } ];
    }
    function $$QProvider() {
        this.$get = [ "$browser", "$exceptionHandler", function($browser, $exceptionHandler) {
            return qFactory(function(callback) {
                $browser.defer(callback);
            }, $exceptionHandler);
        } ];
    }
    function qFactory(nextTick, exceptionHandler) {
        function callOnce(self, resolveFn, rejectFn) {
            function wrap(fn) {
                return function(value) {
                    called || (called = !0, fn.call(self, value));
                };
            }
            var called = !1;
            return [ wrap(resolveFn), wrap(rejectFn) ];
        }
        function Promise() {
            this.$$state = {
                status: 0
            };
        }
        function simpleBind(context, fn) {
            return function(value) {
                fn.call(context, value);
            };
        }
        function processQueue(state) {
            var fn, deferred, pending;
            pending = state.pending, state.processScheduled = !1, state.pending = undefined;
            for (var i = 0, ii = pending.length; ii > i; ++i) {
                deferred = pending[i][0], fn = pending[i][state.status];
                try {
                    isFunction(fn) ? deferred.resolve(fn(state.value)) : 1 === state.status ? deferred.resolve(state.value) : deferred.reject(state.value);
                } catch (e) {
                    deferred.reject(e), exceptionHandler(e);
                }
            }
        }
        function scheduleProcessQueue(state) {
            !state.processScheduled && state.pending && (state.processScheduled = !0, nextTick(function() {
                processQueue(state);
            }));
        }
        function Deferred() {
            this.promise = new Promise(), this.resolve = simpleBind(this, this.resolve), this.reject = simpleBind(this, this.reject), 
            this.notify = simpleBind(this, this.notify);
        }
        function all(promises) {
            var deferred = new Deferred(), counter = 0, results = isArray(promises) ? [] : {};
            return forEach(promises, function(promise, key) {
                counter++, when(promise).then(function(value) {
                    results.hasOwnProperty(key) || (results[key] = value, --counter || deferred.resolve(results));
                }, function(reason) {
                    results.hasOwnProperty(key) || deferred.reject(reason);
                });
            }), 0 === counter && deferred.resolve(results), deferred.promise;
        }
        var $qMinErr = minErr("$q", TypeError), defer = function() {
            return new Deferred();
        };
        Promise.prototype = {
            then: function(onFulfilled, onRejected, progressBack) {
                var result = new Deferred();
                return this.$$state.pending = this.$$state.pending || [], this.$$state.pending.push([ result, onFulfilled, onRejected, progressBack ]), 
                this.$$state.status > 0 && scheduleProcessQueue(this.$$state), result.promise;
            },
            "catch": function(callback) {
                return this.then(null, callback);
            },
            "finally": function(callback, progressBack) {
                return this.then(function(value) {
                    return handleCallback(value, !0, callback);
                }, function(error) {
                    return handleCallback(error, !1, callback);
                }, progressBack);
            }
        }, Deferred.prototype = {
            resolve: function(val) {
                this.promise.$$state.status || (val === this.promise ? this.$$reject($qMinErr("qcycle", "Expected promise to be resolved with value other than itself '{0}'", val)) : this.$$resolve(val));
            },
            $$resolve: function(val) {
                var then, fns;
                fns = callOnce(this, this.$$resolve, this.$$reject);
                try {
                    (isObject(val) || isFunction(val)) && (then = val && val.then), isFunction(then) ? (this.promise.$$state.status = -1, 
                    then.call(val, fns[0], fns[1], this.notify)) : (this.promise.$$state.value = val, 
                    this.promise.$$state.status = 1, scheduleProcessQueue(this.promise.$$state));
                } catch (e) {
                    fns[1](e), exceptionHandler(e);
                }
            },
            reject: function(reason) {
                this.promise.$$state.status || this.$$reject(reason);
            },
            $$reject: function(reason) {
                this.promise.$$state.value = reason, this.promise.$$state.status = 2, scheduleProcessQueue(this.promise.$$state);
            },
            notify: function(progress) {
                var callbacks = this.promise.$$state.pending;
                this.promise.$$state.status <= 0 && callbacks && callbacks.length && nextTick(function() {
                    for (var callback, result, i = 0, ii = callbacks.length; ii > i; i++) {
                        result = callbacks[i][0], callback = callbacks[i][3];
                        try {
                            result.notify(isFunction(callback) ? callback(progress) : progress);
                        } catch (e) {
                            exceptionHandler(e);
                        }
                    }
                });
            }
        };
        var reject = function(reason) {
            var result = new Deferred();
            return result.reject(reason), result.promise;
        }, makePromise = function(value, resolved) {
            var result = new Deferred();
            return resolved ? result.resolve(value) : result.reject(value), result.promise;
        }, handleCallback = function(value, isResolved, callback) {
            var callbackOutput = null;
            try {
                isFunction(callback) && (callbackOutput = callback());
            } catch (e) {
                return makePromise(e, !1);
            }
            return isPromiseLike(callbackOutput) ? callbackOutput.then(function() {
                return makePromise(value, isResolved);
            }, function(error) {
                return makePromise(error, !1);
            }) : makePromise(value, isResolved);
        }, when = function(value, callback, errback, progressBack) {
            var result = new Deferred();
            return result.resolve(value), result.promise.then(callback, errback, progressBack);
        }, resolve = when, $Q = function Q(resolver) {
            function resolveFn(value) {
                deferred.resolve(value);
            }
            function rejectFn(reason) {
                deferred.reject(reason);
            }
            if (!isFunction(resolver)) throw $qMinErr("norslvr", "Expected resolverFn, got '{0}'", resolver);
            if (!(this instanceof Q)) return new Q(resolver);
            var deferred = new Deferred();
            return resolver(resolveFn, rejectFn), deferred.promise;
        };
        return $Q.defer = defer, $Q.reject = reject, $Q.when = when, $Q.resolve = resolve, 
        $Q.all = all, $Q;
    }
    function $$RAFProvider() {
        this.$get = [ "$window", "$timeout", function($window, $timeout) {
            function flush() {
                for (var i = 0; i < taskQueue.length; i++) {
                    var task = taskQueue[i];
                    task && (taskQueue[i] = null, task());
                }
                taskCount = taskQueue.length = 0;
            }
            function queueFn(asyncFn) {
                var index = taskQueue.length;
                return taskCount++, taskQueue.push(asyncFn), 0 === index && (cancelLastRAF = rafFn(flush)), 
                function() {
                    index >= 0 && (taskQueue[index] = null, index = null, 0 === --taskCount && cancelLastRAF && (cancelLastRAF(), 
                    cancelLastRAF = null, taskQueue.length = 0));
                };
            }
            var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame, cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame, rafSupported = !!requestAnimationFrame, rafFn = rafSupported ? function(fn) {
                var id = requestAnimationFrame(fn);
                return function() {
                    cancelAnimationFrame(id);
                };
            } : function(fn) {
                var timer = $timeout(fn, 16.66, !1);
                return function() {
                    $timeout.cancel(timer);
                };
            };
            queueFn.supported = rafSupported;
            var cancelLastRAF, taskCount = 0, taskQueue = [];
            return queueFn;
        } ];
    }
    function $RootScopeProvider() {
        function createChildScopeClass(parent) {
            function ChildScope() {
                this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null, 
                this.$$listeners = {}, this.$$listenerCount = {}, this.$$watchersCount = 0, this.$id = nextUid(), 
                this.$$ChildScope = null;
            }
            return ChildScope.prototype = parent, ChildScope;
        }
        var TTL = 10, $rootScopeMinErr = minErr("$rootScope"), lastDirtyWatch = null, applyAsyncId = null;
        this.digestTtl = function(value) {
            return arguments.length && (TTL = value), TTL;
        }, this.$get = [ "$injector", "$exceptionHandler", "$parse", "$browser", function($injector, $exceptionHandler, $parse, $browser) {
            function destroyChildScope($event) {
                $event.currentScope.$$destroyed = !0;
            }
            function Scope() {
                this.$id = nextUid(), this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null, 
                this.$root = this, this.$$destroyed = !1, this.$$listeners = {}, this.$$listenerCount = {}, 
                this.$$watchersCount = 0, this.$$isolateBindings = null;
            }
            function beginPhase(phase) {
                if ($rootScope.$$phase) throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase);
                $rootScope.$$phase = phase;
            }
            function clearPhase() {
                $rootScope.$$phase = null;
            }
            function incrementWatchersCount(current, count) {
                do current.$$watchersCount += count; while (current = current.$parent);
            }
            function decrementListenerCount(current, count, name) {
                do current.$$listenerCount[name] -= count, 0 === current.$$listenerCount[name] && delete current.$$listenerCount[name]; while (current = current.$parent);
            }
            function initWatchVal() {}
            function flushApplyAsync() {
                for (;applyAsyncQueue.length; ) try {
                    applyAsyncQueue.shift()();
                } catch (e) {
                    $exceptionHandler(e);
                }
                applyAsyncId = null;
            }
            function scheduleApplyAsync() {
                null === applyAsyncId && (applyAsyncId = $browser.defer(function() {
                    $rootScope.$apply(flushApplyAsync);
                }));
            }
            Scope.prototype = {
                constructor: Scope,
                $new: function(isolate, parent) {
                    var child;
                    return parent = parent || this, isolate ? (child = new Scope(), child.$root = this.$root) : (this.$$ChildScope || (this.$$ChildScope = createChildScopeClass(this)), 
                    child = new this.$$ChildScope()), child.$parent = parent, child.$$prevSibling = parent.$$childTail, 
                    parent.$$childHead ? (parent.$$childTail.$$nextSibling = child, parent.$$childTail = child) : parent.$$childHead = parent.$$childTail = child, 
                    (isolate || parent != this) && child.$on("$destroy", destroyChildScope), child;
                },
                $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
                    var get = $parse(watchExp);
                    if (get.$$watchDelegate) return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
                    var scope = this, array = scope.$$watchers, watcher = {
                        fn: listener,
                        last: initWatchVal,
                        get: get,
                        exp: prettyPrintExpression || watchExp,
                        eq: !!objectEquality
                    };
                    return lastDirtyWatch = null, isFunction(listener) || (watcher.fn = noop), array || (array = scope.$$watchers = []), 
                    array.unshift(watcher), incrementWatchersCount(this, 1), function() {
                        arrayRemove(array, watcher) >= 0 && incrementWatchersCount(scope, -1), lastDirtyWatch = null;
                    };
                },
                $watchGroup: function(watchExpressions, listener) {
                    function watchGroupAction() {
                        changeReactionScheduled = !1, firstRun ? (firstRun = !1, listener(newValues, newValues, self)) : listener(newValues, oldValues, self);
                    }
                    var oldValues = new Array(watchExpressions.length), newValues = new Array(watchExpressions.length), deregisterFns = [], self = this, changeReactionScheduled = !1, firstRun = !0;
                    if (!watchExpressions.length) {
                        var shouldCall = !0;
                        return self.$evalAsync(function() {
                            shouldCall && listener(newValues, newValues, self);
                        }), function() {
                            shouldCall = !1;
                        };
                    }
                    return 1 === watchExpressions.length ? this.$watch(watchExpressions[0], function(value, oldValue, scope) {
                        newValues[0] = value, oldValues[0] = oldValue, listener(newValues, value === oldValue ? newValues : oldValues, scope);
                    }) : (forEach(watchExpressions, function(expr, i) {
                        var unwatchFn = self.$watch(expr, function(value, oldValue) {
                            newValues[i] = value, oldValues[i] = oldValue, changeReactionScheduled || (changeReactionScheduled = !0, 
                            self.$evalAsync(watchGroupAction));
                        });
                        deregisterFns.push(unwatchFn);
                    }), function() {
                        for (;deregisterFns.length; ) deregisterFns.shift()();
                    });
                },
                $watchCollection: function(obj, listener) {
                    function $watchCollectionInterceptor(_value) {
                        newValue = _value;
                        var newLength, key, bothNaN, newItem, oldItem;
                        if (!isUndefined(newValue)) {
                            if (isObject(newValue)) if (isArrayLike(newValue)) {
                                oldValue !== internalArray && (oldValue = internalArray, oldLength = oldValue.length = 0, 
                                changeDetected++), newLength = newValue.length, oldLength !== newLength && (changeDetected++, 
                                oldValue.length = oldLength = newLength);
                                for (var i = 0; newLength > i; i++) oldItem = oldValue[i], newItem = newValue[i], 
                                bothNaN = oldItem !== oldItem && newItem !== newItem, bothNaN || oldItem === newItem || (changeDetected++, 
                                oldValue[i] = newItem);
                            } else {
                                oldValue !== internalObject && (oldValue = internalObject = {}, oldLength = 0, changeDetected++), 
                                newLength = 0;
                                for (key in newValue) newValue.hasOwnProperty(key) && (newLength++, newItem = newValue[key], 
                                oldItem = oldValue[key], key in oldValue ? (bothNaN = oldItem !== oldItem && newItem !== newItem, 
                                bothNaN || oldItem === newItem || (changeDetected++, oldValue[key] = newItem)) : (oldLength++, 
                                oldValue[key] = newItem, changeDetected++));
                                if (oldLength > newLength) {
                                    changeDetected++;
                                    for (key in oldValue) newValue.hasOwnProperty(key) || (oldLength--, delete oldValue[key]);
                                }
                            } else oldValue !== newValue && (oldValue = newValue, changeDetected++);
                            return changeDetected;
                        }
                    }
                    function $watchCollectionAction() {
                        if (initRun ? (initRun = !1, listener(newValue, newValue, self)) : listener(newValue, veryOldValue, self), 
                        trackVeryOldValue) if (isObject(newValue)) if (isArrayLike(newValue)) {
                            veryOldValue = new Array(newValue.length);
                            for (var i = 0; i < newValue.length; i++) veryOldValue[i] = newValue[i];
                        } else {
                            veryOldValue = {};
                            for (var key in newValue) hasOwnProperty.call(newValue, key) && (veryOldValue[key] = newValue[key]);
                        } else veryOldValue = newValue;
                    }
                    $watchCollectionInterceptor.$stateful = !0;
                    var newValue, oldValue, veryOldValue, self = this, trackVeryOldValue = listener.length > 1, changeDetected = 0, changeDetector = $parse(obj, $watchCollectionInterceptor), internalArray = [], internalObject = {}, initRun = !0, oldLength = 0;
                    return this.$watch(changeDetector, $watchCollectionAction);
                },
                $digest: function() {
                    var watch, value, last, watchers, length, dirty, next, current, logIdx, asyncTask, ttl = TTL, target = this, watchLog = [];
                    beginPhase("$digest"), $browser.$$checkUrlChange(), this === $rootScope && null !== applyAsyncId && ($browser.defer.cancel(applyAsyncId), 
                    flushApplyAsync()), lastDirtyWatch = null;
                    do {
                        for (dirty = !1, current = target; asyncQueue.length; ) {
                            try {
                                asyncTask = asyncQueue.shift(), asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                            lastDirtyWatch = null;
                        }
                        traverseScopesLoop: do {
                            if (watchers = current.$$watchers) for (length = watchers.length; length--; ) try {
                                if (watch = watchers[length]) if ((value = watch.get(current)) === (last = watch.last) || (watch.eq ? equals(value, last) : "number" == typeof value && "number" == typeof last && isNaN(value) && isNaN(last))) {
                                    if (watch === lastDirtyWatch) {
                                        dirty = !1;
                                        break traverseScopesLoop;
                                    }
                                } else dirty = !0, lastDirtyWatch = watch, watch.last = watch.eq ? copy(value, null) : value, 
                                watch.fn(value, last === initWatchVal ? value : last, current), 5 > ttl && (logIdx = 4 - ttl, 
                                watchLog[logIdx] || (watchLog[logIdx] = []), watchLog[logIdx].push({
                                    msg: isFunction(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                    newVal: value,
                                    oldVal: last
                                }));
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                            if (!(next = current.$$watchersCount && current.$$childHead || current !== target && current.$$nextSibling)) for (;current !== target && !(next = current.$$nextSibling); ) current = current.$parent;
                        } while (current = next);
                        if ((dirty || asyncQueue.length) && !ttl--) throw clearPhase(), $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\nWatchers fired in the last 5 iterations: {1}", TTL, watchLog);
                    } while (dirty || asyncQueue.length);
                    for (clearPhase(); postDigestQueue.length; ) try {
                        postDigestQueue.shift()();
                    } catch (e) {
                        $exceptionHandler(e);
                    }
                },
                $destroy: function() {
                    if (!this.$$destroyed) {
                        var parent = this.$parent;
                        this.$broadcast("$destroy"), this.$$destroyed = !0, this === $rootScope && $browser.$$applicationDestroyed(), 
                        incrementWatchersCount(this, -this.$$watchersCount);
                        for (var eventName in this.$$listenerCount) decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
                        parent && parent.$$childHead == this && (parent.$$childHead = this.$$nextSibling), 
                        parent && parent.$$childTail == this && (parent.$$childTail = this.$$prevSibling), 
                        this.$$prevSibling && (this.$$prevSibling.$$nextSibling = this.$$nextSibling), this.$$nextSibling && (this.$$nextSibling.$$prevSibling = this.$$prevSibling), 
                        this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop, 
                        this.$on = this.$watch = this.$watchGroup = function() {
                            return noop;
                        }, this.$$listeners = {}, this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = this.$root = this.$$watchers = null;
                    }
                },
                $eval: function(expr, locals) {
                    return $parse(expr)(this, locals);
                },
                $evalAsync: function(expr, locals) {
                    $rootScope.$$phase || asyncQueue.length || $browser.defer(function() {
                        asyncQueue.length && $rootScope.$digest();
                    }), asyncQueue.push({
                        scope: this,
                        expression: expr,
                        locals: locals
                    });
                },
                $$postDigest: function(fn) {
                    postDigestQueue.push(fn);
                },
                $apply: function(expr) {
                    try {
                        return beginPhase("$apply"), this.$eval(expr);
                    } catch (e) {
                        $exceptionHandler(e);
                    } finally {
                        clearPhase();
                        try {
                            $rootScope.$digest();
                        } catch (e) {
                            throw $exceptionHandler(e), e;
                        }
                    }
                },
                $applyAsync: function(expr) {
                    function $applyAsyncExpression() {
                        scope.$eval(expr);
                    }
                    var scope = this;
                    expr && applyAsyncQueue.push($applyAsyncExpression), scheduleApplyAsync();
                },
                $on: function(name, listener) {
                    var namedListeners = this.$$listeners[name];
                    namedListeners || (this.$$listeners[name] = namedListeners = []), namedListeners.push(listener);
                    var current = this;
                    do current.$$listenerCount[name] || (current.$$listenerCount[name] = 0), current.$$listenerCount[name]++; while (current = current.$parent);
                    var self = this;
                    return function() {
                        var indexOfListener = namedListeners.indexOf(listener);
                        -1 !== indexOfListener && (namedListeners[indexOfListener] = null, decrementListenerCount(self, 1, name));
                    };
                },
                $emit: function(name, args) {
                    var namedListeners, i, length, empty = [], scope = this, stopPropagation = !1, event = {
                        name: name,
                        targetScope: scope,
                        stopPropagation: function() {
                            stopPropagation = !0;
                        },
                        preventDefault: function() {
                            event.defaultPrevented = !0;
                        },
                        defaultPrevented: !1
                    }, listenerArgs = concat([ event ], arguments, 1);
                    do {
                        for (namedListeners = scope.$$listeners[name] || empty, event.currentScope = scope, 
                        i = 0, length = namedListeners.length; length > i; i++) if (namedListeners[i]) try {
                            namedListeners[i].apply(null, listenerArgs);
                        } catch (e) {
                            $exceptionHandler(e);
                        } else namedListeners.splice(i, 1), i--, length--;
                        if (stopPropagation) return event.currentScope = null, event;
                        scope = scope.$parent;
                    } while (scope);
                    return event.currentScope = null, event;
                },
                $broadcast: function(name, args) {
                    var target = this, current = target, next = target, event = {
                        name: name,
                        targetScope: target,
                        preventDefault: function() {
                            event.defaultPrevented = !0;
                        },
                        defaultPrevented: !1
                    };
                    if (!target.$$listenerCount[name]) return event;
                    for (var listeners, i, length, listenerArgs = concat([ event ], arguments, 1); current = next; ) {
                        for (event.currentScope = current, listeners = current.$$listeners[name] || [], 
                        i = 0, length = listeners.length; length > i; i++) if (listeners[i]) try {
                            listeners[i].apply(null, listenerArgs);
                        } catch (e) {
                            $exceptionHandler(e);
                        } else listeners.splice(i, 1), i--, length--;
                        if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling)) for (;current !== target && !(next = current.$$nextSibling); ) current = current.$parent;
                    }
                    return event.currentScope = null, event;
                }
            };
            var $rootScope = new Scope(), asyncQueue = $rootScope.$$asyncQueue = [], postDigestQueue = $rootScope.$$postDigestQueue = [], applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
            return $rootScope;
        } ];
    }
    function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/, imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? (aHrefSanitizationWhitelist = regexp, this) : aHrefSanitizationWhitelist;
        }, this.imgSrcSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? (imgSrcSanitizationWhitelist = regexp, this) : imgSrcSanitizationWhitelist;
        }, this.$get = function() {
            return function(uri, isImage) {
                var normalizedVal, regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
                return normalizedVal = urlResolve(uri).href, "" === normalizedVal || normalizedVal.match(regex) ? uri : "unsafe:" + normalizedVal;
            };
        };
    }
    function adjustMatcher(matcher) {
        if ("self" === matcher) return matcher;
        if (isString(matcher)) {
            if (matcher.indexOf("***") > -1) throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher);
            return matcher = escapeForRegexp(matcher).replace("\\*\\*", ".*").replace("\\*", "[^:/.?&;]*"), 
            new RegExp("^" + matcher + "$");
        }
        if (isRegExp(matcher)) return new RegExp("^" + matcher.source + "$");
        throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects');
    }
    function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        return isDefined(matchers) && forEach(matchers, function(matcher) {
            adjustedMatchers.push(adjustMatcher(matcher));
        }), adjustedMatchers;
    }
    function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = [ "self" ], resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
            return arguments.length && (resourceUrlWhitelist = adjustMatchers(value)), resourceUrlWhitelist;
        }, this.resourceUrlBlacklist = function(value) {
            return arguments.length && (resourceUrlBlacklist = adjustMatchers(value)), resourceUrlBlacklist;
        }, this.$get = [ "$injector", function($injector) {
            function matchUrl(matcher, parsedUrl) {
                return "self" === matcher ? urlIsSameOrigin(parsedUrl) : !!matcher.exec(parsedUrl.href);
            }
            function isResourceUrlAllowedByPolicy(url) {
                var i, n, parsedUrl = urlResolve(url.toString()), allowed = !1;
                for (i = 0, n = resourceUrlWhitelist.length; n > i; i++) if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                    allowed = !0;
                    break;
                }
                if (allowed) for (i = 0, n = resourceUrlBlacklist.length; n > i; i++) if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                    allowed = !1;
                    break;
                }
                return allowed;
            }
            function generateHolderType(Base) {
                var holderType = function(trustedValue) {
                    this.$$unwrapTrustedValue = function() {
                        return trustedValue;
                    };
                };
                return Base && (holderType.prototype = new Base()), holderType.prototype.valueOf = function() {
                    return this.$$unwrapTrustedValue();
                }, holderType.prototype.toString = function() {
                    return this.$$unwrapTrustedValue().toString();
                }, holderType;
            }
            function trustAs(type, trustedValue) {
                var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (!Constructor) throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue);
                if (null === trustedValue || trustedValue === undefined || "" === trustedValue) return trustedValue;
                if ("string" != typeof trustedValue) throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type);
                return new Constructor(trustedValue);
            }
            function valueOf(maybeTrusted) {
                return maybeTrusted instanceof trustedValueHolderBase ? maybeTrusted.$$unwrapTrustedValue() : maybeTrusted;
            }
            function getTrusted(type, maybeTrusted) {
                if (null === maybeTrusted || maybeTrusted === undefined || "" === maybeTrusted) return maybeTrusted;
                var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (constructor && maybeTrusted instanceof constructor) return maybeTrusted.$$unwrapTrustedValue();
                if (type === SCE_CONTEXTS.RESOURCE_URL) {
                    if (isResourceUrlAllowedByPolicy(maybeTrusted)) return maybeTrusted;
                    throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString());
                }
                if (type === SCE_CONTEXTS.HTML) return htmlSanitizer(maybeTrusted);
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            }
            var htmlSanitizer = function(html) {
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            };
            $injector.has("$sanitize") && (htmlSanitizer = $injector.get("$sanitize"));
            var trustedValueHolderBase = generateHolderType(), byType = {};
            return byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase), 
            byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase), 
            byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]), 
            {
                trustAs: trustAs,
                getTrusted: getTrusted,
                valueOf: valueOf
            };
        } ];
    }
    function $SceProvider() {
        var enabled = !0;
        this.enabled = function(value) {
            return arguments.length && (enabled = !!value), enabled;
        }, this.$get = [ "$parse", "$sceDelegate", function($parse, $sceDelegate) {
            if (enabled && 8 > msie) throw $sceMinErr("iequirks", "Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks mode.  You can fix this by adding the text <!doctype html> to the top of your HTML document.  See http://docs.angularjs.org/api/ng.$sce for more information.");
            var sce = shallowCopy(SCE_CONTEXTS);
            sce.isEnabled = function() {
                return enabled;
            }, sce.trustAs = $sceDelegate.trustAs, sce.getTrusted = $sceDelegate.getTrusted, 
            sce.valueOf = $sceDelegate.valueOf, enabled || (sce.trustAs = sce.getTrusted = function(type, value) {
                return value;
            }, sce.valueOf = identity), sce.parseAs = function(type, expr) {
                var parsed = $parse(expr);
                return parsed.literal && parsed.constant ? parsed : $parse(expr, function(value) {
                    return sce.getTrusted(type, value);
                });
            };
            var parse = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs;
            return forEach(SCE_CONTEXTS, function(enumValue, name) {
                var lName = lowercase(name);
                sce[camelCase("parse_as_" + lName)] = function(expr) {
                    return parse(enumValue, expr);
                }, sce[camelCase("get_trusted_" + lName)] = function(value) {
                    return getTrusted(enumValue, value);
                }, sce[camelCase("trust_as_" + lName)] = function(value) {
                    return trustAs(enumValue, value);
                };
            }), sce;
        } ];
    }
    function $SnifferProvider() {
        this.$get = [ "$window", "$document", function($window, $document) {
            var vendorPrefix, match, eventSupport = {}, android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document = $document[0] || {}, vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/, bodyStyle = document.body && document.body.style, transitions = !1, animations = !1;
            if (bodyStyle) {
                for (var prop in bodyStyle) if (match = vendorRegex.exec(prop)) {
                    vendorPrefix = match[0], vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
                    break;
                }
                vendorPrefix || (vendorPrefix = "WebkitOpacity" in bodyStyle && "webkit"), transitions = !!("transition" in bodyStyle || vendorPrefix + "Transition" in bodyStyle), 
                animations = !!("animation" in bodyStyle || vendorPrefix + "Animation" in bodyStyle), 
                !android || transitions && animations || (transitions = isString(bodyStyle.webkitTransition), 
                animations = isString(bodyStyle.webkitAnimation));
            }
            return {
                history: !(!$window.history || !$window.history.pushState || 4 > android || boxee),
                hasEvent: function(event) {
                    if ("input" === event && 11 >= msie) return !1;
                    if (isUndefined(eventSupport[event])) {
                        var divElm = document.createElement("div");
                        eventSupport[event] = "on" + event in divElm;
                    }
                    return eventSupport[event];
                },
                csp: csp(),
                vendorPrefix: vendorPrefix,
                transitions: transitions,
                animations: animations,
                android: android
            };
        } ];
    }
    function $TemplateRequestProvider() {
        this.$get = [ "$templateCache", "$http", "$q", "$sce", function($templateCache, $http, $q, $sce) {
            function handleRequestFn(tpl, ignoreRequestError) {
                function handleError(resp) {
                    if (!ignoreRequestError) throw $compileMinErr("tpload", "Failed to load template: {0} (HTTP status: {1} {2})", tpl, resp.status, resp.statusText);
                    return $q.reject(resp);
                }
                handleRequestFn.totalPendingRequests++, isString(tpl) && $templateCache.get(tpl) || (tpl = $sce.getTrustedResourceUrl(tpl));
                var transformResponse = $http.defaults && $http.defaults.transformResponse;
                isArray(transformResponse) ? transformResponse = transformResponse.filter(function(transformer) {
                    return transformer !== defaultHttpResponseTransform;
                }) : transformResponse === defaultHttpResponseTransform && (transformResponse = null);
                var httpOptions = {
                    cache: $templateCache,
                    transformResponse: transformResponse
                };
                return $http.get(tpl, httpOptions)["finally"](function() {
                    handleRequestFn.totalPendingRequests--;
                }).then(function(response) {
                    return $templateCache.put(tpl, response.data), response.data;
                }, handleError);
            }
            return handleRequestFn.totalPendingRequests = 0, handleRequestFn;
        } ];
    }
    function $$TestabilityProvider() {
        this.$get = [ "$rootScope", "$browser", "$location", function($rootScope, $browser, $location) {
            var testability = {};
            return testability.findBindings = function(element, expression, opt_exactMatch) {
                var bindings = element.getElementsByClassName("ng-binding"), matches = [];
                return forEach(bindings, function(binding) {
                    var dataBinding = angular.element(binding).data("$binding");
                    dataBinding && forEach(dataBinding, function(bindingName) {
                        if (opt_exactMatch) {
                            var matcher = new RegExp("(^|\\s)" + escapeForRegexp(expression) + "(\\s|\\||$)");
                            matcher.test(bindingName) && matches.push(binding);
                        } else -1 != bindingName.indexOf(expression) && matches.push(binding);
                    });
                }), matches;
            }, testability.findModels = function(element, expression, opt_exactMatch) {
                for (var prefixes = [ "ng-", "data-ng-", "ng\\:" ], p = 0; p < prefixes.length; ++p) {
                    var attributeEquals = opt_exactMatch ? "=" : "*=", selector = "[" + prefixes[p] + "model" + attributeEquals + '"' + expression + '"]', elements = element.querySelectorAll(selector);
                    if (elements.length) return elements;
                }
            }, testability.getLocation = function() {
                return $location.url();
            }, testability.setLocation = function(url) {
                url !== $location.url() && ($location.url(url), $rootScope.$digest());
            }, testability.whenStable = function(callback) {
                $browser.notifyWhenNoOutstandingRequests(callback);
            }, testability;
        } ];
    }
    function $TimeoutProvider() {
        this.$get = [ "$rootScope", "$browser", "$q", "$$q", "$exceptionHandler", function($rootScope, $browser, $q, $$q, $exceptionHandler) {
            function timeout(fn, delay, invokeApply) {
                isFunction(fn) || (invokeApply = delay, delay = fn, fn = noop);
                var timeoutId, args = sliceArgs(arguments, 3), skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                return timeoutId = $browser.defer(function() {
                    try {
                        deferred.resolve(fn.apply(null, args));
                    } catch (e) {
                        deferred.reject(e), $exceptionHandler(e);
                    } finally {
                        delete deferreds[promise.$$timeoutId];
                    }
                    skipApply || $rootScope.$apply();
                }, delay), promise.$$timeoutId = timeoutId, deferreds[timeoutId] = deferred, promise;
            }
            var deferreds = {};
            return timeout.cancel = function(promise) {
                return promise && promise.$$timeoutId in deferreds ? (deferreds[promise.$$timeoutId].reject("canceled"), 
                delete deferreds[promise.$$timeoutId], $browser.defer.cancel(promise.$$timeoutId)) : !1;
            }, timeout;
        } ];
    }
    function urlResolve(url) {
        var href = url;
        return msie && (urlParsingNode.setAttribute("href", href), href = urlParsingNode.href), 
        urlParsingNode.setAttribute("href", href), {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: "/" === urlParsingNode.pathname.charAt(0) ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
    }
    function urlIsSameOrigin(requestUrl) {
        var parsed = isString(requestUrl) ? urlResolve(requestUrl) : requestUrl;
        return parsed.protocol === originUrl.protocol && parsed.host === originUrl.host;
    }
    function $WindowProvider() {
        this.$get = valueFn(window);
    }
    function $$CookieReader($document) {
        function safeDecodeURIComponent(str) {
            try {
                return decodeURIComponent(str);
            } catch (e) {
                return str;
            }
        }
        var rawDocument = $document[0] || {}, lastCookies = {}, lastCookieString = "";
        return function() {
            var cookieArray, cookie, i, index, name, currentCookieString = rawDocument.cookie || "";
            if (currentCookieString !== lastCookieString) for (lastCookieString = currentCookieString, 
            cookieArray = lastCookieString.split("; "), lastCookies = {}, i = 0; i < cookieArray.length; i++) cookie = cookieArray[i], 
            index = cookie.indexOf("="), index > 0 && (name = safeDecodeURIComponent(cookie.substring(0, index)), 
            lastCookies[name] === undefined && (lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1))));
            return lastCookies;
        };
    }
    function $$CookieReaderProvider() {
        this.$get = $$CookieReader;
    }
    function $FilterProvider($provide) {
        function register(name, factory) {
            if (isObject(name)) {
                var filters = {};
                return forEach(name, function(filter, key) {
                    filters[key] = register(key, filter);
                }), filters;
            }
            return $provide.factory(name + suffix, factory);
        }
        var suffix = "Filter";
        this.register = register, this.$get = [ "$injector", function($injector) {
            return function(name) {
                return $injector.get(name + suffix);
            };
        } ], register("currency", currencyFilter), register("date", dateFilter), register("filter", filterFilter), 
        register("json", jsonFilter), register("limitTo", limitToFilter), register("lowercase", lowercaseFilter), 
        register("number", numberFilter), register("orderBy", orderByFilter), register("uppercase", uppercaseFilter);
    }
    function filterFilter() {
        return function(array, expression, comparator) {
            if (!isArrayLike(array)) {
                if (null == array) return array;
                throw minErr("filter")("notarray", "Expected array but received: {0}", array);
            }
            var predicateFn, matchAgainstAnyProp, expressionType = getTypeForFilter(expression);
            switch (expressionType) {
              case "function":
                predicateFn = expression;
                break;

              case "boolean":
              case "null":
              case "number":
              case "string":
                matchAgainstAnyProp = !0;

              case "object":
                predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);
                break;

              default:
                return array;
            }
            return Array.prototype.filter.call(array, predicateFn);
        };
    }
    function createPredicateFn(expression, comparator, matchAgainstAnyProp) {
        var predicateFn, shouldMatchPrimitives = isObject(expression) && "$" in expression;
        return comparator === !0 ? comparator = equals : isFunction(comparator) || (comparator = function(actual, expected) {
            return isUndefined(actual) ? !1 : null === actual || null === expected ? actual === expected : isObject(expected) || isObject(actual) && !hasCustomToString(actual) ? !1 : (actual = lowercase("" + actual), 
            expected = lowercase("" + expected), -1 !== actual.indexOf(expected));
        }), predicateFn = function(item) {
            return shouldMatchPrimitives && !isObject(item) ? deepCompare(item, expression.$, comparator, !1) : deepCompare(item, expression, comparator, matchAgainstAnyProp);
        };
    }
    function deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) {
        var actualType = getTypeForFilter(actual), expectedType = getTypeForFilter(expected);
        if ("string" === expectedType && "!" === expected.charAt(0)) return !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);
        if (isArray(actual)) return actual.some(function(item) {
            return deepCompare(item, expected, comparator, matchAgainstAnyProp);
        });
        switch (actualType) {
          case "object":
            var key;
            if (matchAgainstAnyProp) {
                for (key in actual) if ("$" !== key.charAt(0) && deepCompare(actual[key], expected, comparator, !0)) return !0;
                return dontMatchWholeObject ? !1 : deepCompare(actual, expected, comparator, !1);
            }
            if ("object" === expectedType) {
                for (key in expected) {
                    var expectedVal = expected[key];
                    if (!isFunction(expectedVal) && !isUndefined(expectedVal)) {
                        var matchAnyProperty = "$" === key, actualVal = matchAnyProperty ? actual : actual[key];
                        if (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) return !1;
                    }
                }
                return !0;
            }
            return comparator(actual, expected);

          case "function":
            return !1;

          default:
            return comparator(actual, expected);
        }
    }
    function getTypeForFilter(val) {
        return null === val ? "null" : typeof val;
    }
    function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol, fractionSize) {
            return isUndefined(currencySymbol) && (currencySymbol = formats.CURRENCY_SYM), isUndefined(fractionSize) && (fractionSize = formats.PATTERNS[1].maxFrac), 
            null == amount ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
        };
    }
    function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
            return null == number ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
    }
    function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (isObject(number)) return "";
        var isNegative = 0 > number;
        number = Math.abs(number);
        var isInfinity = number === 1 / 0;
        if (!isInfinity && !isFinite(number)) return "";
        var numStr = number + "", formatedText = "", hasExponent = !1, parts = [];
        if (isInfinity && (formatedText = "∞"), !isInfinity && -1 !== numStr.indexOf("e")) {
            var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
            match && "-" == match[2] && match[3] > fractionSize + 1 ? number = 0 : (formatedText = numStr, 
            hasExponent = !0);
        }
        if (isInfinity || hasExponent) fractionSize > 0 && 1 > number && (formatedText = number.toFixed(fractionSize), 
        number = parseFloat(formatedText)); else {
            var fractionLen = (numStr.split(DECIMAL_SEP)[1] || "").length;
            isUndefined(fractionSize) && (fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac)), 
            number = +(Math.round(+(number.toString() + "e" + fractionSize)).toString() + "e" + -fractionSize);
            var fraction = ("" + number).split(DECIMAL_SEP), whole = fraction[0];
            fraction = fraction[1] || "";
            var i, pos = 0, lgroup = pattern.lgSize, group = pattern.gSize;
            if (whole.length >= lgroup + group) for (pos = whole.length - lgroup, i = 0; pos > i; i++) (pos - i) % group === 0 && 0 !== i && (formatedText += groupSep), 
            formatedText += whole.charAt(i);
            for (i = pos; i < whole.length; i++) (whole.length - i) % lgroup === 0 && 0 !== i && (formatedText += groupSep), 
            formatedText += whole.charAt(i);
            for (;fraction.length < fractionSize; ) fraction += "0";
            fractionSize && "0" !== fractionSize && (formatedText += decimalSep + fraction.substr(0, fractionSize));
        }
        return 0 === number && (isNegative = !1), parts.push(isNegative ? pattern.negPre : pattern.posPre, formatedText, isNegative ? pattern.negSuf : pattern.posSuf), 
        parts.join("");
    }
    function padNumber(num, digits, trim) {
        var neg = "";
        for (0 > num && (neg = "-", num = -num), num = "" + num; num.length < digits; ) num = "0" + num;
        return trim && (num = num.substr(num.length - digits)), neg + num;
    }
    function dateGetter(name, size, offset, trim) {
        return offset = offset || 0, function(date) {
            var value = date["get" + name]();
            return (offset > 0 || value > -offset) && (value += offset), 0 === value && -12 == offset && (value = 12), 
            padNumber(value, size, trim);
        };
    }
    function dateStrGetter(name, shortForm) {
        return function(date, formats) {
            var value = date["get" + name](), get = uppercase(shortForm ? "SHORT" + name : name);
            return formats[get][value];
        };
    }
    function timeZoneGetter(date, formats, offset) {
        var zone = -1 * offset, paddedZone = zone >= 0 ? "+" : "";
        return paddedZone += padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
    }
    function getFirstThursdayOfYear(year) {
        var dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
        return new Date(year, 0, (4 >= dayOfWeekOnFirst ? 5 : 12) - dayOfWeekOnFirst);
    }
    function getThursdayThisWeek(datetime) {
        return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
    }
    function weekGetter(size) {
        return function(date) {
            var firstThurs = getFirstThursdayOfYear(date.getFullYear()), thisThurs = getThursdayThisWeek(date), diff = +thisThurs - +firstThurs, result = 1 + Math.round(diff / 6048e5);
            return padNumber(result, size);
        };
    }
    function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
    }
    function eraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
    }
    function longEraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
    }
    function dateFilter($locale) {
        function jsonStringToDate(string) {
            var match;
            if (match = string.match(R_ISO8601_STR)) {
                var date = new Date(0), tzHour = 0, tzMin = 0, dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear, timeSetter = match[8] ? date.setUTCHours : date.setHours;
                match[9] && (tzHour = toInt(match[9] + match[10]), tzMin = toInt(match[9] + match[11])), 
                dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
                var h = toInt(match[4] || 0) - tzHour, m = toInt(match[5] || 0) - tzMin, s = toInt(match[6] || 0), ms = Math.round(1e3 * parseFloat("0." + (match[7] || 0)));
                return timeSetter.call(date, h, m, s, ms), date;
            }
            return string;
        }
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        return function(date, format, timezone) {
            var fn, match, text = "", parts = [];
            if (format = format || "mediumDate", format = $locale.DATETIME_FORMATS[format] || format, 
            isString(date) && (date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date)), 
            isNumber(date) && (date = new Date(date)), !isDate(date) || !isFinite(date.getTime())) return date;
            for (;format; ) match = DATE_FORMATS_SPLIT.exec(format), match ? (parts = concat(parts, match, 1), 
            format = parts.pop()) : (parts.push(format), format = null);
            var dateTimezoneOffset = date.getTimezoneOffset();
            return timezone && (dateTimezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset()), 
            date = convertTimezoneToLocal(date, timezone, !0)), forEach(parts, function(value) {
                fn = DATE_FORMATS[value], text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : value.replace(/(^'|'$)/g, "").replace(/''/g, "'");
            }), text;
        };
    }
    function jsonFilter() {
        return function(object, spacing) {
            return isUndefined(spacing) && (spacing = 2), toJson(object, spacing);
        };
    }
    function limitToFilter() {
        return function(input, limit, begin) {
            return limit = Math.abs(Number(limit)) === 1 / 0 ? Number(limit) : toInt(limit), 
            isNaN(limit) ? input : (isNumber(input) && (input = input.toString()), isArray(input) || isString(input) ? (begin = !begin || isNaN(begin) ? 0 : toInt(begin), 
            begin = 0 > begin && begin >= -input.length ? input.length + begin : begin, limit >= 0 ? input.slice(begin, begin + limit) : 0 === begin ? input.slice(limit, input.length) : input.slice(Math.max(0, begin + limit), begin)) : input);
        };
    }
    function orderByFilter($parse) {
        function processPredicates(sortPredicate, reverseOrder) {
            return reverseOrder = reverseOrder ? -1 : 1, sortPredicate.map(function(predicate) {
                var descending = 1, get = identity;
                if (isFunction(predicate)) get = predicate; else if (isString(predicate) && (("+" == predicate.charAt(0) || "-" == predicate.charAt(0)) && (descending = "-" == predicate.charAt(0) ? -1 : 1, 
                predicate = predicate.substring(1)), "" !== predicate && (get = $parse(predicate), 
                get.constant))) {
                    var key = get();
                    get = function(value) {
                        return value[key];
                    };
                }
                return {
                    get: get,
                    descending: descending * reverseOrder
                };
            });
        }
        function isPrimitive(value) {
            switch (typeof value) {
              case "number":
              case "boolean":
              case "string":
                return !0;

              default:
                return !1;
            }
        }
        function objectValue(value, index) {
            return "function" == typeof value.valueOf && (value = value.valueOf(), isPrimitive(value)) ? value : hasCustomToString(value) && (value = value.toString(), 
            isPrimitive(value)) ? value : index;
        }
        function getPredicateValue(value, index) {
            var type = typeof value;
            return null === value ? (type = "string", value = "null") : "string" === type ? value = value.toLowerCase() : "object" === type && (value = objectValue(value, index)), 
            {
                value: value,
                type: type
            };
        }
        function compare(v1, v2) {
            var result = 0;
            return v1.type === v2.type ? v1.value !== v2.value && (result = v1.value < v2.value ? -1 : 1) : result = v1.type < v2.type ? -1 : 1, 
            result;
        }
        return function(array, sortPredicate, reverseOrder) {
            function getComparisonObject(value, index) {
                return {
                    value: value,
                    predicateValues: predicates.map(function(predicate) {
                        return getPredicateValue(predicate.get(value), index);
                    })
                };
            }
            function doComparison(v1, v2) {
                for (var result = 0, index = 0, length = predicates.length; length > index && !(result = compare(v1.predicateValues[index], v2.predicateValues[index]) * predicates[index].descending); ++index) ;
                return result;
            }
            if (!isArrayLike(array)) return array;
            isArray(sortPredicate) || (sortPredicate = [ sortPredicate ]), 0 === sortPredicate.length && (sortPredicate = [ "+" ]);
            var predicates = processPredicates(sortPredicate, reverseOrder), compareValues = Array.prototype.map.call(array, getComparisonObject);
            return compareValues.sort(doComparison), array = compareValues.map(function(item) {
                return item.value;
            });
        };
    }
    function ngDirective(directive) {
        return isFunction(directive) && (directive = {
            link: directive
        }), directive.restrict = directive.restrict || "AC", valueFn(directive);
    }
    function nullFormRenameControl(control, name) {
        control.$name = name;
    }
    function FormController(element, attrs, $scope, $animate, $interpolate) {
        var form = this, controls = [], parentForm = form.$$parentForm = element.parent().controller("form") || nullFormCtrl;
        form.$error = {}, form.$$success = {}, form.$pending = undefined, form.$name = $interpolate(attrs.name || attrs.ngForm || "")($scope), 
        form.$dirty = !1, form.$pristine = !0, form.$valid = !0, form.$invalid = !1, form.$submitted = !1, 
        parentForm.$addControl(form), form.$rollbackViewValue = function() {
            forEach(controls, function(control) {
                control.$rollbackViewValue();
            });
        }, form.$commitViewValue = function() {
            forEach(controls, function(control) {
                control.$commitViewValue();
            });
        }, form.$addControl = function(control) {
            assertNotHasOwnProperty(control.$name, "input"), controls.push(control), control.$name && (form[control.$name] = control);
        }, form.$$renameControl = function(control, newName) {
            var oldName = control.$name;
            form[oldName] === control && delete form[oldName], form[newName] = control, control.$name = newName;
        }, form.$removeControl = function(control) {
            control.$name && form[control.$name] === control && delete form[control.$name], 
            forEach(form.$pending, function(value, name) {
                form.$setValidity(name, null, control);
            }), forEach(form.$error, function(value, name) {
                form.$setValidity(name, null, control);
            }), forEach(form.$$success, function(value, name) {
                form.$setValidity(name, null, control);
            }), arrayRemove(controls, control);
        }, addSetValidityMethod({
            ctrl: this,
            $element: element,
            set: function(object, property, controller) {
                var list = object[property];
                if (list) {
                    var index = list.indexOf(controller);
                    -1 === index && list.push(controller);
                } else object[property] = [ controller ];
            },
            unset: function(object, property, controller) {
                var list = object[property];
                list && (arrayRemove(list, controller), 0 === list.length && delete object[property]);
            },
            parentForm: parentForm,
            $animate: $animate
        }), form.$setDirty = function() {
            $animate.removeClass(element, PRISTINE_CLASS), $animate.addClass(element, DIRTY_CLASS), 
            form.$dirty = !0, form.$pristine = !1, parentForm.$setDirty();
        }, form.$setPristine = function() {
            $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + " " + SUBMITTED_CLASS), 
            form.$dirty = !1, form.$pristine = !0, form.$submitted = !1, forEach(controls, function(control) {
                control.$setPristine();
            });
        }, form.$setUntouched = function() {
            forEach(controls, function(control) {
                control.$setUntouched();
            });
        }, form.$setSubmitted = function() {
            $animate.addClass(element, SUBMITTED_CLASS), form.$submitted = !0, parentForm.$setSubmitted();
        };
    }
    function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(function(value) {
            return ctrl.$isEmpty(value) ? value : value.toString();
        });
    }
    function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl);
    }
    function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var type = lowercase(element[0].type);
        if (!$sniffer.android) {
            var composing = !1;
            element.on("compositionstart", function(data) {
                composing = !0;
            }), element.on("compositionend", function() {
                composing = !1, listener();
            });
        }
        var listener = function(ev) {
            if (timeout && ($browser.defer.cancel(timeout), timeout = null), !composing) {
                var value = element.val(), event = ev && ev.type;
                "password" === type || attr.ngTrim && "false" === attr.ngTrim || (value = trim(value)), 
                (ctrl.$viewValue !== value || "" === value && ctrl.$$hasNativeValidators) && ctrl.$setViewValue(value, event);
            }
        };
        if ($sniffer.hasEvent("input")) element.on("input", listener); else {
            var timeout, deferListener = function(ev, input, origValue) {
                timeout || (timeout = $browser.defer(function() {
                    timeout = null, input && input.value === origValue || listener(ev);
                }));
            };
            element.on("keydown", function(event) {
                var key = event.keyCode;
                91 === key || key > 15 && 19 > key || key >= 37 && 40 >= key || deferListener(event, this, this.value);
            }), $sniffer.hasEvent("paste") && element.on("paste cut", deferListener);
        }
        element.on("change", listener), ctrl.$render = function() {
            element.val(ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue);
        };
    }
    function weekParser(isoWeek, existingDate) {
        if (isDate(isoWeek)) return isoWeek;
        if (isString(isoWeek)) {
            WEEK_REGEXP.lastIndex = 0;
            var parts = WEEK_REGEXP.exec(isoWeek);
            if (parts) {
                var year = +parts[1], week = +parts[2], hours = 0, minutes = 0, seconds = 0, milliseconds = 0, firstThurs = getFirstThursdayOfYear(year), addDays = 7 * (week - 1);
                return existingDate && (hours = existingDate.getHours(), minutes = existingDate.getMinutes(), 
                seconds = existingDate.getSeconds(), milliseconds = existingDate.getMilliseconds()), 
                new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
            }
        }
        return NaN;
    }
    function createDateParser(regexp, mapping) {
        return function(iso, date) {
            var parts, map;
            if (isDate(iso)) return iso;
            if (isString(iso)) {
                if ('"' == iso.charAt(0) && '"' == iso.charAt(iso.length - 1) && (iso = iso.substring(1, iso.length - 1)), 
                ISO_DATE_REGEXP.test(iso)) return new Date(iso);
                if (regexp.lastIndex = 0, parts = regexp.exec(iso)) return parts.shift(), map = date ? {
                    yyyy: date.getFullYear(),
                    MM: date.getMonth() + 1,
                    dd: date.getDate(),
                    HH: date.getHours(),
                    mm: date.getMinutes(),
                    ss: date.getSeconds(),
                    sss: date.getMilliseconds() / 1e3
                } : {
                    yyyy: 1970,
                    MM: 1,
                    dd: 1,
                    HH: 0,
                    mm: 0,
                    ss: 0,
                    sss: 0
                }, forEach(parts, function(part, index) {
                    index < mapping.length && (map[mapping[index]] = +part);
                }), new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, 1e3 * map.sss || 0);
            }
            return NaN;
        };
    }
    function createDateInputType(type, regexp, parseDate, format) {
        return function(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
            function isValidDate(value) {
                return value && !(value.getTime && value.getTime() !== value.getTime());
            }
            function parseObservedDateValue(val) {
                return isDefined(val) ? isDate(val) ? val : parseDate(val) : undefined;
            }
            badInputChecker(scope, element, attr, ctrl), baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
            var previousDate, timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
            if (ctrl.$$parserName = type, ctrl.$parsers.push(function(value) {
                if (ctrl.$isEmpty(value)) return null;
                if (regexp.test(value)) {
                    var parsedDate = parseDate(value, previousDate);
                    return timezone && (parsedDate = convertTimezoneToLocal(parsedDate, timezone)), 
                    parsedDate;
                }
                return undefined;
            }), ctrl.$formatters.push(function(value) {
                if (value && !isDate(value)) throw $ngModelMinErr("datefmt", "Expected `{0}` to be a date", value);
                return isValidDate(value) ? (previousDate = value, previousDate && timezone && (previousDate = convertTimezoneToLocal(previousDate, timezone, !0)), 
                $filter("date")(value, format, timezone)) : (previousDate = null, "");
            }), isDefined(attr.min) || attr.ngMin) {
                var minVal;
                ctrl.$validators.min = function(value) {
                    return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
                }, attr.$observe("min", function(val) {
                    minVal = parseObservedDateValue(val), ctrl.$validate();
                });
            }
            if (isDefined(attr.max) || attr.ngMax) {
                var maxVal;
                ctrl.$validators.max = function(value) {
                    return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
                }, attr.$observe("max", function(val) {
                    maxVal = parseObservedDateValue(val), ctrl.$validate();
                });
            }
        };
    }
    function badInputChecker(scope, element, attr, ctrl) {
        var node = element[0], nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
        nativeValidation && ctrl.$parsers.push(function(value) {
            var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
            return validity.badInput && !validity.typeMismatch ? undefined : value;
        });
    }
    function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        if (badInputChecker(scope, element, attr, ctrl), baseInputType(scope, element, attr, ctrl, $sniffer, $browser), 
        ctrl.$$parserName = "number", ctrl.$parsers.push(function(value) {
            return ctrl.$isEmpty(value) ? null : NUMBER_REGEXP.test(value) ? parseFloat(value) : undefined;
        }), ctrl.$formatters.push(function(value) {
            if (!ctrl.$isEmpty(value)) {
                if (!isNumber(value)) throw $ngModelMinErr("numfmt", "Expected `{0}` to be a number", value);
                value = value.toString();
            }
            return value;
        }), isDefined(attr.min) || attr.ngMin) {
            var minVal;
            ctrl.$validators.min = function(value) {
                return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
            }, attr.$observe("min", function(val) {
                isDefined(val) && !isNumber(val) && (val = parseFloat(val, 10)), minVal = isNumber(val) && !isNaN(val) ? val : undefined, 
                ctrl.$validate();
            });
        }
        if (isDefined(attr.max) || attr.ngMax) {
            var maxVal;
            ctrl.$validators.max = function(value) {
                return ctrl.$isEmpty(value) || isUndefined(maxVal) || maxVal >= value;
            }, attr.$observe("max", function(val) {
                isDefined(val) && !isNumber(val) && (val = parseFloat(val, 10)), maxVal = isNumber(val) && !isNaN(val) ? val : undefined, 
                ctrl.$validate();
            });
        }
    }
    function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl), 
        ctrl.$$parserName = "url", ctrl.$validators.url = function(modelValue, viewValue) {
            var value = modelValue || viewValue;
            return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
        };
    }
    function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl), 
        ctrl.$$parserName = "email", ctrl.$validators.email = function(modelValue, viewValue) {
            var value = modelValue || viewValue;
            return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
        };
    }
    function radioInputType(scope, element, attr, ctrl) {
        isUndefined(attr.name) && element.attr("name", nextUid());
        var listener = function(ev) {
            element[0].checked && ctrl.$setViewValue(attr.value, ev && ev.type);
        };
        element.on("click", listener), ctrl.$render = function() {
            var value = attr.value;
            element[0].checked = value == ctrl.$viewValue;
        }, attr.$observe("value", ctrl.$render);
    }
    function parseConstantExpr($parse, context, name, expression, fallback) {
        var parseFn;
        if (isDefined(expression)) {
            if (parseFn = $parse(expression), !parseFn.constant) throw minErr("ngModel")("constexpr", "Expected constant expression for `{0}`, but saw `{1}`.", name, expression);
            return parseFn(context);
        }
        return fallback;
    }
    function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        var trueValue = parseConstantExpr($parse, scope, "ngTrueValue", attr.ngTrueValue, !0), falseValue = parseConstantExpr($parse, scope, "ngFalseValue", attr.ngFalseValue, !1), listener = function(ev) {
            ctrl.$setViewValue(element[0].checked, ev && ev.type);
        };
        element.on("click", listener), ctrl.$render = function() {
            element[0].checked = ctrl.$viewValue;
        }, ctrl.$isEmpty = function(value) {
            return value === !1;
        }, ctrl.$formatters.push(function(value) {
            return equals(value, trueValue);
        }), ctrl.$parsers.push(function(value) {
            return value ? trueValue : falseValue;
        });
    }
    function classDirective(name, selector) {
        return name = "ngClass" + name, [ "$animate", function($animate) {
            function arrayDifference(tokens1, tokens2) {
                var values = [];
                outer: for (var i = 0; i < tokens1.length; i++) {
                    for (var token = tokens1[i], j = 0; j < tokens2.length; j++) if (token == tokens2[j]) continue outer;
                    values.push(token);
                }
                return values;
            }
            function arrayClasses(classVal) {
                var classes = [];
                return isArray(classVal) ? (forEach(classVal, function(v) {
                    classes = classes.concat(arrayClasses(v));
                }), classes) : isString(classVal) ? classVal.split(" ") : isObject(classVal) ? (forEach(classVal, function(v, k) {
                    v && (classes = classes.concat(k.split(" ")));
                }), classes) : classVal;
            }
            return {
                restrict: "AC",
                link: function(scope, element, attr) {
                    function addClasses(classes) {
                        var newClasses = digestClassCounts(classes, 1);
                        attr.$addClass(newClasses);
                    }
                    function removeClasses(classes) {
                        var newClasses = digestClassCounts(classes, -1);
                        attr.$removeClass(newClasses);
                    }
                    function digestClassCounts(classes, count) {
                        var classCounts = element.data("$classCounts") || createMap(), classesToUpdate = [];
                        return forEach(classes, function(className) {
                            (count > 0 || classCounts[className]) && (classCounts[className] = (classCounts[className] || 0) + count, 
                            classCounts[className] === +(count > 0) && classesToUpdate.push(className));
                        }), element.data("$classCounts", classCounts), classesToUpdate.join(" ");
                    }
                    function updateClasses(oldClasses, newClasses) {
                        var toAdd = arrayDifference(newClasses, oldClasses), toRemove = arrayDifference(oldClasses, newClasses);
                        toAdd = digestClassCounts(toAdd, 1), toRemove = digestClassCounts(toRemove, -1), 
                        toAdd && toAdd.length && $animate.addClass(element, toAdd), toRemove && toRemove.length && $animate.removeClass(element, toRemove);
                    }
                    function ngClassWatchAction(newVal) {
                        if (selector === !0 || scope.$index % 2 === selector) {
                            var newClasses = arrayClasses(newVal || []);
                            if (oldVal) {
                                if (!equals(newVal, oldVal)) {
                                    var oldClasses = arrayClasses(oldVal);
                                    updateClasses(oldClasses, newClasses);
                                }
                            } else addClasses(newClasses);
                        }
                        oldVal = shallowCopy(newVal);
                    }
                    var oldVal;
                    scope.$watch(attr[name], ngClassWatchAction, !0), attr.$observe("class", function(value) {
                        ngClassWatchAction(scope.$eval(attr[name]));
                    }), "ngClass" !== name && scope.$watch("$index", function($index, old$index) {
                        var mod = 1 & $index;
                        if (mod !== (1 & old$index)) {
                            var classes = arrayClasses(scope.$eval(attr[name]));
                            mod === selector ? addClasses(classes) : removeClasses(classes);
                        }
                    });
                }
            };
        } ];
    }
    function addSetValidityMethod(context) {
        function setValidity(validationErrorKey, state, controller) {
            state === undefined ? createAndSet("$pending", validationErrorKey, controller) : unsetAndCleanup("$pending", validationErrorKey, controller), 
            isBoolean(state) ? state ? (unset(ctrl.$error, validationErrorKey, controller), 
            set(ctrl.$$success, validationErrorKey, controller)) : (set(ctrl.$error, validationErrorKey, controller), 
            unset(ctrl.$$success, validationErrorKey, controller)) : (unset(ctrl.$error, validationErrorKey, controller), 
            unset(ctrl.$$success, validationErrorKey, controller)), ctrl.$pending ? (cachedToggleClass(PENDING_CLASS, !0), 
            ctrl.$valid = ctrl.$invalid = undefined, toggleValidationCss("", null)) : (cachedToggleClass(PENDING_CLASS, !1), 
            ctrl.$valid = isObjectEmpty(ctrl.$error), ctrl.$invalid = !ctrl.$valid, toggleValidationCss("", ctrl.$valid));
            var combinedState;
            combinedState = ctrl.$pending && ctrl.$pending[validationErrorKey] ? undefined : ctrl.$error[validationErrorKey] ? !1 : ctrl.$$success[validationErrorKey] ? !0 : null, 
            toggleValidationCss(validationErrorKey, combinedState), parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
        }
        function createAndSet(name, value, controller) {
            ctrl[name] || (ctrl[name] = {}), set(ctrl[name], value, controller);
        }
        function unsetAndCleanup(name, value, controller) {
            ctrl[name] && unset(ctrl[name], value, controller), isObjectEmpty(ctrl[name]) && (ctrl[name] = undefined);
        }
        function cachedToggleClass(className, switchValue) {
            switchValue && !classCache[className] ? ($animate.addClass($element, className), 
            classCache[className] = !0) : !switchValue && classCache[className] && ($animate.removeClass($element, className), 
            classCache[className] = !1);
        }
        function toggleValidationCss(validationErrorKey, isValid) {
            validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "", 
            cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === !0), cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === !1);
        }
        var ctrl = context.ctrl, $element = context.$element, classCache = {}, set = context.set, unset = context.unset, parentForm = context.parentForm, $animate = context.$animate;
        classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS)), 
        ctrl.$setValidity = setValidity;
    }
    function isObjectEmpty(obj) {
        if (obj) for (var prop in obj) if (obj.hasOwnProperty(prop)) return !1;
        return !0;
    }
    var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/, VALIDITY_STATE_PROPERTY = "validity", lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
    }, hasOwnProperty = Object.prototype.hasOwnProperty, uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
    }, manualLowercase = function(s) {
        return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
            return String.fromCharCode(32 | ch.charCodeAt(0));
        }) : s;
    }, manualUppercase = function(s) {
        return isString(s) ? s.replace(/[a-z]/g, function(ch) {
            return String.fromCharCode(-33 & ch.charCodeAt(0));
        }) : s;
    };
    "i" !== "I".toLowerCase() && (lowercase = manualLowercase, uppercase = manualUppercase);
    var msie, jqLite, jQuery, angularModule, slice = [].slice, splice = [].splice, push = [].push, toString = Object.prototype.toString, getPrototypeOf = Object.getPrototypeOf, ngMinErr = minErr("ng"), angular = window.angular || (window.angular = {}), uid = 0;
    msie = document.documentMode, noop.$inject = [], identity.$inject = [];
    var skipDestroyOnNextJQueryCleanData, isArray = Array.isArray, TYPED_ARRAY_REGEXP = /^\[object (Uint8(Clamped)?)|(Uint16)|(Uint32)|(Int8)|(Int16)|(Int32)|(Float(32)|(64))Array\]$/, trim = function(value) {
        return isString(value) ? value.trim() : value;
    }, escapeForRegexp = function(s) {
        return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
    }, csp = function() {
        if (isDefined(csp.isActive_)) return csp.isActive_;
        var active = !(!document.querySelector("[ng-csp]") && !document.querySelector("[data-ng-csp]"));
        if (!active) try {
            new Function("");
        } catch (e) {
            active = !0;
        }
        return csp.isActive_ = active;
    }, jq = function() {
        if (isDefined(jq.name_)) return jq.name_;
        var el, i, prefix, name, ii = ngAttrPrefixes.length;
        for (i = 0; ii > i; ++i) if (prefix = ngAttrPrefixes[i], el = document.querySelector("[" + prefix.replace(":", "\\:") + "jq]")) {
            name = el.getAttribute(prefix + "jq");
            break;
        }
        return jq.name_ = name;
    }, ngAttrPrefixes = [ "ng-", "data-ng-", "ng:", "x-ng-" ], SNAKE_CASE_REGEXP = /[A-Z]/g, bindJQueryFired = !1, NODE_TYPE_ELEMENT = 1, NODE_TYPE_ATTRIBUTE = 2, NODE_TYPE_TEXT = 3, NODE_TYPE_COMMENT = 8, NODE_TYPE_DOCUMENT = 9, NODE_TYPE_DOCUMENT_FRAGMENT = 11, version = {
        full: "1.4.3",
        major: 1,
        minor: 4,
        dot: 3,
        codeName: "foam-acceleration"
    };
    JQLite.expando = "ng339";
    var jqCache = JQLite.cache = {}, jqId = 1, addEventListenerFn = function(element, type, fn) {
        element.addEventListener(type, fn, !1);
    }, removeEventListenerFn = function(element, type, fn) {
        element.removeEventListener(type, fn, !1);
    };
    JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
    };
    var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g, MOZ_HACK_REGEXP = /^moz([A-Z])/, MOUSE_EVENT_MAP = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
    }, jqLiteMinErr = minErr("jqLite"), SINGLE_TAG_REGEXP = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, HTML_REGEXP = /<|&#?\w+;/, TAG_NAME_REGEXP = /<([\w:]+)/, XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, wrapMap = {
        option: [ 1, '<select multiple="multiple">', "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    wrapMap.optgroup = wrapMap.option, wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead, 
    wrapMap.th = wrapMap.td;
    var JQLitePrototype = JQLite.prototype = {
        ready: function(fn) {
            function trigger() {
                fired || (fired = !0, fn());
            }
            var fired = !1;
            "complete" === document.readyState ? setTimeout(trigger) : (this.on("DOMContentLoaded", trigger), 
            JQLite(window).on("load", trigger));
        },
        toString: function() {
            var value = [];
            return forEach(this, function(e) {
                value.push("" + e);
            }), "[" + value.join(", ") + "]";
        },
        eq: function(index) {
            return jqLite(index >= 0 ? this[index] : this[this.length + index]);
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
    }, BOOLEAN_ATTR = {};
    forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
    });
    var BOOLEAN_ELEMENTS = {};
    forEach("input,select,option,textarea,button,form,details".split(","), function(value) {
        BOOLEAN_ELEMENTS[value] = !0;
    });
    var ALIASED_ATTR = {
        ngMinlength: "minlength",
        ngMaxlength: "maxlength",
        ngMin: "min",
        ngMax: "max",
        ngPattern: "pattern"
    };
    forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData,
        hasData: jqLiteHasData
    }, function(fn, name) {
        JQLite[name] = fn;
    }), forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
            return jqLite.data(element, "$scope") || jqLiteInheritedData(element.parentNode || element, [ "$isolateScope", "$scope" ]);
        },
        isolateScope: function(element) {
            return jqLite.data(element, "$isolateScope") || jqLite.data(element, "$isolateScopeNoTemplate");
        },
        controller: jqLiteController,
        injector: function(element) {
            return jqLiteInheritedData(element, "$injector");
        },
        removeAttr: function(element, name) {
            element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
            return name = camelCase(name), isDefined(value) ? void (element.style[name] = value) : element.style[name];
        },
        attr: function(element, name, value) {
            var nodeType = element.nodeType;
            if (nodeType !== NODE_TYPE_TEXT && nodeType !== NODE_TYPE_ATTRIBUTE && nodeType !== NODE_TYPE_COMMENT) {
                var lowercasedName = lowercase(name);
                if (BOOLEAN_ATTR[lowercasedName]) {
                    if (!isDefined(value)) return element[name] || (element.attributes.getNamedItem(name) || noop).specified ? lowercasedName : undefined;
                    value ? (element[name] = !0, element.setAttribute(name, lowercasedName)) : (element[name] = !1, 
                    element.removeAttribute(lowercasedName));
                } else if (isDefined(value)) element.setAttribute(name, value); else if (element.getAttribute) {
                    var ret = element.getAttribute(name, 2);
                    return null === ret ? undefined : ret;
                }
            }
        },
        prop: function(element, name, value) {
            return isDefined(value) ? void (element[name] = value) : element[name];
        },
        text: function() {
            function getText(element, value) {
                if (isUndefined(value)) {
                    var nodeType = element.nodeType;
                    return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT ? element.textContent : "";
                }
                element.textContent = value;
            }
            return getText.$dv = "", getText;
        }(),
        val: function(element, value) {
            if (isUndefined(value)) {
                if (element.multiple && "select" === nodeName_(element)) {
                    var result = [];
                    return forEach(element.options, function(option) {
                        option.selected && result.push(option.value || option.text);
                    }), 0 === result.length ? null : result;
                }
                return element.value;
            }
            element.value = value;
        },
        html: function(element, value) {
            return isUndefined(value) ? element.innerHTML : (jqLiteDealoc(element, !0), void (element.innerHTML = value));
        },
        empty: jqLiteEmpty
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
            var i, key, nodeCount = this.length;
            if (fn !== jqLiteEmpty && (2 == fn.length && fn !== jqLiteHasClass && fn !== jqLiteController ? arg1 : arg2) === undefined) {
                if (isObject(arg1)) {
                    for (i = 0; nodeCount > i; i++) if (fn === jqLiteData) fn(this[i], arg1); else for (key in arg1) fn(this[i], key, arg1[key]);
                    return this;
                }
                for (var value = fn.$dv, jj = value === undefined ? Math.min(nodeCount, 1) : nodeCount, j = 0; jj > j; j++) {
                    var nodeValue = fn(this[j], arg1, arg2);
                    value = value ? value + nodeValue : nodeValue;
                }
                return value;
            }
            for (i = 0; nodeCount > i; i++) fn(this[i], arg1, arg2);
            return this;
        };
    }), forEach({
        removeData: jqLiteRemoveData,
        on: function jqLiteOn(element, type, fn, unsupported) {
            if (isDefined(unsupported)) throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters");
            if (jqLiteAcceptsData(element)) {
                var expandoStore = jqLiteExpandoStore(element, !0), events = expandoStore.events, handle = expandoStore.handle;
                handle || (handle = expandoStore.handle = createEventHandler(element, events));
                for (var types = type.indexOf(" ") >= 0 ? type.split(" ") : [ type ], i = types.length; i--; ) {
                    type = types[i];
                    var eventFns = events[type];
                    eventFns || (events[type] = [], "mouseenter" === type || "mouseleave" === type ? jqLiteOn(element, MOUSE_EVENT_MAP[type], function(event) {
                        var target = this, related = event.relatedTarget;
                        (!related || related !== target && !target.contains(related)) && handle(event, type);
                    }) : "$destroy" !== type && addEventListenerFn(element, type, handle), eventFns = events[type]), 
                    eventFns.push(fn);
                }
            }
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
            element = jqLite(element), element.on(type, function onFn() {
                element.off(type, fn), element.off(type, onFn);
            }), element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
            var index, parent = element.parentNode;
            jqLiteDealoc(element), forEach(new JQLite(replaceNode), function(node) {
                index ? parent.insertBefore(node, index.nextSibling) : parent.replaceChild(node, element), 
                index = node;
            });
        },
        children: function(element) {
            var children = [];
            return forEach(element.childNodes, function(element) {
                element.nodeType === NODE_TYPE_ELEMENT && children.push(element);
            }), children;
        },
        contents: function(element) {
            return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
            var nodeType = element.nodeType;
            if (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_DOCUMENT_FRAGMENT) {
                node = new JQLite(node);
                for (var i = 0, ii = node.length; ii > i; i++) {
                    var child = node[i];
                    element.appendChild(child);
                }
            }
        },
        prepend: function(element, node) {
            if (element.nodeType === NODE_TYPE_ELEMENT) {
                var index = element.firstChild;
                forEach(new JQLite(node), function(child) {
                    element.insertBefore(child, index);
                });
            }
        },
        wrap: function(element, wrapNode) {
            wrapNode = jqLite(wrapNode).eq(0).clone()[0];
            var parent = element.parentNode;
            parent && parent.replaceChild(wrapNode, element), wrapNode.appendChild(element);
        },
        remove: jqLiteRemove,
        detach: function(element) {
            jqLiteRemove(element, !0);
        },
        after: function(element, newElement) {
            var index = element, parent = element.parentNode;
            newElement = new JQLite(newElement);
            for (var i = 0, ii = newElement.length; ii > i; i++) {
                var node = newElement[i];
                parent.insertBefore(node, index.nextSibling), index = node;
            }
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
            selector && forEach(selector.split(" "), function(className) {
                var classCondition = condition;
                isUndefined(classCondition) && (classCondition = !jqLiteHasClass(element, className)), 
                (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
            });
        },
        parent: function(element) {
            var parent = element.parentNode;
            return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
        },
        next: function(element) {
            return element.nextElementSibling;
        },
        find: function(element, selector) {
            return element.getElementsByTagName ? element.getElementsByTagName(selector) : [];
        },
        clone: jqLiteClone,
        triggerHandler: function(element, event, extraParameters) {
            var dummyEvent, eventFnsCopy, handlerArgs, eventName = event.type || event, expandoStore = jqLiteExpandoStore(element), events = expandoStore && expandoStore.events, eventFns = events && events[eventName];
            eventFns && (dummyEvent = {
                preventDefault: function() {
                    this.defaultPrevented = !0;
                },
                isDefaultPrevented: function() {
                    return this.defaultPrevented === !0;
                },
                stopImmediatePropagation: function() {
                    this.immediatePropagationStopped = !0;
                },
                isImmediatePropagationStopped: function() {
                    return this.immediatePropagationStopped === !0;
                },
                stopPropagation: noop,
                type: eventName,
                target: element
            }, event.type && (dummyEvent = extend(dummyEvent, event)), eventFnsCopy = shallowCopy(eventFns), 
            handlerArgs = extraParameters ? [ dummyEvent ].concat(extraParameters) : [ dummyEvent ], 
            forEach(eventFnsCopy, function(fn) {
                dummyEvent.isImmediatePropagationStopped() || fn.apply(element, handlerArgs);
            }));
        }
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
            for (var value, i = 0, ii = this.length; ii > i; i++) isUndefined(value) ? (value = fn(this[i], arg1, arg2, arg3), 
            isDefined(value) && (value = jqLite(value))) : jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
            return isDefined(value) ? value : this;
        }, JQLite.prototype.bind = JQLite.prototype.on, JQLite.prototype.unbind = JQLite.prototype.off;
    }), HashMap.prototype = {
        put: function(key, value) {
            this[hashKey(key, this.nextUid)] = value;
        },
        get: function(key) {
            return this[hashKey(key, this.nextUid)];
        },
        remove: function(key) {
            var value = this[key = hashKey(key, this.nextUid)];
            return delete this[key], value;
        }
    };
    var $$HashMapProvider = [ function() {
        this.$get = [ function() {
            return HashMap;
        } ];
    } ], FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m, FN_ARG_SPLIT = /,/, FN_ARG = /^\s*(_?)(\S+?)\1\s*$/, STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm, $injectorMinErr = minErr("$injector");
    createInjector.$$annotate = annotate;
    var $animateMinErr = minErr("$animate"), ELEMENT_NODE = 1, NG_ANIMATE_CLASSNAME = "ng-animate", $$CoreAnimateRunnerProvider = function() {
        this.$get = [ "$q", "$$rAF", function($q, $$rAF) {
            function AnimateRunner() {}
            return AnimateRunner.all = noop, AnimateRunner.chain = noop, AnimateRunner.prototype = {
                end: noop,
                cancel: noop,
                resume: noop,
                pause: noop,
                complete: noop,
                then: function(pass, fail) {
                    return $q(function(resolve) {
                        $$rAF(function() {
                            resolve();
                        });
                    }).then(pass, fail);
                }
            }, AnimateRunner;
        } ];
    }, $$CoreAnimateQueueProvider = function() {
        var postDigestQueue = new HashMap(), postDigestElements = [];
        this.$get = [ "$$AnimateRunner", "$rootScope", function($$AnimateRunner, $rootScope) {
            function addRemoveClassesPostDigest(element, add, remove) {
                var data = postDigestQueue.get(element);
                data || (postDigestQueue.put(element, data = {}), postDigestElements.push(element)), 
                add && forEach(add.split(" "), function(className) {
                    className && (data[className] = !0);
                }), remove && forEach(remove.split(" "), function(className) {
                    className && (data[className] = !1);
                }), postDigestElements.length > 1 || $rootScope.$$postDigest(function() {
                    forEach(postDigestElements, function(element) {
                        var data = postDigestQueue.get(element);
                        if (data) {
                            var existing = splitClasses(element.attr("class")), toAdd = "", toRemove = "";
                            forEach(data, function(status, className) {
                                var hasClass = !!existing[className];
                                status !== hasClass && (status ? toAdd += (toAdd.length ? " " : "") + className : toRemove += (toRemove.length ? " " : "") + className);
                            }), forEach(element, function(elm) {
                                toAdd && jqLiteAddClass(elm, toAdd), toRemove && jqLiteRemoveClass(elm, toRemove);
                            }), postDigestQueue.remove(element);
                        }
                    }), postDigestElements.length = 0;
                });
            }
            return {
                enabled: noop,
                on: noop,
                off: noop,
                pin: noop,
                push: function(element, event, options, domOperation) {
                    return domOperation && domOperation(), options = options || {}, options.from && element.css(options.from), 
                    options.to && element.css(options.to), (options.addClass || options.removeClass) && addRemoveClassesPostDigest(element, options.addClass, options.removeClass), 
                    new $$AnimateRunner();
                }
            };
        } ];
    }, $AnimateProvider = [ "$provide", function($provide) {
        var provider = this;
        this.$$registeredAnimations = Object.create(null), this.register = function(name, factory) {
            if (name && "." !== name.charAt(0)) throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name);
            var key = name + "-animation";
            provider.$$registeredAnimations[name.substr(1)] = key, $provide.factory(key, factory);
        }, this.classNameFilter = function(expression) {
            if (1 === arguments.length && (this.$$classNameFilter = expression instanceof RegExp ? expression : null, 
            this.$$classNameFilter)) {
                var reservedRegex = new RegExp("(\\s+|\\/)" + NG_ANIMATE_CLASSNAME + "(\\s+|\\/)");
                if (reservedRegex.test(this.$$classNameFilter.toString())) throw $animateMinErr("nongcls", '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
            }
            return this.$$classNameFilter;
        }, this.$get = [ "$$animateQueue", function($$animateQueue) {
            function domInsert(element, parentElement, afterElement) {
                if (afterElement) {
                    var afterNode = extractElementNode(afterElement);
                    !afterNode || afterNode.parentNode || afterNode.previousElementSibling || (afterElement = null);
                }
                afterElement ? afterElement.after(element) : parentElement.prepend(element);
            }
            return {
                on: $$animateQueue.on,
                off: $$animateQueue.off,
                pin: $$animateQueue.pin,
                enabled: $$animateQueue.enabled,
                cancel: function(runner) {
                    runner.end && runner.end();
                },
                enter: function(element, parent, after, options) {
                    return parent = parent && jqLite(parent), after = after && jqLite(after), parent = parent || after.parent(), 
                    domInsert(element, parent, after), $$animateQueue.push(element, "enter", prepareAnimateOptions(options));
                },
                move: function(element, parent, after, options) {
                    return parent = parent && jqLite(parent), after = after && jqLite(after), parent = parent || after.parent(), 
                    domInsert(element, parent, after), $$animateQueue.push(element, "move", prepareAnimateOptions(options));
                },
                leave: function(element, options) {
                    return $$animateQueue.push(element, "leave", prepareAnimateOptions(options), function() {
                        element.remove();
                    });
                },
                addClass: function(element, className, options) {
                    return options = prepareAnimateOptions(options), options.addClass = mergeClasses(options.addclass, className), 
                    $$animateQueue.push(element, "addClass", options);
                },
                removeClass: function(element, className, options) {
                    return options = prepareAnimateOptions(options), options.removeClass = mergeClasses(options.removeClass, className), 
                    $$animateQueue.push(element, "removeClass", options);
                },
                setClass: function(element, add, remove, options) {
                    return options = prepareAnimateOptions(options), options.addClass = mergeClasses(options.addClass, add), 
                    options.removeClass = mergeClasses(options.removeClass, remove), $$animateQueue.push(element, "setClass", options);
                },
                animate: function(element, from, to, className, options) {
                    return options = prepareAnimateOptions(options), options.from = options.from ? extend(options.from, from) : from, 
                    options.to = options.to ? extend(options.to, to) : to, className = className || "ng-inline-animate", 
                    options.tempClasses = mergeClasses(options.tempClasses, className), $$animateQueue.push(element, "animate", options);
                }
            };
        } ];
    } ], $compileMinErr = minErr("$compile");
    $CompileProvider.$inject = [ "$provide", "$$sanitizeUriProvider" ];
    var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i, $controllerMinErr = minErr("$controller"), CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/, APPLICATION_JSON = "application/json", CONTENT_TYPE_APPLICATION_JSON = {
        "Content-Type": APPLICATION_JSON + ";charset=utf-8"
    }, JSON_START = /^\[|^\{(?!\{)/, JSON_ENDS = {
        "[": /]$/,
        "{": /}$/
    }, JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/, $interpolateMinErr = angular.$interpolateMinErr = minErr("$interpolate");
    $interpolateMinErr.throwNoconcat = function(text) {
        throw $interpolateMinErr("noconcat", "Error while interpolating: {0}\nStrict Contextual Escaping disallows interpolations that concatenate multiple expressions when a trusted value is required.  See http://docs.angularjs.org/api/ng.$sce", text);
    }, $interpolateMinErr.interr = function(text, err) {
        return $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
    };
    var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/, DEFAULT_PORTS = {
        http: 80,
        https: 443,
        ftp: 21
    }, $locationMinErr = minErr("$location"), locationPrototype = {
        $$html5: !1,
        $$replace: !1,
        absUrl: locationGetter("$$absUrl"),
        url: function(url) {
            if (isUndefined(url)) return this.$$url;
            var match = PATH_MATCH.exec(url);
            return (match[1] || "" === url) && this.path(decodeURIComponent(match[1])), (match[2] || match[1] || "" === url) && this.search(match[3] || ""), 
            this.hash(match[5] || ""), this;
        },
        protocol: locationGetter("$$protocol"),
        host: locationGetter("$$host"),
        port: locationGetter("$$port"),
        path: locationGetterSetter("$$path", function(path) {
            return path = null !== path ? path.toString() : "", "/" == path.charAt(0) ? path : "/" + path;
        }),
        search: function(search, paramValue) {
            switch (arguments.length) {
              case 0:
                return this.$$search;

              case 1:
                if (isString(search) || isNumber(search)) search = search.toString(), this.$$search = parseKeyValue(search); else {
                    if (!isObject(search)) throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.");
                    search = copy(search, {}), forEach(search, function(value, key) {
                        null == value && delete search[key];
                    }), this.$$search = search;
                }
                break;

              default:
                isUndefined(paramValue) || null === paramValue ? delete this.$$search[search] : this.$$search[search] = paramValue;
            }
            return this.$$compose(), this;
        },
        hash: locationGetterSetter("$$hash", function(hash) {
            return null !== hash ? hash.toString() : "";
        }),
        replace: function() {
            return this.$$replace = !0, this;
        }
    };
    forEach([ LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url ], function(Location) {
        Location.prototype = Object.create(locationPrototype), Location.prototype.state = function(state) {
            if (!arguments.length) return this.$$state;
            if (Location !== LocationHtml5Url || !this.$$html5) throw $locationMinErr("nostate", "History API state support is available only in HTML5 mode and only in browsers supporting HTML5 History API");
            return this.$$state = isUndefined(state) ? null : state, this;
        };
    });
    var $parseMinErr = minErr("$parse"), CALL = Function.prototype.call, APPLY = Function.prototype.apply, BIND = Function.prototype.bind, OPERATORS = createMap();
    forEach("+ - * / % === !== == != < > <= >= && || ! = |".split(" "), function(operator) {
        OPERATORS[operator] = !0;
    });
    var ESCAPE = {
        n: "\n",
        f: "\f",
        r: "\r",
        t: "	",
        v: "",
        "'": "'",
        '"': '"'
    }, Lexer = function(options) {
        this.options = options;
    };
    Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
            for (this.text = text, this.index = 0, this.tokens = []; this.index < this.text.length; ) {
                var ch = this.text.charAt(this.index);
                if ('"' === ch || "'" === ch) this.readString(ch); else if (this.isNumber(ch) || "." === ch && this.isNumber(this.peek())) this.readNumber(); else if (this.isIdent(ch)) this.readIdent(); else if (this.is(ch, "(){}[].,;:?")) this.tokens.push({
                    index: this.index,
                    text: ch
                }), this.index++; else if (this.isWhitespace(ch)) this.index++; else {
                    var ch2 = ch + this.peek(), ch3 = ch2 + this.peek(2), op1 = OPERATORS[ch], op2 = OPERATORS[ch2], op3 = OPERATORS[ch3];
                    if (op1 || op2 || op3) {
                        var token = op3 ? ch3 : op2 ? ch2 : ch;
                        this.tokens.push({
                            index: this.index,
                            text: token,
                            operator: !0
                        }), this.index += token.length;
                    } else this.throwError("Unexpected next character ", this.index, this.index + 1);
                }
            }
            return this.tokens;
        },
        is: function(ch, chars) {
            return -1 !== chars.indexOf(ch);
        },
        peek: function(i) {
            var num = i || 1;
            return this.index + num < this.text.length ? this.text.charAt(this.index + num) : !1;
        },
        isNumber: function(ch) {
            return ch >= "0" && "9" >= ch && "string" == typeof ch;
        },
        isWhitespace: function(ch) {
            return " " === ch || "\r" === ch || "	" === ch || "\n" === ch || "" === ch || " " === ch;
        },
        isIdent: function(ch) {
            return ch >= "a" && "z" >= ch || ch >= "A" && "Z" >= ch || "_" === ch || "$" === ch;
        },
        isExpOperator: function(ch) {
            return "-" === ch || "+" === ch || this.isNumber(ch);
        },
        throwError: function(error, start, end) {
            end = end || this.index;
            var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]" : " " + end;
            throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text);
        },
        readNumber: function() {
            for (var number = "", start = this.index; this.index < this.text.length; ) {
                var ch = lowercase(this.text.charAt(this.index));
                if ("." == ch || this.isNumber(ch)) number += ch; else {
                    var peekCh = this.peek();
                    if ("e" == ch && this.isExpOperator(peekCh)) number += ch; else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && "e" == number.charAt(number.length - 1)) number += ch; else {
                        if (!this.isExpOperator(ch) || peekCh && this.isNumber(peekCh) || "e" != number.charAt(number.length - 1)) break;
                        this.throwError("Invalid exponent");
                    }
                }
                this.index++;
            }
            this.tokens.push({
                index: start,
                text: number,
                constant: !0,
                value: Number(number)
            });
        },
        readIdent: function() {
            for (var start = this.index; this.index < this.text.length; ) {
                var ch = this.text.charAt(this.index);
                if (!this.isIdent(ch) && !this.isNumber(ch)) break;
                this.index++;
            }
            this.tokens.push({
                index: start,
                text: this.text.slice(start, this.index),
                identifier: !0
            });
        },
        readString: function(quote) {
            var start = this.index;
            this.index++;
            for (var string = "", rawString = quote, escape = !1; this.index < this.text.length; ) {
                var ch = this.text.charAt(this.index);
                if (rawString += ch, escape) {
                    if ("u" === ch) {
                        var hex = this.text.substring(this.index + 1, this.index + 5);
                        hex.match(/[\da-f]{4}/i) || this.throwError("Invalid unicode escape [\\u" + hex + "]"), 
                        this.index += 4, string += String.fromCharCode(parseInt(hex, 16));
                    } else {
                        var rep = ESCAPE[ch];
                        string += rep || ch;
                    }
                    escape = !1;
                } else if ("\\" === ch) escape = !0; else {
                    if (ch === quote) return this.index++, void this.tokens.push({
                        index: start,
                        text: rawString,
                        constant: !0,
                        value: string
                    });
                    string += ch;
                }
                this.index++;
            }
            this.throwError("Unterminated quote", start);
        }
    };
    var AST = function(lexer, options) {
        this.lexer = lexer, this.options = options;
    };
    AST.Program = "Program", AST.ExpressionStatement = "ExpressionStatement", AST.AssignmentExpression = "AssignmentExpression", 
    AST.ConditionalExpression = "ConditionalExpression", AST.LogicalExpression = "LogicalExpression", 
    AST.BinaryExpression = "BinaryExpression", AST.UnaryExpression = "UnaryExpression", 
    AST.CallExpression = "CallExpression", AST.MemberExpression = "MemberExpression", 
    AST.Identifier = "Identifier", AST.Literal = "Literal", AST.ArrayExpression = "ArrayExpression", 
    AST.Property = "Property", AST.ObjectExpression = "ObjectExpression", AST.ThisExpression = "ThisExpression", 
    AST.NGValueParameter = "NGValueParameter", AST.prototype = {
        ast: function(text) {
            this.text = text, this.tokens = this.lexer.lex(text);
            var value = this.program();
            return 0 !== this.tokens.length && this.throwError("is an unexpected token", this.tokens[0]), 
            value;
        },
        program: function() {
            for (var body = []; ;) if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]") && body.push(this.expressionStatement()), 
            !this.expect(";")) return {
                type: AST.Program,
                body: body
            };
        },
        expressionStatement: function() {
            return {
                type: AST.ExpressionStatement,
                expression: this.filterChain()
            };
        },
        filterChain: function() {
            for (var token, left = this.expression(); token = this.expect("|"); ) left = this.filter(left);
            return left;
        },
        expression: function() {
            return this.assignment();
        },
        assignment: function() {
            var result = this.ternary();
            return this.expect("=") && (result = {
                type: AST.AssignmentExpression,
                left: result,
                right: this.assignment(),
                operator: "="
            }), result;
        },
        ternary: function() {
            var alternate, consequent, test = this.logicalOR();
            return this.expect("?") && (alternate = this.expression(), this.consume(":")) ? (consequent = this.expression(), 
            {
                type: AST.ConditionalExpression,
                test: test,
                alternate: alternate,
                consequent: consequent
            }) : test;
        },
        logicalOR: function() {
            for (var left = this.logicalAND(); this.expect("||"); ) left = {
                type: AST.LogicalExpression,
                operator: "||",
                left: left,
                right: this.logicalAND()
            };
            return left;
        },
        logicalAND: function() {
            for (var left = this.equality(); this.expect("&&"); ) left = {
                type: AST.LogicalExpression,
                operator: "&&",
                left: left,
                right: this.equality()
            };
            return left;
        },
        equality: function() {
            for (var token, left = this.relational(); token = this.expect("==", "!=", "===", "!=="); ) left = {
                type: AST.BinaryExpression,
                operator: token.text,
                left: left,
                right: this.relational()
            };
            return left;
        },
        relational: function() {
            for (var token, left = this.additive(); token = this.expect("<", ">", "<=", ">="); ) left = {
                type: AST.BinaryExpression,
                operator: token.text,
                left: left,
                right: this.additive()
            };
            return left;
        },
        additive: function() {
            for (var token, left = this.multiplicative(); token = this.expect("+", "-"); ) left = {
                type: AST.BinaryExpression,
                operator: token.text,
                left: left,
                right: this.multiplicative()
            };
            return left;
        },
        multiplicative: function() {
            for (var token, left = this.unary(); token = this.expect("*", "/", "%"); ) left = {
                type: AST.BinaryExpression,
                operator: token.text,
                left: left,
                right: this.unary()
            };
            return left;
        },
        unary: function() {
            var token;
            return (token = this.expect("+", "-", "!")) ? {
                type: AST.UnaryExpression,
                operator: token.text,
                prefix: !0,
                argument: this.unary()
            } : this.primary();
        },
        primary: function() {
            var primary;
            this.expect("(") ? (primary = this.filterChain(), this.consume(")")) : this.expect("[") ? primary = this.arrayDeclaration() : this.expect("{") ? primary = this.object() : this.constants.hasOwnProperty(this.peek().text) ? primary = copy(this.constants[this.consume().text]) : this.peek().identifier ? primary = this.identifier() : this.peek().constant ? primary = this.constant() : this.throwError("not a primary expression", this.peek());
            for (var next; next = this.expect("(", "[", "."); ) "(" === next.text ? (primary = {
                type: AST.CallExpression,
                callee: primary,
                arguments: this.parseArguments()
            }, this.consume(")")) : "[" === next.text ? (primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.expression(),
                computed: !0
            }, this.consume("]")) : "." === next.text ? primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.identifier(),
                computed: !1
            } : this.throwError("IMPOSSIBLE");
            return primary;
        },
        filter: function(baseExpression) {
            for (var args = [ baseExpression ], result = {
                type: AST.CallExpression,
                callee: this.identifier(),
                arguments: args,
                filter: !0
            }; this.expect(":"); ) args.push(this.expression());
            return result;
        },
        parseArguments: function() {
            var args = [];
            if (")" !== this.peekToken().text) do args.push(this.expression()); while (this.expect(","));
            return args;
        },
        identifier: function() {
            var token = this.consume();
            return token.identifier || this.throwError("is not a valid identifier", token), 
            {
                type: AST.Identifier,
                name: token.text
            };
        },
        constant: function() {
            return {
                type: AST.Literal,
                value: this.consume().value
            };
        },
        arrayDeclaration: function() {
            var elements = [];
            if ("]" !== this.peekToken().text) do {
                if (this.peek("]")) break;
                elements.push(this.expression());
            } while (this.expect(","));
            return this.consume("]"), {
                type: AST.ArrayExpression,
                elements: elements
            };
        },
        object: function() {
            var property, properties = [];
            if ("}" !== this.peekToken().text) do {
                if (this.peek("}")) break;
                property = {
                    type: AST.Property,
                    kind: "init"
                }, this.peek().constant ? property.key = this.constant() : this.peek().identifier ? property.key = this.identifier() : this.throwError("invalid key", this.peek()), 
                this.consume(":"), property.value = this.expression(), properties.push(property);
            } while (this.expect(","));
            return this.consume("}"), {
                type: AST.ObjectExpression,
                properties: properties
            };
        },
        throwError: function(msg, token) {
            throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index));
        },
        consume: function(e1) {
            if (0 === this.tokens.length) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            var token = this.expect(e1);
            return token || this.throwError("is unexpected, expecting [" + e1 + "]", this.peek()), 
            token;
        },
        peekToken: function() {
            if (0 === this.tokens.length) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
            return this.peekAhead(0, e1, e2, e3, e4);
        },
        peekAhead: function(i, e1, e2, e3, e4) {
            if (this.tokens.length > i) {
                var token = this.tokens[i], t = token.text;
                if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) return token;
            }
            return !1;
        },
        expect: function(e1, e2, e3, e4) {
            var token = this.peek(e1, e2, e3, e4);
            return token ? (this.tokens.shift(), token) : !1;
        },
        constants: {
            "true": {
                type: AST.Literal,
                value: !0
            },
            "false": {
                type: AST.Literal,
                value: !1
            },
            "null": {
                type: AST.Literal,
                value: null
            },
            undefined: {
                type: AST.Literal,
                value: undefined
            },
            "this": {
                type: AST.ThisExpression
            }
        }
    }, ASTCompiler.prototype = {
        compile: function(expression, expensiveChecks) {
            var self = this, ast = this.astBuilder.ast(expression);
            this.state = {
                nextId: 0,
                filters: {},
                expensiveChecks: expensiveChecks,
                fn: {
                    vars: [],
                    body: [],
                    own: {}
                },
                assign: {
                    vars: [],
                    body: [],
                    own: {}
                },
                inputs: []
            }, findConstantAndWatchExpressions(ast, self.$filter);
            var assignable, extra = "";
            if (this.stage = "assign", assignable = assignableAST(ast)) {
                this.state.computing = "assign";
                var result = this.nextId();
                this.recurse(assignable, result), extra = "fn.assign=" + this.generateFunction("assign", "s,v,l");
            }
            var toWatch = getInputs(ast.body);
            self.stage = "inputs", forEach(toWatch, function(watch, key) {
                var fnKey = "fn" + key;
                self.state[fnKey] = {
                    vars: [],
                    body: [],
                    own: {}
                }, self.state.computing = fnKey;
                var intoId = self.nextId();
                self.recurse(watch, intoId), self.return_(intoId), self.state.inputs.push(fnKey), 
                watch.watchId = key;
            }), this.state.computing = "fn", this.stage = "main", this.recurse(ast);
            var fnString = '"' + this.USE + " " + this.STRICT + '";\n' + this.filterPrefix() + "var fn=" + this.generateFunction("fn", "s,l,a,i") + extra + this.watchFns() + "return fn;", fn = new Function("$filter", "ensureSafeMemberName", "ensureSafeObject", "ensureSafeFunction", "ifDefined", "plus", "text", fnString)(this.$filter, ensureSafeMemberName, ensureSafeObject, ensureSafeFunction, ifDefined, plusFn, expression);
            return this.state = this.stage = undefined, fn.literal = isLiteral(ast), fn.constant = isConstant(ast), 
            fn;
        },
        USE: "use",
        STRICT: "strict",
        watchFns: function() {
            var result = [], fns = this.state.inputs, self = this;
            return forEach(fns, function(name) {
                result.push("var " + name + "=" + self.generateFunction(name, "s"));
            }), fns.length && result.push("fn.inputs=[" + fns.join(",") + "];"), result.join("");
        },
        generateFunction: function(name, params) {
            return "function(" + params + "){" + this.varsPrefix(name) + this.body(name) + "};";
        },
        filterPrefix: function() {
            var parts = [], self = this;
            return forEach(this.state.filters, function(id, filter) {
                parts.push(id + "=$filter(" + self.escape(filter) + ")");
            }), parts.length ? "var " + parts.join(",") + ";" : "";
        },
        varsPrefix: function(section) {
            return this.state[section].vars.length ? "var " + this.state[section].vars.join(",") + ";" : "";
        },
        body: function(section) {
            return this.state[section].body.join("");
        },
        recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
            var left, right, args, expression, self = this;
            if (recursionFn = recursionFn || noop, !skipWatchIdCheck && isDefined(ast.watchId)) return intoId = intoId || this.nextId(), 
            void this.if_("i", this.lazyAssign(intoId, this.computedMember("i", ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, !0));
            switch (ast.type) {
              case AST.Program:
                forEach(ast.body, function(expression, pos) {
                    self.recurse(expression.expression, undefined, undefined, function(expr) {
                        right = expr;
                    }), pos !== ast.body.length - 1 ? self.current().body.push(right, ";") : self.return_(right);
                });
                break;

              case AST.Literal:
                expression = this.escape(ast.value), this.assign(intoId, expression), recursionFn(expression);
                break;

              case AST.UnaryExpression:
                this.recurse(ast.argument, undefined, undefined, function(expr) {
                    right = expr;
                }), expression = ast.operator + "(" + this.ifDefined(right, 0) + ")", this.assign(intoId, expression), 
                recursionFn(expression);
                break;

              case AST.BinaryExpression:
                this.recurse(ast.left, undefined, undefined, function(expr) {
                    left = expr;
                }), this.recurse(ast.right, undefined, undefined, function(expr) {
                    right = expr;
                }), expression = "+" === ast.operator ? this.plus(left, right) : "-" === ast.operator ? this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0) : "(" + left + ")" + ast.operator + "(" + right + ")", 
                this.assign(intoId, expression), recursionFn(expression);
                break;

              case AST.LogicalExpression:
                intoId = intoId || this.nextId(), self.recurse(ast.left, intoId), self.if_("&&" === ast.operator ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId)), 
                recursionFn(intoId);
                break;

              case AST.ConditionalExpression:
                intoId = intoId || this.nextId(), self.recurse(ast.test, intoId), self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId)), 
                recursionFn(intoId);
                break;

              case AST.Identifier:
                intoId = intoId || this.nextId(), nameId && (nameId.context = "inputs" === self.stage ? "s" : this.assign(this.nextId(), this.getHasOwnProperty("l", ast.name) + "?l:s"), 
                nameId.computed = !1, nameId.name = ast.name), ensureSafeMemberName(ast.name), self.if_("inputs" === self.stage || self.not(self.getHasOwnProperty("l", ast.name)), function() {
                    self.if_("inputs" === self.stage || "s", function() {
                        create && 1 !== create && self.if_(self.not(self.nonComputedMember("s", ast.name)), self.lazyAssign(self.nonComputedMember("s", ast.name), "{}")), 
                        self.assign(intoId, self.nonComputedMember("s", ast.name));
                    });
                }, intoId && self.lazyAssign(intoId, self.nonComputedMember("l", ast.name))), (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) && self.addEnsureSafeObject(intoId), 
                recursionFn(intoId);
                break;

              case AST.MemberExpression:
                left = nameId && (nameId.context = this.nextId()) || this.nextId(), intoId = intoId || this.nextId(), 
                self.recurse(ast.object, left, undefined, function() {
                    self.if_(self.notNull(left), function() {
                        ast.computed ? (right = self.nextId(), self.recurse(ast.property, right), self.addEnsureSafeMemberName(right), 
                        create && 1 !== create && self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), "{}")), 
                        expression = self.ensureSafeObject(self.computedMember(left, right)), self.assign(intoId, expression), 
                        nameId && (nameId.computed = !0, nameId.name = right)) : (ensureSafeMemberName(ast.property.name), 
                        create && 1 !== create && self.if_(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), "{}")), 
                        expression = self.nonComputedMember(left, ast.property.name), (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) && (expression = self.ensureSafeObject(expression)), 
                        self.assign(intoId, expression), nameId && (nameId.computed = !1, nameId.name = ast.property.name));
                    }, function() {
                        self.assign(intoId, "undefined");
                    }), recursionFn(intoId);
                }, !!create);
                break;

              case AST.CallExpression:
                intoId = intoId || this.nextId(), ast.filter ? (right = self.filter(ast.callee.name), 
                args = [], forEach(ast.arguments, function(expr) {
                    var argument = self.nextId();
                    self.recurse(expr, argument), args.push(argument);
                }), expression = right + "(" + args.join(",") + ")", self.assign(intoId, expression), 
                recursionFn(intoId)) : (right = self.nextId(), left = {}, args = [], self.recurse(ast.callee, right, left, function() {
                    self.if_(self.notNull(right), function() {
                        self.addEnsureSafeFunction(right), forEach(ast.arguments, function(expr) {
                            self.recurse(expr, self.nextId(), undefined, function(argument) {
                                args.push(self.ensureSafeObject(argument));
                            });
                        }), left.name ? (self.state.expensiveChecks || self.addEnsureSafeObject(left.context), 
                        expression = self.member(left.context, left.name, left.computed) + "(" + args.join(",") + ")") : expression = right + "(" + args.join(",") + ")", 
                        expression = self.ensureSafeObject(expression), self.assign(intoId, expression);
                    }, function() {
                        self.assign(intoId, "undefined");
                    }), recursionFn(intoId);
                }));
                break;

              case AST.AssignmentExpression:
                if (right = this.nextId(), left = {}, !isAssignable(ast.left)) throw $parseMinErr("lval", "Trying to assing a value to a non l-value");
                this.recurse(ast.left, undefined, left, function() {
                    self.if_(self.notNull(left.context), function() {
                        self.recurse(ast.right, right), self.addEnsureSafeObject(self.member(left.context, left.name, left.computed)), 
                        expression = self.member(left.context, left.name, left.computed) + ast.operator + right, 
                        self.assign(intoId, expression), recursionFn(intoId || expression);
                    });
                }, 1);
                break;

              case AST.ArrayExpression:
                args = [], forEach(ast.elements, function(expr) {
                    self.recurse(expr, self.nextId(), undefined, function(argument) {
                        args.push(argument);
                    });
                }), expression = "[" + args.join(",") + "]", this.assign(intoId, expression), recursionFn(expression);
                break;

              case AST.ObjectExpression:
                args = [], forEach(ast.properties, function(property) {
                    self.recurse(property.value, self.nextId(), undefined, function(expr) {
                        args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : "" + property.key.value) + ":" + expr);
                    });
                }), expression = "{" + args.join(",") + "}", this.assign(intoId, expression), recursionFn(expression);
                break;

              case AST.ThisExpression:
                this.assign(intoId, "s"), recursionFn("s");
                break;

              case AST.NGValueParameter:
                this.assign(intoId, "v"), recursionFn("v");
            }
        },
        getHasOwnProperty: function(element, property) {
            var key = element + "." + property, own = this.current().own;
            return own.hasOwnProperty(key) || (own[key] = this.nextId(!1, element + "&&(" + this.escape(property) + " in " + element + ")")), 
            own[key];
        },
        assign: function(id, value) {
            return id ? (this.current().body.push(id, "=", value, ";"), id) : void 0;
        },
        filter: function(filterName) {
            return this.state.filters.hasOwnProperty(filterName) || (this.state.filters[filterName] = this.nextId(!0)), 
            this.state.filters[filterName];
        },
        ifDefined: function(id, defaultValue) {
            return "ifDefined(" + id + "," + this.escape(defaultValue) + ")";
        },
        plus: function(left, right) {
            return "plus(" + left + "," + right + ")";
        },
        return_: function(id) {
            this.current().body.push("return ", id, ";");
        },
        if_: function(test, alternate, consequent) {
            if (test === !0) alternate(); else {
                var body = this.current().body;
                body.push("if(", test, "){"), alternate(), body.push("}"), consequent && (body.push("else{"), 
                consequent(), body.push("}"));
            }
        },
        not: function(expression) {
            return "!(" + expression + ")";
        },
        notNull: function(expression) {
            return expression + "!=null";
        },
        nonComputedMember: function(left, right) {
            return left + "." + right;
        },
        computedMember: function(left, right) {
            return left + "[" + right + "]";
        },
        member: function(left, right, computed) {
            return computed ? this.computedMember(left, right) : this.nonComputedMember(left, right);
        },
        addEnsureSafeObject: function(item) {
            this.current().body.push(this.ensureSafeObject(item), ";");
        },
        addEnsureSafeMemberName: function(item) {
            this.current().body.push(this.ensureSafeMemberName(item), ";");
        },
        addEnsureSafeFunction: function(item) {
            this.current().body.push(this.ensureSafeFunction(item), ";");
        },
        ensureSafeObject: function(item) {
            return "ensureSafeObject(" + item + ",text)";
        },
        ensureSafeMemberName: function(item) {
            return "ensureSafeMemberName(" + item + ",text)";
        },
        ensureSafeFunction: function(item) {
            return "ensureSafeFunction(" + item + ",text)";
        },
        lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
            var self = this;
            return function() {
                self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
            };
        },
        lazyAssign: function(id, value) {
            var self = this;
            return function() {
                self.assign(id, value);
            };
        },
        stringEscapeRegex: /[^ a-zA-Z0-9]/g,
        stringEscapeFn: function(c) {
            return "\\u" + ("0000" + c.charCodeAt(0).toString(16)).slice(-4);
        },
        escape: function(value) {
            if (isString(value)) return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
            if (isNumber(value)) return value.toString();
            if (value === !0) return "true";
            if (value === !1) return "false";
            if (null === value) return "null";
            if ("undefined" == typeof value) return "undefined";
            throw $parseMinErr("esc", "IMPOSSIBLE");
        },
        nextId: function(skip, init) {
            var id = "v" + this.state.nextId++;
            return skip || this.current().vars.push(id + (init ? "=" + init : "")), id;
        },
        current: function() {
            return this.state[this.state.computing];
        }
    }, ASTInterpreter.prototype = {
        compile: function(expression, expensiveChecks) {
            var self = this, ast = this.astBuilder.ast(expression);
            this.expression = expression, this.expensiveChecks = expensiveChecks, findConstantAndWatchExpressions(ast, self.$filter);
            var assignable, assign;
            (assignable = assignableAST(ast)) && (assign = this.recurse(assignable));
            var inputs, toWatch = getInputs(ast.body);
            toWatch && (inputs = [], forEach(toWatch, function(watch, key) {
                var input = self.recurse(watch);
                watch.input = input, inputs.push(input), watch.watchId = key;
            }));
            var expressions = [];
            forEach(ast.body, function(expression) {
                expressions.push(self.recurse(expression.expression));
            });
            var fn = 0 === ast.body.length ? function() {} : 1 === ast.body.length ? expressions[0] : function(scope, locals) {
                var lastValue;
                return forEach(expressions, function(exp) {
                    lastValue = exp(scope, locals);
                }), lastValue;
            };
            return assign && (fn.assign = function(scope, value, locals) {
                return assign(scope, locals, value);
            }), inputs && (fn.inputs = inputs), fn.literal = isLiteral(ast), fn.constant = isConstant(ast), 
            fn;
        },
        recurse: function(ast, context, create) {
            var left, right, args, self = this;
            if (ast.input) return this.inputs(ast.input, ast.watchId);
            switch (ast.type) {
              case AST.Literal:
                return this.value(ast.value, context);

              case AST.UnaryExpression:
                return right = this.recurse(ast.argument), this["unary" + ast.operator](right, context);

              case AST.BinaryExpression:
                return left = this.recurse(ast.left), right = this.recurse(ast.right), this["binary" + ast.operator](left, right, context);

              case AST.LogicalExpression:
                return left = this.recurse(ast.left), right = this.recurse(ast.right), this["binary" + ast.operator](left, right, context);

              case AST.ConditionalExpression:
                return this["ternary?:"](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);

              case AST.Identifier:
                return ensureSafeMemberName(ast.name, self.expression), self.identifier(ast.name, self.expensiveChecks || isPossiblyDangerousMemberName(ast.name), context, create, self.expression);

              case AST.MemberExpression:
                return left = this.recurse(ast.object, !1, !!create), ast.computed || (ensureSafeMemberName(ast.property.name, self.expression), 
                right = ast.property.name), ast.computed && (right = this.recurse(ast.property)), 
                ast.computed ? this.computedMember(left, right, context, create, self.expression) : this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);

              case AST.CallExpression:
                return args = [], forEach(ast.arguments, function(expr) {
                    args.push(self.recurse(expr));
                }), ast.filter && (right = this.$filter(ast.callee.name)), ast.filter || (right = this.recurse(ast.callee, !0)), 
                ast.filter ? function(scope, locals, assign, inputs) {
                    for (var values = [], i = 0; i < args.length; ++i) values.push(args[i](scope, locals, assign, inputs));
                    var value = right.apply(undefined, values, inputs);
                    return context ? {
                        context: undefined,
                        name: undefined,
                        value: value
                    } : value;
                } : function(scope, locals, assign, inputs) {
                    var value, rhs = right(scope, locals, assign, inputs);
                    if (null != rhs.value) {
                        ensureSafeObject(rhs.context, self.expression), ensureSafeFunction(rhs.value, self.expression);
                        for (var values = [], i = 0; i < args.length; ++i) values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), self.expression));
                        value = ensureSafeObject(rhs.value.apply(rhs.context, values), self.expression);
                    }
                    return context ? {
                        value: value
                    } : value;
                };

              case AST.AssignmentExpression:
                return left = this.recurse(ast.left, !0, 1), right = this.recurse(ast.right), function(scope, locals, assign, inputs) {
                    var lhs = left(scope, locals, assign, inputs), rhs = right(scope, locals, assign, inputs);
                    return ensureSafeObject(lhs.value, self.expression), lhs.context[lhs.name] = rhs, 
                    context ? {
                        value: rhs
                    } : rhs;
                };

              case AST.ArrayExpression:
                return args = [], forEach(ast.elements, function(expr) {
                    args.push(self.recurse(expr));
                }), function(scope, locals, assign, inputs) {
                    for (var value = [], i = 0; i < args.length; ++i) value.push(args[i](scope, locals, assign, inputs));
                    return context ? {
                        value: value
                    } : value;
                };

              case AST.ObjectExpression:
                return args = [], forEach(ast.properties, function(property) {
                    args.push({
                        key: property.key.type === AST.Identifier ? property.key.name : "" + property.key.value,
                        value: self.recurse(property.value)
                    });
                }), function(scope, locals, assign, inputs) {
                    for (var value = {}, i = 0; i < args.length; ++i) value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                    return context ? {
                        value: value
                    } : value;
                };

              case AST.ThisExpression:
                return function(scope) {
                    return context ? {
                        value: scope
                    } : scope;
                };

              case AST.NGValueParameter:
                return function(scope, locals, assign, inputs) {
                    return context ? {
                        value: assign
                    } : assign;
                };
            }
        },
        "unary+": function(argument, context) {
            return function(scope, locals, assign, inputs) {
                var arg = argument(scope, locals, assign, inputs);
                return arg = isDefined(arg) ? +arg : 0, context ? {
                    value: arg
                } : arg;
            };
        },
        "unary-": function(argument, context) {
            return function(scope, locals, assign, inputs) {
                var arg = argument(scope, locals, assign, inputs);
                return arg = isDefined(arg) ? -arg : 0, context ? {
                    value: arg
                } : arg;
            };
        },
        "unary!": function(argument, context) {
            return function(scope, locals, assign, inputs) {
                var arg = !argument(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary+": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs), rhs = right(scope, locals, assign, inputs), arg = plusFn(lhs, rhs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary-": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs), rhs = right(scope, locals, assign, inputs), arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary*": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary/": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary%": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary===": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary!==": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary==": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary!=": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary<": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary>": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary<=": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary>=": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary&&": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary||": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "ternary?:": function(test, alternate, consequent, context) {
            return function(scope, locals, assign, inputs) {
                var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        value: function(value, context) {
            return function() {
                return context ? {
                    context: undefined,
                    name: undefined,
                    value: value
                } : value;
            };
        },
        identifier: function(name, expensiveChecks, context, create, expression) {
            return function(scope, locals, assign, inputs) {
                var base = locals && name in locals ? locals : scope;
                create && 1 !== create && base && !base[name] && (base[name] = {});
                var value = base ? base[name] : undefined;
                return expensiveChecks && ensureSafeObject(value, expression), context ? {
                    context: base,
                    name: name,
                    value: value
                } : value;
            };
        },
        computedMember: function(left, right, context, create, expression) {
            return function(scope, locals, assign, inputs) {
                var rhs, value, lhs = left(scope, locals, assign, inputs);
                return null != lhs && (rhs = right(scope, locals, assign, inputs), ensureSafeMemberName(rhs, expression), 
                create && 1 !== create && lhs && !lhs[rhs] && (lhs[rhs] = {}), value = lhs[rhs], 
                ensureSafeObject(value, expression)), context ? {
                    context: lhs,
                    name: rhs,
                    value: value
                } : value;
            };
        },
        nonComputedMember: function(left, right, expensiveChecks, context, create, expression) {
            return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                create && 1 !== create && lhs && !lhs[right] && (lhs[right] = {});
                var value = null != lhs ? lhs[right] : undefined;
                return (expensiveChecks || isPossiblyDangerousMemberName(right)) && ensureSafeObject(value, expression), 
                context ? {
                    context: lhs,
                    name: right,
                    value: value
                } : value;
            };
        },
        inputs: function(input, watchId) {
            return function(scope, value, locals, inputs) {
                return inputs ? inputs[watchId] : input(scope, value, locals);
            };
        }
    };
    var Parser = function(lexer, $filter, options) {
        this.lexer = lexer, this.$filter = $filter, this.options = options, this.ast = new AST(this.lexer), 
        this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) : new ASTCompiler(this.ast, $filter);
    };
    Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
            return this.astCompiler.compile(text, this.options.expensiveChecks);
        }
    };
    var objectValueOf = (createMap(), createMap(), Object.prototype.valueOf), $sceMinErr = minErr("$sce"), SCE_CONTEXTS = {
        HTML: "html",
        CSS: "css",
        URL: "url",
        RESOURCE_URL: "resourceUrl",
        JS: "js"
    }, $compileMinErr = minErr("$compile"), urlParsingNode = document.createElement("a"), originUrl = urlResolve(window.location.href);
    $$CookieReader.$inject = [ "$document" ], $FilterProvider.$inject = [ "$provide" ], 
    currencyFilter.$inject = [ "$locale" ], numberFilter.$inject = [ "$locale" ];
    var DECIMAL_SEP = ".", DATE_FORMATS = {
        yyyy: dateGetter("FullYear", 4),
        yy: dateGetter("FullYear", 2, 0, !0),
        y: dateGetter("FullYear", 1),
        MMMM: dateStrGetter("Month"),
        MMM: dateStrGetter("Month", !0),
        MM: dateGetter("Month", 2, 1),
        M: dateGetter("Month", 1, 1),
        dd: dateGetter("Date", 2),
        d: dateGetter("Date", 1),
        HH: dateGetter("Hours", 2),
        H: dateGetter("Hours", 1),
        hh: dateGetter("Hours", 2, -12),
        h: dateGetter("Hours", 1, -12),
        mm: dateGetter("Minutes", 2),
        m: dateGetter("Minutes", 1),
        ss: dateGetter("Seconds", 2),
        s: dateGetter("Seconds", 1),
        sss: dateGetter("Milliseconds", 3),
        EEEE: dateStrGetter("Day"),
        EEE: dateStrGetter("Day", !0),
        a: ampmGetter,
        Z: timeZoneGetter,
        ww: weekGetter(2),
        w: weekGetter(1),
        G: eraGetter,
        GG: eraGetter,
        GGG: eraGetter,
        GGGG: longEraGetter
    }, DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/, NUMBER_STRING = /^\-?\d+$/;
    dateFilter.$inject = [ "$locale" ];
    var lowercaseFilter = valueFn(lowercase), uppercaseFilter = valueFn(uppercase);
    orderByFilter.$inject = [ "$parse" ];
    var htmlAnchorDirective = valueFn({
        restrict: "E",
        compile: function(element, attr) {
            return attr.href || attr.xlinkHref ? void 0 : function(scope, element) {
                if ("a" === element[0].nodeName.toLowerCase()) {
                    var href = "[object SVGAnimatedString]" === toString.call(element.prop("href")) ? "xlink:href" : "href";
                    element.on("click", function(event) {
                        element.attr(href) || event.preventDefault();
                    });
                }
            };
        }
    }), ngAttributeAliasDirectives = {};
    forEach(BOOLEAN_ATTR, function(propName, attrName) {
        function defaultLinkFn(scope, element, attr) {
            scope.$watch(attr[normalized], function(value) {
                attr.$set(attrName, !!value);
            });
        }
        if ("multiple" != propName) {
            var normalized = directiveNormalize("ng-" + attrName), linkFn = defaultLinkFn;
            "checked" === propName && (linkFn = function(scope, element, attr) {
                attr.ngModel !== attr[normalized] && defaultLinkFn(scope, element, attr);
            }), ngAttributeAliasDirectives[normalized] = function() {
                return {
                    restrict: "A",
                    priority: 100,
                    link: linkFn
                };
            };
        }
    }), forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
        ngAttributeAliasDirectives[ngAttr] = function() {
            return {
                priority: 100,
                link: function(scope, element, attr) {
                    if ("ngPattern" === ngAttr && "/" == attr.ngPattern.charAt(0)) {
                        var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                        if (match) return void attr.$set("ngPattern", new RegExp(match[1], match[2]));
                    }
                    scope.$watch(attr[ngAttr], function(value) {
                        attr.$set(ngAttr, value);
                    });
                }
            };
        };
    }), forEach([ "src", "srcset", "href" ], function(attrName) {
        var normalized = directiveNormalize("ng-" + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
            return {
                priority: 99,
                link: function(scope, element, attr) {
                    var propName = attrName, name = attrName;
                    "href" === attrName && "[object SVGAnimatedString]" === toString.call(element.prop("href")) && (name = "xlinkHref", 
                    attr.$attr[name] = "xlink:href", propName = null), attr.$observe(normalized, function(value) {
                        return value ? (attr.$set(name, value), void (msie && propName && element.prop(propName, attr[name]))) : void ("href" === attrName && attr.$set(name, null));
                    });
                }
            };
        };
    });
    var nullFormCtrl = {
        $addControl: noop,
        $$renameControl: nullFormRenameControl,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop,
        $setSubmitted: noop
    }, SUBMITTED_CLASS = "ng-submitted";
    FormController.$inject = [ "$element", "$attrs", "$scope", "$animate", "$interpolate" ];
    var formDirectiveFactory = function(isNgForm) {
        return [ "$timeout", function($timeout) {
            var formDirective = {
                name: "form",
                restrict: isNgForm ? "EAC" : "E",
                controller: FormController,
                compile: function(formElement, attr) {
                    formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
                    var nameAttr = attr.name ? "name" : isNgForm && attr.ngForm ? "ngForm" : !1;
                    return {
                        pre: function(scope, formElement, attr, controller) {
                            if (!("action" in attr)) {
                                var handleFormSubmission = function(event) {
                                    scope.$apply(function() {
                                        controller.$commitViewValue(), controller.$setSubmitted();
                                    }), event.preventDefault();
                                };
                                addEventListenerFn(formElement[0], "submit", handleFormSubmission), formElement.on("$destroy", function() {
                                    $timeout(function() {
                                        removeEventListenerFn(formElement[0], "submit", handleFormSubmission);
                                    }, 0, !1);
                                });
                            }
                            var parentFormCtrl = controller.$$parentForm;
                            nameAttr && (setter(scope, controller.$name, controller, controller.$name), attr.$observe(nameAttr, function(newValue) {
                                controller.$name !== newValue && (setter(scope, controller.$name, undefined, controller.$name), 
                                parentFormCtrl.$$renameControl(controller, newValue), setter(scope, controller.$name, controller, controller.$name));
                            })), formElement.on("$destroy", function() {
                                parentFormCtrl.$removeControl(controller), nameAttr && setter(scope, attr[nameAttr], undefined, controller.$name), 
                                extend(controller, nullFormCtrl);
                            });
                        }
                    };
                }
            };
            return formDirective;
        } ];
    }, formDirective = formDirectiveFactory(), ngFormDirective = formDirectiveFactory(!0), ISO_DATE_REGEXP = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/, URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/, EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i, NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/, DATE_REGEXP = /^(\d{4})-(\d{2})-(\d{2})$/, DATETIMELOCAL_REGEXP = /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, WEEK_REGEXP = /^(\d{4})-W(\d\d)$/, MONTH_REGEXP = /^(\d{4})-(\d\d)$/, TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, inputType = {
        text: textInputType,
        date: createDateInputType("date", DATE_REGEXP, createDateParser(DATE_REGEXP, [ "yyyy", "MM", "dd" ]), "yyyy-MM-dd"),
        "datetime-local": createDateInputType("datetimelocal", DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, [ "yyyy", "MM", "dd", "HH", "mm", "ss", "sss" ]), "yyyy-MM-ddTHH:mm:ss.sss"),
        time: createDateInputType("time", TIME_REGEXP, createDateParser(TIME_REGEXP, [ "HH", "mm", "ss", "sss" ]), "HH:mm:ss.sss"),
        week: createDateInputType("week", WEEK_REGEXP, weekParser, "yyyy-Www"),
        month: createDateInputType("month", MONTH_REGEXP, createDateParser(MONTH_REGEXP, [ "yyyy", "MM" ]), "yyyy-MM"),
        number: numberInputType,
        url: urlInputType,
        email: emailInputType,
        radio: radioInputType,
        checkbox: checkboxInputType,
        hidden: noop,
        button: noop,
        submit: noop,
        reset: noop,
        file: noop
    }, inputDirective = [ "$browser", "$sniffer", "$filter", "$parse", function($browser, $sniffer, $filter, $parse) {
        return {
            restrict: "E",
            require: [ "?ngModel" ],
            link: {
                pre: function(scope, element, attr, ctrls) {
                    ctrls[0] && (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
                }
            }
        };
    } ], CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/, ngValueDirective = function() {
        return {
            restrict: "A",
            priority: 100,
            compile: function(tpl, tplAttr) {
                return CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue) ? function(scope, elm, attr) {
                    attr.$set("value", scope.$eval(attr.ngValue));
                } : function(scope, elm, attr) {
                    scope.$watch(attr.ngValue, function(value) {
                        attr.$set("value", value);
                    });
                };
            }
        };
    }, ngBindDirective = [ "$compile", function($compile) {
        return {
            restrict: "AC",
            compile: function(templateElement) {
                return $compile.$$addBindingClass(templateElement), function(scope, element, attr) {
                    $compile.$$addBindingInfo(element, attr.ngBind), element = element[0], scope.$watch(attr.ngBind, function(value) {
                        element.textContent = value === undefined ? "" : value;
                    });
                };
            }
        };
    } ], ngBindTemplateDirective = [ "$interpolate", "$compile", function($interpolate, $compile) {
        return {
            compile: function(templateElement) {
                return $compile.$$addBindingClass(templateElement), function(scope, element, attr) {
                    var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
                    $compile.$$addBindingInfo(element, interpolateFn.expressions), element = element[0], 
                    attr.$observe("ngBindTemplate", function(value) {
                        element.textContent = value === undefined ? "" : value;
                    });
                };
            }
        };
    } ], ngBindHtmlDirective = [ "$sce", "$parse", "$compile", function($sce, $parse, $compile) {
        return {
            restrict: "A",
            compile: function(tElement, tAttrs) {
                var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml), ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function(value) {
                    return (value || "").toString();
                });
                return $compile.$$addBindingClass(tElement), function(scope, element, attr) {
                    $compile.$$addBindingInfo(element, attr.ngBindHtml), scope.$watch(ngBindHtmlWatch, function() {
                        element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || "");
                    });
                };
            }
        };
    } ], ngChangeDirective = valueFn({
        restrict: "A",
        require: "ngModel",
        link: function(scope, element, attr, ctrl) {
            ctrl.$viewChangeListeners.push(function() {
                scope.$eval(attr.ngChange);
            });
        }
    }), ngClassDirective = classDirective("", !0), ngClassOddDirective = classDirective("Odd", 0), ngClassEvenDirective = classDirective("Even", 1), ngCloakDirective = ngDirective({
        compile: function(element, attr) {
            attr.$set("ngCloak", undefined), element.removeClass("ng-cloak");
        }
    }), ngControllerDirective = [ function() {
        return {
            restrict: "A",
            scope: !0,
            controller: "@",
            priority: 500
        };
    } ], ngEventDirectives = {}, forceAsyncEvents = {
        blur: !0,
        focus: !0
    };
    forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function(eventName) {
        var directiveName = directiveNormalize("ng-" + eventName);
        ngEventDirectives[directiveName] = [ "$parse", "$rootScope", function($parse, $rootScope) {
            return {
                restrict: "A",
                compile: function($element, attr) {
                    var fn = $parse(attr[directiveName], null, !0);
                    return function(scope, element) {
                        element.on(eventName, function(event) {
                            var callback = function() {
                                fn(scope, {
                                    $event: event
                                });
                            };
                            forceAsyncEvents[eventName] && $rootScope.$$phase ? scope.$evalAsync(callback) : scope.$apply(callback);
                        });
                    };
                }
            };
        } ];
    });
    var ngIfDirective = [ "$animate", function($animate) {
        return {
            multiElement: !0,
            transclude: "element",
            priority: 600,
            terminal: !0,
            restrict: "A",
            $$tlb: !0,
            link: function($scope, $element, $attr, ctrl, $transclude) {
                var block, childScope, previousElements;
                $scope.$watch($attr.ngIf, function(value) {
                    value ? childScope || $transclude(function(clone, newScope) {
                        childScope = newScope, clone[clone.length++] = document.createComment(" end ngIf: " + $attr.ngIf + " "), 
                        block = {
                            clone: clone
                        }, $animate.enter(clone, $element.parent(), $element);
                    }) : (previousElements && (previousElements.remove(), previousElements = null), 
                    childScope && (childScope.$destroy(), childScope = null), block && (previousElements = getBlockNodes(block.clone), 
                    $animate.leave(previousElements).then(function() {
                        previousElements = null;
                    }), block = null));
                });
            }
        };
    } ], ngIncludeDirective = [ "$templateRequest", "$anchorScroll", "$animate", function($templateRequest, $anchorScroll, $animate) {
        return {
            restrict: "ECA",
            priority: 400,
            terminal: !0,
            transclude: "element",
            controller: angular.noop,
            compile: function(element, attr) {
                var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || "", autoScrollExp = attr.autoscroll;
                return function(scope, $element, $attr, ctrl, $transclude) {
                    var currentScope, previousElement, currentElement, changeCounter = 0, cleanupLastIncludeContent = function() {
                        previousElement && (previousElement.remove(), previousElement = null), currentScope && (currentScope.$destroy(), 
                        currentScope = null), currentElement && ($animate.leave(currentElement).then(function() {
                            previousElement = null;
                        }), previousElement = currentElement, currentElement = null);
                    };
                    scope.$watch(srcExp, function(src) {
                        var afterAnimation = function() {
                            !isDefined(autoScrollExp) || autoScrollExp && !scope.$eval(autoScrollExp) || $anchorScroll();
                        }, thisChangeId = ++changeCounter;
                        src ? ($templateRequest(src, !0).then(function(response) {
                            if (thisChangeId === changeCounter) {
                                var newScope = scope.$new();
                                ctrl.template = response;
                                var clone = $transclude(newScope, function(clone) {
                                    cleanupLastIncludeContent(), $animate.enter(clone, null, $element).then(afterAnimation);
                                });
                                currentScope = newScope, currentElement = clone, currentScope.$emit("$includeContentLoaded", src), 
                                scope.$eval(onloadExp);
                            }
                        }, function() {
                            thisChangeId === changeCounter && (cleanupLastIncludeContent(), scope.$emit("$includeContentError", src));
                        }), scope.$emit("$includeContentRequested", src)) : (cleanupLastIncludeContent(), 
                        ctrl.template = null);
                    });
                };
            }
        };
    } ], ngIncludeFillContentDirective = [ "$compile", function($compile) {
        return {
            restrict: "ECA",
            priority: -400,
            require: "ngInclude",
            link: function(scope, $element, $attr, ctrl) {
                return /SVG/.test($element[0].toString()) ? ($element.empty(), void $compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(scope, function(clone) {
                    $element.append(clone);
                }, {
                    futureParentElement: $element
                })) : ($element.html(ctrl.template), void $compile($element.contents())(scope));
            }
        };
    } ], ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
            return {
                pre: function(scope, element, attrs) {
                    scope.$eval(attrs.ngInit);
                }
            };
        }
    }), ngListDirective = function() {
        return {
            restrict: "A",
            priority: 100,
            require: "ngModel",
            link: function(scope, element, attr, ctrl) {
                var ngList = element.attr(attr.$attr.ngList) || ", ", trimValues = "false" !== attr.ngTrim, separator = trimValues ? trim(ngList) : ngList, parse = function(viewValue) {
                    if (!isUndefined(viewValue)) {
                        var list = [];
                        return viewValue && forEach(viewValue.split(separator), function(value) {
                            value && list.push(trimValues ? trim(value) : value);
                        }), list;
                    }
                };
                ctrl.$parsers.push(parse), ctrl.$formatters.push(function(value) {
                    return isArray(value) ? value.join(ngList) : undefined;
                }), ctrl.$isEmpty = function(value) {
                    return !value || !value.length;
                };
            }
        };
    }, VALID_CLASS = "ng-valid", INVALID_CLASS = "ng-invalid", PRISTINE_CLASS = "ng-pristine", DIRTY_CLASS = "ng-dirty", UNTOUCHED_CLASS = "ng-untouched", TOUCHED_CLASS = "ng-touched", PENDING_CLASS = "ng-pending", $ngModelMinErr = new minErr("ngModel"), NgModelController = [ "$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", "$timeout", "$rootScope", "$q", "$interpolate", function($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
        this.$viewValue = Number.NaN, this.$modelValue = Number.NaN, this.$$rawModelValue = undefined, 
        this.$validators = {}, this.$asyncValidators = {}, this.$parsers = [], this.$formatters = [], 
        this.$viewChangeListeners = [], this.$untouched = !0, this.$touched = !1, this.$pristine = !0, 
        this.$dirty = !1, this.$valid = !0, this.$invalid = !1, this.$error = {}, this.$$success = {}, 
        this.$pending = undefined, this.$name = $interpolate($attr.name || "", !1)($scope);
        var parserValid, parsedNgModel = $parse($attr.ngModel), parsedNgModelAssign = parsedNgModel.assign, ngModelGet = parsedNgModel, ngModelSet = parsedNgModelAssign, pendingDebounce = null, ctrl = this;
        this.$$setOptions = function(options) {
            if (ctrl.$options = options, options && options.getterSetter) {
                var invokeModelGetter = $parse($attr.ngModel + "()"), invokeModelSetter = $parse($attr.ngModel + "($$$p)");
                ngModelGet = function($scope) {
                    var modelValue = parsedNgModel($scope);
                    return isFunction(modelValue) && (modelValue = invokeModelGetter($scope)), modelValue;
                }, ngModelSet = function($scope, newValue) {
                    isFunction(parsedNgModel($scope)) ? invokeModelSetter($scope, {
                        $$$p: ctrl.$modelValue
                    }) : parsedNgModelAssign($scope, ctrl.$modelValue);
                };
            } else if (!parsedNgModel.assign) throw $ngModelMinErr("nonassign", "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
        }, this.$render = noop, this.$isEmpty = function(value) {
            return isUndefined(value) || "" === value || null === value || value !== value;
        };
        var parentForm = $element.inheritedData("$formController") || nullFormCtrl, currentValidationRunId = 0;
        addSetValidityMethod({
            ctrl: this,
            $element: $element,
            set: function(object, property) {
                object[property] = !0;
            },
            unset: function(object, property) {
                delete object[property];
            },
            parentForm: parentForm,
            $animate: $animate
        }), this.$setPristine = function() {
            ctrl.$dirty = !1, ctrl.$pristine = !0, $animate.removeClass($element, DIRTY_CLASS), 
            $animate.addClass($element, PRISTINE_CLASS);
        }, this.$setDirty = function() {
            ctrl.$dirty = !0, ctrl.$pristine = !1, $animate.removeClass($element, PRISTINE_CLASS), 
            $animate.addClass($element, DIRTY_CLASS), parentForm.$setDirty();
        }, this.$setUntouched = function() {
            ctrl.$touched = !1, ctrl.$untouched = !0, $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
        }, this.$setTouched = function() {
            ctrl.$touched = !0, ctrl.$untouched = !1, $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
        }, this.$rollbackViewValue = function() {
            $timeout.cancel(pendingDebounce), ctrl.$viewValue = ctrl.$$lastCommittedViewValue, 
            ctrl.$render();
        }, this.$validate = function() {
            if (!isNumber(ctrl.$modelValue) || !isNaN(ctrl.$modelValue)) {
                var viewValue = ctrl.$$lastCommittedViewValue, modelValue = ctrl.$$rawModelValue, prevValid = ctrl.$valid, prevModelValue = ctrl.$modelValue, allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
                ctrl.$$runValidators(modelValue, viewValue, function(allValid) {
                    allowInvalid || prevValid === allValid || (ctrl.$modelValue = allValid ? modelValue : undefined, 
                    ctrl.$modelValue !== prevModelValue && ctrl.$$writeModelToScope());
                });
            }
        }, this.$$runValidators = function(modelValue, viewValue, doneCallback) {
            function processParseErrors() {
                var errorKey = ctrl.$$parserName || "parse";
                return parserValid !== undefined ? (parserValid || (forEach(ctrl.$validators, function(v, name) {
                    setValidity(name, null);
                }), forEach(ctrl.$asyncValidators, function(v, name) {
                    setValidity(name, null);
                })), setValidity(errorKey, parserValid), parserValid) : (setValidity(errorKey, null), 
                !0);
            }
            function processSyncValidators() {
                var syncValidatorsValid = !0;
                return forEach(ctrl.$validators, function(validator, name) {
                    var result = validator(modelValue, viewValue);
                    syncValidatorsValid = syncValidatorsValid && result, setValidity(name, result);
                }), syncValidatorsValid ? !0 : (forEach(ctrl.$asyncValidators, function(v, name) {
                    setValidity(name, null);
                }), !1);
            }
            function processAsyncValidators() {
                var validatorPromises = [], allValid = !0;
                forEach(ctrl.$asyncValidators, function(validator, name) {
                    var promise = validator(modelValue, viewValue);
                    if (!isPromiseLike(promise)) throw $ngModelMinErr("$asyncValidators", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
                    setValidity(name, undefined), validatorPromises.push(promise.then(function() {
                        setValidity(name, !0);
                    }, function(error) {
                        allValid = !1, setValidity(name, !1);
                    }));
                }), validatorPromises.length ? $q.all(validatorPromises).then(function() {
                    validationDone(allValid);
                }, noop) : validationDone(!0);
            }
            function setValidity(name, isValid) {
                localValidationRunId === currentValidationRunId && ctrl.$setValidity(name, isValid);
            }
            function validationDone(allValid) {
                localValidationRunId === currentValidationRunId && doneCallback(allValid);
            }
            currentValidationRunId++;
            var localValidationRunId = currentValidationRunId;
            return processParseErrors() && processSyncValidators() ? void processAsyncValidators() : void validationDone(!1);
        }, this.$commitViewValue = function() {
            var viewValue = ctrl.$viewValue;
            $timeout.cancel(pendingDebounce), (ctrl.$$lastCommittedViewValue !== viewValue || "" === viewValue && ctrl.$$hasNativeValidators) && (ctrl.$$lastCommittedViewValue = viewValue, 
            ctrl.$pristine && this.$setDirty(), this.$$parseAndValidate());
        }, this.$$parseAndValidate = function() {
            function writeToModelIfNeeded() {
                ctrl.$modelValue !== prevModelValue && ctrl.$$writeModelToScope();
            }
            var viewValue = ctrl.$$lastCommittedViewValue, modelValue = viewValue;
            if (parserValid = isUndefined(modelValue) ? undefined : !0) for (var i = 0; i < ctrl.$parsers.length; i++) if (modelValue = ctrl.$parsers[i](modelValue), 
            isUndefined(modelValue)) {
                parserValid = !1;
                break;
            }
            isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue) && (ctrl.$modelValue = ngModelGet($scope));
            var prevModelValue = ctrl.$modelValue, allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
            ctrl.$$rawModelValue = modelValue, allowInvalid && (ctrl.$modelValue = modelValue, 
            writeToModelIfNeeded()), ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, function(allValid) {
                allowInvalid || (ctrl.$modelValue = allValid ? modelValue : undefined, writeToModelIfNeeded());
            });
        }, this.$$writeModelToScope = function() {
            ngModelSet($scope, ctrl.$modelValue), forEach(ctrl.$viewChangeListeners, function(listener) {
                try {
                    listener();
                } catch (e) {
                    $exceptionHandler(e);
                }
            });
        }, this.$setViewValue = function(value, trigger) {
            ctrl.$viewValue = value, (!ctrl.$options || ctrl.$options.updateOnDefault) && ctrl.$$debounceViewValueCommit(trigger);
        }, this.$$debounceViewValueCommit = function(trigger) {
            var debounce, debounceDelay = 0, options = ctrl.$options;
            options && isDefined(options.debounce) && (debounce = options.debounce, isNumber(debounce) ? debounceDelay = debounce : isNumber(debounce[trigger]) ? debounceDelay = debounce[trigger] : isNumber(debounce["default"]) && (debounceDelay = debounce["default"])), 
            $timeout.cancel(pendingDebounce), debounceDelay ? pendingDebounce = $timeout(function() {
                ctrl.$commitViewValue();
            }, debounceDelay) : $rootScope.$$phase ? ctrl.$commitViewValue() : $scope.$apply(function() {
                ctrl.$commitViewValue();
            });
        }, $scope.$watch(function() {
            var modelValue = ngModelGet($scope);
            if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
                ctrl.$modelValue = ctrl.$$rawModelValue = modelValue, parserValid = undefined;
                for (var formatters = ctrl.$formatters, idx = formatters.length, viewValue = modelValue; idx--; ) viewValue = formatters[idx](viewValue);
                ctrl.$viewValue !== viewValue && (ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue, 
                ctrl.$render(), ctrl.$$runValidators(modelValue, viewValue, noop));
            }
            return modelValue;
        });
    } ], ngModelDirective = [ "$rootScope", function($rootScope) {
        return {
            restrict: "A",
            require: [ "ngModel", "^?form", "^?ngModelOptions" ],
            controller: NgModelController,
            priority: 1,
            compile: function(element) {
                return element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS), 
                {
                    pre: function(scope, element, attr, ctrls) {
                        var modelCtrl = ctrls[0], formCtrl = ctrls[1] || nullFormCtrl;
                        modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options), formCtrl.$addControl(modelCtrl), 
                        attr.$observe("name", function(newValue) {
                            modelCtrl.$name !== newValue && formCtrl.$$renameControl(modelCtrl, newValue);
                        }), scope.$on("$destroy", function() {
                            formCtrl.$removeControl(modelCtrl);
                        });
                    },
                    post: function(scope, element, attr, ctrls) {
                        var modelCtrl = ctrls[0];
                        modelCtrl.$options && modelCtrl.$options.updateOn && element.on(modelCtrl.$options.updateOn, function(ev) {
                            modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                        }), element.on("blur", function(ev) {
                            modelCtrl.$touched || ($rootScope.$$phase ? scope.$evalAsync(modelCtrl.$setTouched) : scope.$apply(modelCtrl.$setTouched));
                        });
                    }
                };
            }
        };
    } ], DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/, ngModelOptionsDirective = function() {
        return {
            restrict: "A",
            controller: [ "$scope", "$attrs", function($scope, $attrs) {
                var that = this;
                this.$options = copy($scope.$eval($attrs.ngModelOptions)), this.$options.updateOn !== undefined ? (this.$options.updateOnDefault = !1, 
                this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function() {
                    return that.$options.updateOnDefault = !0, " ";
                }))) : this.$options.updateOnDefault = !0;
            } ]
        };
    }, ngNonBindableDirective = ngDirective({
        terminal: !0,
        priority: 1e3
    }), ngOptionsMinErr = minErr("ngOptions"), NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/, ngOptionsDirective = [ "$compile", "$parse", function($compile, $parse) {
        function parseOptionsExpression(optionsExp, selectElement, scope) {
            function Option(selectValue, viewValue, label, group, disabled) {
                this.selectValue = selectValue, this.viewValue = viewValue, this.label = label, 
                this.group = group, this.disabled = disabled;
            }
            function getOptionValuesKeys(optionValues) {
                var optionValuesKeys;
                if (!keyName && isArrayLike(optionValues)) optionValuesKeys = optionValues; else {
                    optionValuesKeys = [];
                    for (var itemKey in optionValues) optionValues.hasOwnProperty(itemKey) && "$" !== itemKey.charAt(0) && optionValuesKeys.push(itemKey);
                }
                return optionValuesKeys;
            }
            var match = optionsExp.match(NG_OPTIONS_REGEXP);
            if (!match) throw ngOptionsMinErr("iexp", "Expected expression in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_' but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
            var valueName = match[5] || match[7], keyName = match[6], selectAs = / as /.test(match[0]) && match[1], trackBy = match[9], valueFn = $parse(match[2] ? match[1] : valueName), selectAsFn = selectAs && $parse(selectAs), viewValueFn = selectAsFn || valueFn, trackByFn = trackBy && $parse(trackBy), getTrackByValueFn = trackBy ? function(value, locals) {
                return trackByFn(scope, locals);
            } : function(value) {
                return hashKey(value);
            }, getTrackByValue = function(value, key) {
                return getTrackByValueFn(value, getLocals(value, key));
            }, displayFn = $parse(match[2] || match[1]), groupByFn = $parse(match[3] || ""), disableWhenFn = $parse(match[4] || ""), valuesFn = $parse(match[8]), locals = {}, getLocals = keyName ? function(value, key) {
                return locals[keyName] = key, locals[valueName] = value, locals;
            } : function(value) {
                return locals[valueName] = value, locals;
            };
            return {
                trackBy: trackBy,
                getTrackByValue: getTrackByValue,
                getWatchables: $parse(valuesFn, function(optionValues) {
                    var watchedArray = [];
                    optionValues = optionValues || [];
                    for (var optionValuesKeys = getOptionValuesKeys(optionValues), optionValuesLength = optionValuesKeys.length, index = 0; optionValuesLength > index; index++) {
                        var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index], locals = (optionValues[key], 
                        getLocals(optionValues[key], key)), selectValue = getTrackByValueFn(optionValues[key], locals);
                        if (watchedArray.push(selectValue), match[2] || match[1]) {
                            var label = displayFn(scope, locals);
                            watchedArray.push(label);
                        }
                        if (match[4]) {
                            var disableWhen = disableWhenFn(scope, locals);
                            watchedArray.push(disableWhen);
                        }
                    }
                    return watchedArray;
                }),
                getOptions: function() {
                    for (var optionItems = [], selectValueMap = {}, optionValues = valuesFn(scope) || [], optionValuesKeys = getOptionValuesKeys(optionValues), optionValuesLength = optionValuesKeys.length, index = 0; optionValuesLength > index; index++) {
                        var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index], value = optionValues[key], locals = getLocals(value, key), viewValue = viewValueFn(scope, locals), selectValue = getTrackByValueFn(viewValue, locals), label = displayFn(scope, locals), group = groupByFn(scope, locals), disabled = disableWhenFn(scope, locals), optionItem = new Option(selectValue, viewValue, label, group, disabled);
                        optionItems.push(optionItem), selectValueMap[selectValue] = optionItem;
                    }
                    return {
                        items: optionItems,
                        selectValueMap: selectValueMap,
                        getOptionFromViewValue: function(value) {
                            return selectValueMap[getTrackByValue(value)];
                        },
                        getViewValueFromOption: function(option) {
                            return trackBy ? angular.copy(option.viewValue) : option.viewValue;
                        }
                    };
                }
            };
        }
        var optionTemplate = document.createElement("option"), optGroupTemplate = document.createElement("optgroup");
        return {
            restrict: "A",
            terminal: !0,
            require: [ "select", "?ngModel" ],
            link: function(scope, selectElement, attr, ctrls) {
                function updateOptionElement(option, element) {
                    option.element = element, element.disabled = option.disabled, option.value !== element.value && (element.value = option.selectValue), 
                    option.label !== element.label && (element.label = option.label, element.textContent = option.label);
                }
                function addOrReuseElement(parent, current, type, templateElement) {
                    var element;
                    return current && lowercase(current.nodeName) === type ? element = current : (element = templateElement.cloneNode(!1), 
                    current ? parent.insertBefore(element, current) : parent.appendChild(element)), 
                    element;
                }
                function removeExcessElements(current) {
                    for (var next; current; ) next = current.nextSibling, jqLiteRemove(current), current = next;
                }
                function skipEmptyAndUnknownOptions(current) {
                    var emptyOption_ = emptyOption && emptyOption[0], unknownOption_ = unknownOption && unknownOption[0];
                    if (emptyOption_ || unknownOption_) for (;current && (current === emptyOption_ || current === unknownOption_); ) current = current.nextSibling;
                    return current;
                }
                function updateOptions() {
                    var previousValue = options && selectCtrl.readValue();
                    options = ngOptions.getOptions();
                    var groupMap = {}, currentElement = selectElement[0].firstChild;
                    if (providedEmptyOption && selectElement.prepend(emptyOption), currentElement = skipEmptyAndUnknownOptions(currentElement), 
                    options.items.forEach(function(option) {
                        var group, groupElement, optionElement;
                        option.group ? (group = groupMap[option.group], group || (groupElement = addOrReuseElement(selectElement[0], currentElement, "optgroup", optGroupTemplate), 
                        currentElement = groupElement.nextSibling, groupElement.label = option.group, group = groupMap[option.group] = {
                            groupElement: groupElement,
                            currentOptionElement: groupElement.firstChild
                        }), optionElement = addOrReuseElement(group.groupElement, group.currentOptionElement, "option", optionTemplate), 
                        updateOptionElement(option, optionElement), group.currentOptionElement = optionElement.nextSibling) : (optionElement = addOrReuseElement(selectElement[0], currentElement, "option", optionTemplate), 
                        updateOptionElement(option, optionElement), currentElement = optionElement.nextSibling);
                    }), Object.keys(groupMap).forEach(function(key) {
                        removeExcessElements(groupMap[key].currentOptionElement);
                    }), removeExcessElements(currentElement), ngModelCtrl.$render(), !ngModelCtrl.$isEmpty(previousValue)) {
                        var nextValue = selectCtrl.readValue();
                        (ngOptions.trackBy ? equals(previousValue, nextValue) : previousValue === nextValue) || (ngModelCtrl.$setViewValue(nextValue), 
                        ngModelCtrl.$render());
                    }
                }
                var ngModelCtrl = ctrls[1];
                if (ngModelCtrl) {
                    for (var emptyOption, selectCtrl = ctrls[0], multiple = attr.multiple, i = 0, children = selectElement.children(), ii = children.length; ii > i; i++) if ("" === children[i].value) {
                        emptyOption = children.eq(i);
                        break;
                    }
                    var providedEmptyOption = !!emptyOption, unknownOption = jqLite(optionTemplate.cloneNode(!1));
                    unknownOption.val("?");
                    var options, ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope), renderEmptyOption = function() {
                        providedEmptyOption || selectElement.prepend(emptyOption), selectElement.val(""), 
                        emptyOption.prop("selected", !0), emptyOption.attr("selected", !0);
                    }, removeEmptyOption = function() {
                        providedEmptyOption || emptyOption.remove();
                    }, renderUnknownOption = function() {
                        selectElement.prepend(unknownOption), selectElement.val("?"), unknownOption.prop("selected", !0), 
                        unknownOption.attr("selected", !0);
                    }, removeUnknownOption = function() {
                        unknownOption.remove();
                    };
                    multiple ? (ngModelCtrl.$isEmpty = function(value) {
                        return !value || 0 === value.length;
                    }, selectCtrl.writeValue = function(value) {
                        options.items.forEach(function(option) {
                            option.element.selected = !1;
                        }), value && value.forEach(function(item) {
                            var option = options.getOptionFromViewValue(item);
                            option && !option.disabled && (option.element.selected = !0);
                        });
                    }, selectCtrl.readValue = function() {
                        var selectedValues = selectElement.val() || [], selections = [];
                        return forEach(selectedValues, function(value) {
                            var option = options.selectValueMap[value];
                            option.disabled || selections.push(options.getViewValueFromOption(option));
                        }), selections;
                    }, ngOptions.trackBy && scope.$watchCollection(function() {
                        return isArray(ngModelCtrl.$viewValue) ? ngModelCtrl.$viewValue.map(function(value) {
                            return ngOptions.getTrackByValue(value);
                        }) : void 0;
                    }, function() {
                        ngModelCtrl.$render();
                    })) : (selectCtrl.writeValue = function(value) {
                        var option = options.getOptionFromViewValue(value);
                        option && !option.disabled ? selectElement[0].value !== option.selectValue && (removeUnknownOption(), 
                        removeEmptyOption(), selectElement[0].value = option.selectValue, option.element.selected = !0, 
                        option.element.setAttribute("selected", "selected")) : null === value || providedEmptyOption ? (removeUnknownOption(), 
                        renderEmptyOption()) : (removeEmptyOption(), renderUnknownOption());
                    }, selectCtrl.readValue = function() {
                        var selectedOption = options.selectValueMap[selectElement.val()];
                        return selectedOption && !selectedOption.disabled ? (removeEmptyOption(), removeUnknownOption(), 
                        options.getViewValueFromOption(selectedOption)) : null;
                    }, ngOptions.trackBy && scope.$watch(function() {
                        return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
                    }, function() {
                        ngModelCtrl.$render();
                    })), providedEmptyOption ? (emptyOption.remove(), $compile(emptyOption)(scope), 
                    emptyOption.removeClass("ng-scope")) : emptyOption = jqLite(optionTemplate.cloneNode(!1)), 
                    updateOptions(), scope.$watchCollection(ngOptions.getWatchables, updateOptions);
                }
            }
        };
    } ], ngPluralizeDirective = [ "$locale", "$interpolate", "$log", function($locale, $interpolate, $log) {
        var BRACE = /{}/g, IS_WHEN = /^when(Minus)?(.+)$/;
        return {
            link: function(scope, element, attr) {
                function updateElementText(newText) {
                    element.text(newText || "");
                }
                var lastCount, numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), braceReplacement = startSymbol + numberExp + "-" + offset + endSymbol, watchRemover = angular.noop;
                forEach(attr, function(expression, attributeName) {
                    var tmpMatch = IS_WHEN.exec(attributeName);
                    if (tmpMatch) {
                        var whenKey = (tmpMatch[1] ? "-" : "") + lowercase(tmpMatch[2]);
                        whens[whenKey] = element.attr(attr.$attr[attributeName]);
                    }
                }), forEach(whens, function(expression, key) {
                    whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
                }), scope.$watch(numberExp, function(newVal) {
                    var count = parseFloat(newVal), countIsNaN = isNaN(count);
                    if (countIsNaN || count in whens || (count = $locale.pluralCat(count - offset)), 
                    count !== lastCount && !(countIsNaN && isNumber(lastCount) && isNaN(lastCount))) {
                        watchRemover();
                        var whenExpFn = whensExpFns[count];
                        isUndefined(whenExpFn) ? (null != newVal && $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp), 
                        watchRemover = noop, updateElementText()) : watchRemover = scope.$watch(whenExpFn, updateElementText), 
                        lastCount = count;
                    }
                });
            }
        };
    } ], ngRepeatDirective = [ "$parse", "$animate", function($parse, $animate) {
        var NG_REMOVED = "$$NG_REMOVED", ngRepeatMinErr = minErr("ngRepeat"), updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
            scope[valueIdentifier] = value, keyIdentifier && (scope[keyIdentifier] = key), scope.$index = index, 
            scope.$first = 0 === index, scope.$last = index === arrayLength - 1, scope.$middle = !(scope.$first || scope.$last), 
            scope.$odd = !(scope.$even = 0 === (1 & index));
        }, getBlockStart = function(block) {
            return block.clone[0];
        }, getBlockEnd = function(block) {
            return block.clone[block.clone.length - 1];
        };
        return {
            restrict: "A",
            multiElement: !0,
            transclude: "element",
            priority: 1e3,
            terminal: !0,
            $$tlb: !0,
            compile: function($element, $attr) {
                var expression = $attr.ngRepeat, ngRepeatEndComment = document.createComment(" end ngRepeat: " + expression + " "), match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                if (!match) throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
                var lhs = match[1], rhs = match[2], aliasAs = match[3], trackByExp = match[4];
                if (match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/), 
                !match) throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
                var valueIdentifier = match[3] || match[1], keyIdentifier = match[2];
                if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) throw ngRepeatMinErr("badident", "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
                var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn, hashFnLocals = {
                    $id: hashKey
                };
                return trackByExp ? trackByExpGetter = $parse(trackByExp) : (trackByIdArrayFn = function(key, value) {
                    return hashKey(value);
                }, trackByIdObjFn = function(key) {
                    return key;
                }), function($scope, $element, $attr, ctrl, $transclude) {
                    trackByExpGetter && (trackByIdExpFn = function(key, value, index) {
                        return keyIdentifier && (hashFnLocals[keyIdentifier] = key), hashFnLocals[valueIdentifier] = value, 
                        hashFnLocals.$index = index, trackByExpGetter($scope, hashFnLocals);
                    });
                    var lastBlockMap = createMap();
                    $scope.$watchCollection(rhs, function(collection) {
                        var index, length, nextNode, collectionLength, key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder, elementsToRemove, previousNode = $element[0], nextBlockMap = createMap();
                        if (aliasAs && ($scope[aliasAs] = collection), isArrayLike(collection)) collectionKeys = collection, 
                        trackByIdFn = trackByIdExpFn || trackByIdArrayFn; else {
                            trackByIdFn = trackByIdExpFn || trackByIdObjFn, collectionKeys = [];
                            for (var itemKey in collection) collection.hasOwnProperty(itemKey) && "$" !== itemKey.charAt(0) && collectionKeys.push(itemKey);
                        }
                        for (collectionLength = collectionKeys.length, nextBlockOrder = new Array(collectionLength), 
                        index = 0; collectionLength > index; index++) if (key = collection === collectionKeys ? index : collectionKeys[index], 
                        value = collection[key], trackById = trackByIdFn(key, value, index), lastBlockMap[trackById]) block = lastBlockMap[trackById], 
                        delete lastBlockMap[trackById], nextBlockMap[trackById] = block, nextBlockOrder[index] = block; else {
                            if (nextBlockMap[trackById]) throw forEach(nextBlockOrder, function(block) {
                                block && block.scope && (lastBlockMap[block.id] = block);
                            }), ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                            nextBlockOrder[index] = {
                                id: trackById,
                                scope: undefined,
                                clone: undefined
                            }, nextBlockMap[trackById] = !0;
                        }
                        for (var blockKey in lastBlockMap) {
                            if (block = lastBlockMap[blockKey], elementsToRemove = getBlockNodes(block.clone), 
                            $animate.leave(elementsToRemove), elementsToRemove[0].parentNode) for (index = 0, 
                            length = elementsToRemove.length; length > index; index++) elementsToRemove[index][NG_REMOVED] = !0;
                            block.scope.$destroy();
                        }
                        for (index = 0; collectionLength > index; index++) if (key = collection === collectionKeys ? index : collectionKeys[index], 
                        value = collection[key], block = nextBlockOrder[index], block.scope) {
                            nextNode = previousNode;
                            do nextNode = nextNode.nextSibling; while (nextNode && nextNode[NG_REMOVED]);
                            getBlockStart(block) != nextNode && $animate.move(getBlockNodes(block.clone), null, jqLite(previousNode)), 
                            previousNode = getBlockEnd(block), updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                        } else $transclude(function(clone, scope) {
                            block.scope = scope;
                            var endNode = ngRepeatEndComment.cloneNode(!1);
                            clone[clone.length++] = endNode, $animate.enter(clone, null, jqLite(previousNode)), 
                            previousNode = endNode, block.clone = clone, nextBlockMap[block.id] = block, updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                        });
                        lastBlockMap = nextBlockMap;
                    });
                };
            }
        };
    } ], NG_HIDE_CLASS = "ng-hide", NG_HIDE_IN_PROGRESS_CLASS = "ng-hide-animate", ngShowDirective = [ "$animate", function($animate) {
        return {
            restrict: "A",
            multiElement: !0,
            link: function(scope, element, attr) {
                scope.$watch(attr.ngShow, function(value) {
                    $animate[value ? "removeClass" : "addClass"](element, NG_HIDE_CLASS, {
                        tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                    });
                });
            }
        };
    } ], ngHideDirective = [ "$animate", function($animate) {
        return {
            restrict: "A",
            multiElement: !0,
            link: function(scope, element, attr) {
                scope.$watch(attr.ngHide, function(value) {
                    $animate[value ? "addClass" : "removeClass"](element, NG_HIDE_CLASS, {
                        tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                    });
                });
            }
        };
    } ], ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watch(attr.ngStyle, function(newStyles, oldStyles) {
            oldStyles && newStyles !== oldStyles && forEach(oldStyles, function(val, style) {
                element.css(style, "");
            }), newStyles && element.css(newStyles);
        }, !0);
    }), ngSwitchDirective = [ "$animate", function($animate) {
        return {
            require: "ngSwitch",
            controller: [ "$scope", function() {
                this.cases = {};
            } ],
            link: function(scope, element, attr, ngSwitchController) {
                var watchExpr = attr.ngSwitch || attr.on, selectedTranscludes = [], selectedElements = [], previousLeaveAnimations = [], selectedScopes = [], spliceFactory = function(array, index) {
                    return function() {
                        array.splice(index, 1);
                    };
                };
                scope.$watch(watchExpr, function(value) {
                    var i, ii;
                    for (i = 0, ii = previousLeaveAnimations.length; ii > i; ++i) $animate.cancel(previousLeaveAnimations[i]);
                    for (previousLeaveAnimations.length = 0, i = 0, ii = selectedScopes.length; ii > i; ++i) {
                        var selected = getBlockNodes(selectedElements[i].clone);
                        selectedScopes[i].$destroy();
                        var promise = previousLeaveAnimations[i] = $animate.leave(selected);
                        promise.then(spliceFactory(previousLeaveAnimations, i));
                    }
                    selectedElements.length = 0, selectedScopes.length = 0, (selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"]) && forEach(selectedTranscludes, function(selectedTransclude) {
                        selectedTransclude.transclude(function(caseElement, selectedScope) {
                            selectedScopes.push(selectedScope);
                            var anchor = selectedTransclude.element;
                            caseElement[caseElement.length++] = document.createComment(" end ngSwitchWhen: ");
                            var block = {
                                clone: caseElement
                            };
                            selectedElements.push(block), $animate.enter(caseElement, anchor.parent(), anchor);
                        });
                    });
                });
            }
        };
    } ], ngSwitchWhenDirective = ngDirective({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: !0,
        link: function(scope, element, attrs, ctrl, $transclude) {
            ctrl.cases["!" + attrs.ngSwitchWhen] = ctrl.cases["!" + attrs.ngSwitchWhen] || [], 
            ctrl.cases["!" + attrs.ngSwitchWhen].push({
                transclude: $transclude,
                element: element
            });
        }
    }), ngSwitchDefaultDirective = ngDirective({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: !0,
        link: function(scope, element, attr, ctrl, $transclude) {
            ctrl.cases["?"] = ctrl.cases["?"] || [], ctrl.cases["?"].push({
                transclude: $transclude,
                element: element
            });
        }
    }), ngTranscludeDirective = ngDirective({
        restrict: "EAC",
        link: function($scope, $element, $attrs, controller, $transclude) {
            if (!$transclude) throw minErr("ngTransclude")("orphan", "Illegal use of ngTransclude directive in the template! No parent directive that requires a transclusion found. Element: {0}", startingTag($element));
            $transclude(function(clone) {
                $element.empty(), $element.append(clone);
            });
        }
    }), scriptDirective = [ "$templateCache", function($templateCache) {
        return {
            restrict: "E",
            terminal: !0,
            compile: function(element, attr) {
                if ("text/ng-template" == attr.type) {
                    var templateUrl = attr.id, text = element[0].text;
                    $templateCache.put(templateUrl, text);
                }
            }
        };
    } ], noopNgModelController = {
        $setViewValue: noop,
        $render: noop
    }, SelectController = [ "$element", "$scope", "$attrs", function($element, $scope, $attrs) {
        var self = this, optionsMap = new HashMap();
        self.ngModelCtrl = noopNgModelController, self.unknownOption = jqLite(document.createElement("option")), 
        self.renderUnknownOption = function(val) {
            var unknownVal = "? " + hashKey(val) + " ?";
            self.unknownOption.val(unknownVal), $element.prepend(self.unknownOption), $element.val(unknownVal);
        }, $scope.$on("$destroy", function() {
            self.renderUnknownOption = noop;
        }), self.removeUnknownOption = function() {
            self.unknownOption.parent() && self.unknownOption.remove();
        }, self.readValue = function() {
            return self.removeUnknownOption(), $element.val();
        }, self.writeValue = function(value) {
            self.hasOption(value) ? (self.removeUnknownOption(), $element.val(value), "" === value && self.emptyOption.prop("selected", !0)) : null == value && self.emptyOption ? (self.removeUnknownOption(), 
            $element.val("")) : self.renderUnknownOption(value);
        }, self.addOption = function(value, element) {
            assertNotHasOwnProperty(value, '"option value"'), "" === value && (self.emptyOption = element);
            var count = optionsMap.get(value) || 0;
            optionsMap.put(value, count + 1);
        }, self.removeOption = function(value) {
            var count = optionsMap.get(value);
            count && (1 === count ? (optionsMap.remove(value), "" === value && (self.emptyOption = undefined)) : optionsMap.put(value, count - 1));
        }, self.hasOption = function(value) {
            return !!optionsMap.get(value);
        };
    } ], selectDirective = function() {
        return {
            restrict: "E",
            require: [ "select", "?ngModel" ],
            controller: SelectController,
            link: function(scope, element, attr, ctrls) {
                var ngModelCtrl = ctrls[1];
                if (ngModelCtrl) {
                    var selectCtrl = ctrls[0];
                    if (selectCtrl.ngModelCtrl = ngModelCtrl, ngModelCtrl.$render = function() {
                        selectCtrl.writeValue(ngModelCtrl.$viewValue);
                    }, element.on("change", function() {
                        scope.$apply(function() {
                            ngModelCtrl.$setViewValue(selectCtrl.readValue());
                        });
                    }), attr.multiple) {
                        selectCtrl.readValue = function() {
                            var array = [];
                            return forEach(element.find("option"), function(option) {
                                option.selected && array.push(option.value);
                            }), array;
                        }, selectCtrl.writeValue = function(value) {
                            var items = new HashMap(value);
                            forEach(element.find("option"), function(option) {
                                option.selected = isDefined(items.get(option.value));
                            });
                        };
                        var lastView, lastViewRef = NaN;
                        scope.$watch(function() {
                            lastViewRef !== ngModelCtrl.$viewValue || equals(lastView, ngModelCtrl.$viewValue) || (lastView = shallowCopy(ngModelCtrl.$viewValue), 
                            ngModelCtrl.$render()), lastViewRef = ngModelCtrl.$viewValue;
                        }), ngModelCtrl.$isEmpty = function(value) {
                            return !value || 0 === value.length;
                        };
                    }
                }
            }
        };
    }, optionDirective = [ "$interpolate", function($interpolate) {
        function chromeHack(optionElement) {
            optionElement[0].hasAttribute("selected") && (optionElement[0].selected = !0);
        }
        return {
            restrict: "E",
            priority: 100,
            compile: function(element, attr) {
                if (isUndefined(attr.value)) {
                    var interpolateFn = $interpolate(element.text(), !0);
                    interpolateFn || attr.$set("value", element.text());
                }
                return function(scope, element, attr) {
                    var selectCtrlName = "$selectController", parent = element.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
                    selectCtrl && selectCtrl.ngModelCtrl && (interpolateFn ? scope.$watch(interpolateFn, function(newVal, oldVal) {
                        attr.$set("value", newVal), oldVal !== newVal && selectCtrl.removeOption(oldVal), 
                        selectCtrl.addOption(newVal, element), selectCtrl.ngModelCtrl.$render(), chromeHack(element);
                    }) : (selectCtrl.addOption(attr.value, element), selectCtrl.ngModelCtrl.$render(), 
                    chromeHack(element)), element.on("$destroy", function() {
                        selectCtrl.removeOption(attr.value), selectCtrl.ngModelCtrl.$render();
                    }));
                };
            }
        };
    } ], styleDirective = valueFn({
        restrict: "E",
        terminal: !1
    }), requiredDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                ctrl && (attr.required = !0, ctrl.$validators.required = function(modelValue, viewValue) {
                    return !attr.required || !ctrl.$isEmpty(viewValue);
                }, attr.$observe("required", function() {
                    ctrl.$validate();
                }));
            }
        };
    }, patternDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (ctrl) {
                    var regexp, patternExp = attr.ngPattern || attr.pattern;
                    attr.$observe("pattern", function(regex) {
                        if (isString(regex) && regex.length > 0 && (regex = new RegExp("^" + regex + "$")), 
                        regex && !regex.test) throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", patternExp, regex, startingTag(elm));
                        regexp = regex || undefined, ctrl.$validate();
                    }), ctrl.$validators.pattern = function(value) {
                        return ctrl.$isEmpty(value) || isUndefined(regexp) || regexp.test(value);
                    };
                }
            }
        };
    }, maxlengthDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (ctrl) {
                    var maxlength = -1;
                    attr.$observe("maxlength", function(value) {
                        var intVal = toInt(value);
                        maxlength = isNaN(intVal) ? -1 : intVal, ctrl.$validate();
                    }), ctrl.$validators.maxlength = function(modelValue, viewValue) {
                        return 0 > maxlength || ctrl.$isEmpty(viewValue) || viewValue.length <= maxlength;
                    };
                }
            }
        };
    }, minlengthDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (ctrl) {
                    var minlength = 0;
                    attr.$observe("minlength", function(value) {
                        minlength = toInt(value) || 0, ctrl.$validate();
                    }), ctrl.$validators.minlength = function(modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
                    };
                }
            }
        };
    };
    return window.angular.bootstrap ? void console.log("WARNING: Tried to load angular more than once.") : (bindJQuery(), 
    publishExternalAPI(angular), void jqLite(document).ready(function() {
        angularInit(document, bootstrap);
    }));
}(window, document), !window.angular.$$csp() && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>'), 
function(window, angular, undefined) {
    "use strict";
    function assertArg(arg, name, reason) {
        if (!arg) throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
        return arg;
    }
    function mergeClasses(a, b) {
        return a || b ? a ? b ? (isArray(a) && (a = a.join(" ")), isArray(b) && (b = b.join(" ")), 
        a + " " + b) : a : b : "";
    }
    function packageStyles(options) {
        var styles = {};
        return options && (options.to || options.from) && (styles.to = options.to, styles.from = options.from), 
        styles;
    }
    function pendClasses(classes, fix, isPrefix) {
        var className = "";
        return classes = isArray(classes) ? classes : classes && isString(classes) && classes.length ? classes.split(/\s+/) : [], 
        forEach(classes, function(klass, i) {
            klass && klass.length > 0 && (className += i > 0 ? " " : "", className += isPrefix ? fix + klass : klass + fix);
        }), className;
    }
    function removeFromArray(arr, val) {
        var index = arr.indexOf(val);
        val >= 0 && arr.splice(index, 1);
    }
    function stripCommentsFromElement(element) {
        if (element instanceof jqLite) switch (element.length) {
          case 0:
            return [];

          case 1:
            if (element[0].nodeType === ELEMENT_NODE) return element;
            break;

          default:
            return jqLite(extractElementNode(element));
        }
        return element.nodeType === ELEMENT_NODE ? jqLite(element) : void 0;
    }
    function extractElementNode(element) {
        if (!element[0]) return element;
        for (var i = 0; i < element.length; i++) {
            var elm = element[i];
            if (elm.nodeType == ELEMENT_NODE) return elm;
        }
    }
    function $$addClass($$jqLite, element, className) {
        forEach(element, function(elm) {
            $$jqLite.addClass(elm, className);
        });
    }
    function $$removeClass($$jqLite, element, className) {
        forEach(element, function(elm) {
            $$jqLite.removeClass(elm, className);
        });
    }
    function applyAnimationClassesFactory($$jqLite) {
        return function(element, options) {
            options.addClass && ($$addClass($$jqLite, element, options.addClass), options.addClass = null), 
            options.removeClass && ($$removeClass($$jqLite, element, options.removeClass), options.removeClass = null);
        };
    }
    function prepareAnimationOptions(options) {
        if (options = options || {}, !options.$$prepared) {
            var domOperation = options.domOperation || noop;
            options.domOperation = function() {
                options.$$domOperationFired = !0, domOperation(), domOperation = noop;
            }, options.$$prepared = !0;
        }
        return options;
    }
    function applyAnimationStyles(element, options) {
        applyAnimationFromStyles(element, options), applyAnimationToStyles(element, options);
    }
    function applyAnimationFromStyles(element, options) {
        options.from && (element.css(options.from), options.from = null);
    }
    function applyAnimationToStyles(element, options) {
        options.to && (element.css(options.to), options.to = null);
    }
    function mergeAnimationOptions(element, target, newOptions) {
        var toAdd = (target.addClass || "") + " " + (newOptions.addClass || ""), toRemove = (target.removeClass || "") + " " + (newOptions.removeClass || ""), classes = resolveElementClasses(element.attr("class"), toAdd, toRemove);
        return extend(target, newOptions), classes.addClass ? target.addClass = classes.addClass : target.addClass = null, 
        classes.removeClass ? target.removeClass = classes.removeClass : target.removeClass = null, 
        target;
    }
    function resolveElementClasses(existing, toAdd, toRemove) {
        function splitClassesToLookup(classes) {
            isString(classes) && (classes = classes.split(" "));
            var obj = {};
            return forEach(classes, function(klass) {
                klass.length && (obj[klass] = !0);
            }), obj;
        }
        var ADD_CLASS = 1, REMOVE_CLASS = -1, flags = {};
        existing = splitClassesToLookup(existing), toAdd = splitClassesToLookup(toAdd), 
        forEach(toAdd, function(value, key) {
            flags[key] = ADD_CLASS;
        }), toRemove = splitClassesToLookup(toRemove), forEach(toRemove, function(value, key) {
            flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
        });
        var classes = {
            addClass: "",
            removeClass: ""
        };
        return forEach(flags, function(val, klass) {
            var prop, allow;
            val === ADD_CLASS ? (prop = "addClass", allow = !existing[klass]) : val === REMOVE_CLASS && (prop = "removeClass", 
            allow = existing[klass]), allow && (classes[prop].length && (classes[prop] += " "), 
            classes[prop] += klass);
        }), classes;
    }
    function getDomNode(element) {
        return element instanceof angular.element ? element[0] : element;
    }
    function computeCssStyles($window, element, properties) {
        var styles = Object.create(null), detectedStyles = $window.getComputedStyle(element) || {};
        return forEach(properties, function(formalStyleName, actualStyleName) {
            var val = detectedStyles[formalStyleName];
            if (val) {
                var c = val.charAt(0);
                ("-" === c || "+" === c || c >= 0) && (val = parseMaxTime(val)), 0 === val && (val = null), 
                styles[actualStyleName] = val;
            }
        }), styles;
    }
    function parseMaxTime(str) {
        var maxValue = 0, values = str.split(/\s*,\s*/);
        return forEach(values, function(value) {
            "s" == value.charAt(value.length - 1) && (value = value.substring(0, value.length - 1)), 
            value = parseFloat(value) || 0, maxValue = maxValue ? Math.max(value, maxValue) : value;
        }), maxValue;
    }
    function truthyTimingValue(val) {
        return 0 === val || null != val;
    }
    function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
        var style = TRANSITION_PROP, value = duration + "s";
        return applyOnlyDuration ? style += DURATION_KEY : value += " linear all", [ style, value ];
    }
    function getCssKeyframeDurationStyle(duration) {
        return [ ANIMATION_DURATION_PROP, duration + "s" ];
    }
    function getCssDelayStyle(delay, isKeyframeAnimation) {
        var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
        return [ prop, delay + "s" ];
    }
    function blockTransitions(node, duration) {
        var value = duration ? "-" + duration + "s" : "";
        return applyInlineStyle(node, [ TRANSITION_DELAY_PROP, value ]), [ TRANSITION_DELAY_PROP, value ];
    }
    function blockKeyframeAnimations(node, applyBlock) {
        var value = applyBlock ? "paused" : "", key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
        return applyInlineStyle(node, [ key, value ]), [ key, value ];
    }
    function applyInlineStyle(node, styleTuple) {
        var prop = styleTuple[0], value = styleTuple[1];
        node.style[prop] = value;
    }
    function createLocalCacheLookup() {
        var cache = Object.create(null);
        return {
            flush: function() {
                cache = Object.create(null);
            },
            count: function(key) {
                var entry = cache[key];
                return entry ? entry.total : 0;
            },
            get: function(key) {
                var entry = cache[key];
                return entry && entry.value;
            },
            put: function(key, value) {
                cache[key] ? cache[key].total++ : cache[key] = {
                    total: 1,
                    value: value
                };
            }
        };
    }
    var TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT, noop = angular.noop, extend = angular.extend, jqLite = angular.element, forEach = angular.forEach, isArray = angular.isArray, isString = angular.isString, isObject = angular.isObject, isUndefined = angular.isUndefined, isDefined = angular.isDefined, isFunction = angular.isFunction, isElement = angular.isElement, ELEMENT_NODE = 1, NG_ANIMATE_CLASSNAME = "ng-animate", NG_ANIMATE_CHILDREN_DATA = "$$ngAnimateChildren", $$rAFSchedulerFactory = [ "$$rAF", function($$rAF) {
        function scheduler(tasks) {
            tickQueue.push([].concat(tasks)), nextTick();
        }
        function nextTick() {
            if (tickQueue.length) {
                for (var updatedQueue = [], i = 0; i < tickQueue.length; i++) {
                    var innerQueue = tickQueue[i];
                    runNextTask(innerQueue), innerQueue.length && updatedQueue.push(innerQueue);
                }
                tickQueue = updatedQueue, cancelFn || $$rAF(function() {
                    cancelFn || nextTick();
                });
            }
        }
        function runNextTask(tasks) {
            var nextTask = tasks.shift();
            nextTask();
        }
        var cancelFn, tickQueue = [];
        return scheduler.waitUntilQuiet = function(fn) {
            cancelFn && cancelFn(), cancelFn = $$rAF(function() {
                cancelFn = null, fn(), nextTick();
            });
        }, scheduler;
    } ], $$AnimateChildrenDirective = [ function() {
        return function(scope, element, attrs) {
            var val = attrs.ngAnimateChildren;
            angular.isString(val) && 0 === val.length ? element.data(NG_ANIMATE_CHILDREN_DATA, !0) : attrs.$observe("ngAnimateChildren", function(value) {
                value = "on" === value || "true" === value, element.data(NG_ANIMATE_CHILDREN_DATA, value);
            });
        };
    } ], CSS_PREFIX = "";
    window.ontransitionend === undefined && window.onwebkittransitionend !== undefined ? (CSS_PREFIX = "-webkit-", 
    TRANSITION_PROP = "WebkitTransition", TRANSITIONEND_EVENT = "webkitTransitionEnd transitionend") : (TRANSITION_PROP = "transition", 
    TRANSITIONEND_EVENT = "transitionend"), window.onanimationend === undefined && window.onwebkitanimationend !== undefined ? (CSS_PREFIX = "-webkit-", 
    ANIMATION_PROP = "WebkitAnimation", ANIMATIONEND_EVENT = "webkitAnimationEnd animationend") : (ANIMATION_PROP = "animation", 
    ANIMATIONEND_EVENT = "animationend");
    var DURATION_KEY = "Duration", PROPERTY_KEY = "Property", DELAY_KEY = "Delay", TIMING_KEY = "TimingFunction", ANIMATION_ITERATION_COUNT_KEY = "IterationCount", ANIMATION_PLAYSTATE_KEY = "PlayState", ELAPSED_TIME_MAX_DECIMAL_PLACES = 3, CLOSING_TIME_BUFFER = 1.5, ONE_SECOND = 1e3, SAFE_FAST_FORWARD_DURATION_VALUE = 9999, ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY, ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY, TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY, TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY, DETECT_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        transitionProperty: TRANSITION_PROP + PROPERTY_KEY,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP,
        animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
    }, DETECT_STAGGER_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP
    }, $AnimateCssProvider = [ "$animateProvider", function($animateProvider) {
        var gcsLookup = createLocalCacheLookup(), gcsStaggerLookup = createLocalCacheLookup();
        this.$get = [ "$window", "$$jqLite", "$$AnimateRunner", "$timeout", "$document", "$sniffer", "$$rAFScheduler", function($window, $$jqLite, $$AnimateRunner, $timeout, $document, $sniffer, $$rAFScheduler) {
            function gcsHashFn(node, extraClasses) {
                var KEY = "$$ngAnimateParentKey", parentNode = node.parentNode, parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
                return parentID + "-" + node.getAttribute("class") + "-" + extraClasses;
            }
            function computeCachedCssStyles(node, className, cacheKey, properties) {
                var timings = gcsLookup.get(cacheKey);
                return timings || (timings = computeCssStyles($window, node, properties), "infinite" === timings.animationIterationCount && (timings.animationIterationCount = 1)), 
                gcsLookup.put(cacheKey, timings), timings;
            }
            function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
                var stagger;
                if (gcsLookup.count(cacheKey) > 0 && (stagger = gcsStaggerLookup.get(cacheKey), 
                !stagger)) {
                    var staggerClassName = pendClasses(className, "-stagger");
                    $$jqLite.addClass(node, staggerClassName), stagger = computeCssStyles($window, node, properties), 
                    stagger.animationDuration = Math.max(stagger.animationDuration, 0), stagger.transitionDuration = Math.max(stagger.transitionDuration, 0), 
                    $$jqLite.removeClass(node, staggerClassName), gcsStaggerLookup.put(cacheKey, stagger);
                }
                return stagger || {};
            }
            function waitUntilQuiet(callback) {
                rafWaitQueue.push(callback), $$rAFScheduler.waitUntilQuiet(function() {
                    gcsLookup.flush(), gcsStaggerLookup.flush();
                    for (var width = bod.offsetWidth + 1, i = 0; i < rafWaitQueue.length; i++) rafWaitQueue[i](width);
                    rafWaitQueue.length = 0;
                });
            }
            function computeTimings(node, className, cacheKey) {
                var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES), aD = timings.animationDelay, tD = timings.transitionDelay;
                return timings.maxDelay = aD && tD ? Math.max(aD, tD) : aD || tD, timings.maxDuration = Math.max(timings.animationDuration * timings.animationIterationCount, timings.transitionDuration), 
                timings;
            }
            function init(element, options) {
                function endFn() {
                    close();
                }
                function cancelFn() {
                    close(!0);
                }
                function close(rejected) {
                    animationClosed || animationCompleted && animationPaused || (animationClosed = !0, 
                    animationPaused = !1, $$jqLite.removeClass(element, setupClasses), $$jqLite.removeClass(element, activeClasses), 
                    blockKeyframeAnimations(node, !1), blockTransitions(node, !1), forEach(temporaryStyles, function(entry) {
                        node.style[entry[0]] = "";
                    }), applyAnimationClasses(element, options), applyAnimationStyles(element, options), 
                    options.onDone && options.onDone(), runner && runner.complete(!rejected));
                }
                function applyBlocking(duration) {
                    flags.blockTransition && blockTransitions(node, duration), flags.blockKeyframeAnimation && blockKeyframeAnimations(node, !!duration);
                }
                function closeAndReturnNoopAnimator() {
                    return runner = new $$AnimateRunner({
                        end: endFn,
                        cancel: cancelFn
                    }), close(), {
                        $$willAnimate: !1,
                        start: function() {
                            return runner;
                        },
                        end: endFn
                    };
                }
                function start() {
                    function triggerAnimationStart() {
                        if (!animationClosed) {
                            if (applyBlocking(!1), forEach(temporaryStyles, function(entry) {
                                var key = entry[0], value = entry[1];
                                node.style[key] = value;
                            }), applyAnimationClasses(element, options), $$jqLite.addClass(element, activeClasses), 
                            flags.recalculateTimingStyles) {
                                if (fullClassName = node.className + " " + setupClasses, cacheKey = gcsHashFn(node, fullClassName), 
                                timings = computeTimings(node, fullClassName, cacheKey), relativeDelay = timings.maxDelay, 
                                maxDelay = Math.max(relativeDelay, 0), maxDuration = timings.maxDuration, 0 === maxDuration) return void close();
                                flags.hasTransitions = timings.transitionDuration > 0, flags.hasAnimations = timings.animationDuration > 0;
                            }
                            if (flags.applyTransitionDelay || flags.applyAnimationDelay) {
                                relativeDelay = "boolean" != typeof options.delay && truthyTimingValue(options.delay) ? parseFloat(options.delay) : relativeDelay, 
                                maxDelay = Math.max(relativeDelay, 0);
                                var delayStyle;
                                flags.applyTransitionDelay && (timings.transitionDelay = relativeDelay, delayStyle = getCssDelayStyle(relativeDelay), 
                                temporaryStyles.push(delayStyle), node.style[delayStyle[0]] = delayStyle[1]), flags.applyAnimationDelay && (timings.animationDelay = relativeDelay, 
                                delayStyle = getCssDelayStyle(relativeDelay, !0), temporaryStyles.push(delayStyle), 
                                node.style[delayStyle[0]] = delayStyle[1]);
                            }
                            if (maxDelayTime = maxDelay * ONE_SECOND, maxDurationTime = maxDuration * ONE_SECOND, 
                            options.easing) {
                                var easeProp, easeVal = options.easing;
                                flags.hasTransitions && (easeProp = TRANSITION_PROP + TIMING_KEY, temporaryStyles.push([ easeProp, easeVal ]), 
                                node.style[easeProp] = easeVal), flags.hasAnimations && (easeProp = ANIMATION_PROP + TIMING_KEY, 
                                temporaryStyles.push([ easeProp, easeVal ]), node.style[easeProp] = easeVal);
                            }
                            timings.transitionDuration && events.push(TRANSITIONEND_EVENT), timings.animationDuration && events.push(ANIMATIONEND_EVENT), 
                            startTime = Date.now(), element.on(events.join(" "), onAnimationProgress), $timeout(onAnimationExpired, maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime), 
                            applyAnimationToStyles(element, options);
                        }
                    }
                    function onAnimationExpired() {
                        close();
                    }
                    function onAnimationProgress(event) {
                        event.stopPropagation();
                        var ev = event.originalEvent || event, timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now(), elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
                        Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration && (animationCompleted = !0, 
                        close());
                    }
                    if (!animationClosed) {
                        if (!node.parentNode) return void close();
                        var startTime, events = [], playPause = function(playAnimation) {
                            if (animationCompleted) animationPaused && playAnimation && (animationPaused = !1, 
                            close()); else if (animationPaused = !playAnimation, timings.animationDuration) {
                                var value = blockKeyframeAnimations(node, animationPaused);
                                animationPaused ? temporaryStyles.push(value) : removeFromArray(temporaryStyles, value);
                            }
                        }, maxStagger = itemIndex > 0 && (timings.transitionDuration && 0 === stagger.transitionDuration || timings.animationDuration && 0 === stagger.animationDuration) && Math.max(stagger.animationDelay, stagger.transitionDelay);
                        maxStagger ? $timeout(triggerAnimationStart, Math.floor(maxStagger * itemIndex * ONE_SECOND), !1) : triggerAnimationStart(), 
                        runnerHost.resume = function() {
                            playPause(!0);
                        }, runnerHost.pause = function() {
                            playPause(!1);
                        };
                    }
                }
                var node = getDomNode(element);
                if (!node || !node.parentNode) return closeAndReturnNoopAnimator();
                options = prepareAnimationOptions(options);
                var animationClosed, animationPaused, animationCompleted, runner, runnerHost, maxDelay, maxDelayTime, maxDuration, maxDurationTime, temporaryStyles = [], classes = element.attr("class"), styles = packageStyles(options);
                if (0 === options.duration || !$sniffer.animations && !$sniffer.transitions) return closeAndReturnNoopAnimator();
                var method = options.event && isArray(options.event) ? options.event.join(" ") : options.event, isStructural = method && options.structural, structuralClassName = "", addRemoveClassName = "";
                isStructural ? structuralClassName = pendClasses(method, "ng-", !0) : method && (structuralClassName = method), 
                options.addClass && (addRemoveClassName += pendClasses(options.addClass, "-add")), 
                options.removeClass && (addRemoveClassName.length && (addRemoveClassName += " "), 
                addRemoveClassName += pendClasses(options.removeClass, "-remove")), options.applyClassesEarly && addRemoveClassName.length && (applyAnimationClasses(element, options), 
                addRemoveClassName = "");
                var setupClasses = [ structuralClassName, addRemoveClassName ].join(" ").trim(), fullClassName = classes + " " + setupClasses, activeClasses = pendClasses(setupClasses, "-active"), hasToStyles = styles.to && Object.keys(styles.to).length > 0, containsKeyframeAnimation = (options.keyframeStyle || "").length > 0;
                if (!containsKeyframeAnimation && !hasToStyles && !setupClasses) return closeAndReturnNoopAnimator();
                var cacheKey, stagger;
                if (options.stagger > 0) {
                    var staggerVal = parseFloat(options.stagger);
                    stagger = {
                        transitionDelay: staggerVal,
                        animationDelay: staggerVal,
                        transitionDuration: 0,
                        animationDuration: 0
                    };
                } else cacheKey = gcsHashFn(node, fullClassName), stagger = computeCachedCssStaggerStyles(node, setupClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
                $$jqLite.addClass(element, setupClasses);
                var applyOnlyDuration;
                if (options.transitionStyle) {
                    var transitionStyle = [ TRANSITION_PROP, options.transitionStyle ];
                    applyInlineStyle(node, transitionStyle), temporaryStyles.push(transitionStyle);
                }
                if (options.duration >= 0) {
                    applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
                    var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);
                    applyInlineStyle(node, durationStyle), temporaryStyles.push(durationStyle);
                }
                if (options.keyframeStyle) {
                    var keyframeStyle = [ ANIMATION_PROP, options.keyframeStyle ];
                    applyInlineStyle(node, keyframeStyle), temporaryStyles.push(keyframeStyle);
                }
                var itemIndex = stagger ? options.staggerIndex >= 0 ? options.staggerIndex : gcsLookup.count(cacheKey) : 0, isFirst = 0 === itemIndex;
                isFirst && blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
                var timings = computeTimings(node, fullClassName, cacheKey), relativeDelay = timings.maxDelay;
                maxDelay = Math.max(relativeDelay, 0), maxDuration = timings.maxDuration;
                var flags = {};
                return flags.hasTransitions = timings.transitionDuration > 0, flags.hasAnimations = timings.animationDuration > 0, 
                flags.hasTransitionAll = flags.hasTransitions && "all" == timings.transitionProperty, 
                flags.applyTransitionDuration = hasToStyles && (flags.hasTransitions && !flags.hasTransitionAll || flags.hasAnimations && !flags.hasTransitions), 
                flags.applyAnimationDuration = options.duration && flags.hasAnimations, flags.applyTransitionDelay = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions), 
                flags.applyAnimationDelay = truthyTimingValue(options.delay) && flags.hasAnimations, 
                flags.recalculateTimingStyles = addRemoveClassName.length > 0, (flags.applyTransitionDuration || flags.applyAnimationDuration) && (maxDuration = options.duration ? parseFloat(options.duration) : maxDuration, 
                flags.applyTransitionDuration && (flags.hasTransitions = !0, timings.transitionDuration = maxDuration, 
                applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0, temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration))), 
                flags.applyAnimationDuration && (flags.hasAnimations = !0, timings.animationDuration = maxDuration, 
                temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration)))), 0 !== maxDuration || flags.recalculateTimingStyles ? (null == options.duration && timings.transitionDuration > 0 && (flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst), 
                maxDelayTime = maxDelay * ONE_SECOND, maxDurationTime = maxDuration * ONE_SECOND, 
                options.skipBlocking || (flags.blockTransition = timings.transitionDuration > 0, 
                flags.blockKeyframeAnimation = timings.animationDuration > 0 && stagger.animationDelay > 0 && 0 === stagger.animationDuration), 
                applyAnimationFromStyles(element, options), flags.blockTransition || blockTransitions(node, !1), 
                applyBlocking(maxDuration), {
                    $$willAnimate: !0,
                    end: endFn,
                    start: function() {
                        return animationClosed ? void 0 : (runnerHost = {
                            end: endFn,
                            cancel: cancelFn,
                            resume: null,
                            pause: null
                        }, runner = new $$AnimateRunner(runnerHost), waitUntilQuiet(start), runner);
                    }
                }) : closeAndReturnNoopAnimator();
            }
            var applyAnimationClasses = applyAnimationClassesFactory($$jqLite), parentCounter = 0, bod = getDomNode($document).body, rafWaitQueue = [];
            return init;
        } ];
    } ], $$AnimateCssDriverProvider = [ "$$animationProvider", function($$animationProvider) {
        $$animationProvider.drivers.push("$$animateCssDriver");
        var NG_ANIMATE_SHIM_CLASS_NAME = "ng-animate-shim", NG_ANIMATE_ANCHOR_CLASS_NAME = "ng-anchor", NG_OUT_ANCHOR_CLASS_NAME = "ng-anchor-out", NG_IN_ANCHOR_CLASS_NAME = "ng-anchor-in";
        this.$get = [ "$animateCss", "$rootScope", "$$AnimateRunner", "$rootElement", "$document", "$sniffer", function($animateCss, $rootScope, $$AnimateRunner, $rootElement, $document, $sniffer) {
            function filterCssClasses(classes) {
                return classes.replace(/\bng-\S+\b/g, "");
            }
            function getUniqueValues(a, b) {
                return isString(a) && (a = a.split(" ")), isString(b) && (b = b.split(" ")), a.filter(function(val) {
                    return -1 === b.indexOf(val);
                }).join(" ");
            }
            function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
                function calculateAnchorStyles(anchor) {
                    var styles = {}, coords = getDomNode(anchor).getBoundingClientRect();
                    return forEach([ "width", "height", "top", "left" ], function(key) {
                        var value = coords[key];
                        switch (key) {
                          case "top":
                            value += bodyNode.scrollTop;
                            break;

                          case "left":
                            value += bodyNode.scrollLeft;
                        }
                        styles[key] = Math.floor(value) + "px";
                    }), styles;
                }
                function prepareOutAnimation() {
                    var animator = $animateCss(clone, {
                        addClass: NG_OUT_ANCHOR_CLASS_NAME,
                        delay: !0,
                        from: calculateAnchorStyles(outAnchor)
                    });
                    return animator.$$willAnimate ? animator : null;
                }
                function getClassVal(element) {
                    return element.attr("class") || "";
                }
                function prepareInAnimation() {
                    var endingClasses = filterCssClasses(getClassVal(inAnchor)), toAdd = getUniqueValues(endingClasses, startingClasses), toRemove = getUniqueValues(startingClasses, endingClasses), animator = $animateCss(clone, {
                        to: calculateAnchorStyles(inAnchor),
                        addClass: NG_IN_ANCHOR_CLASS_NAME + " " + toAdd,
                        removeClass: NG_OUT_ANCHOR_CLASS_NAME + " " + toRemove,
                        delay: !0
                    });
                    return animator.$$willAnimate ? animator : null;
                }
                function end() {
                    clone.remove(), outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME), inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
                }
                var clone = jqLite(getDomNode(outAnchor).cloneNode(!0)), startingClasses = filterCssClasses(getClassVal(clone));
                outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME), inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME), 
                clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME), rootBodyElement.append(clone);
                var animatorIn, animatorOut = prepareOutAnimation();
                if (!animatorOut && (animatorIn = prepareInAnimation(), !animatorIn)) return end();
                var startingAnimator = animatorOut || animatorIn;
                return {
                    start: function() {
                        function endFn() {
                            currentAnimation && currentAnimation.end();
                        }
                        var runner, currentAnimation = startingAnimator.start();
                        return currentAnimation.done(function() {
                            return currentAnimation = null, !animatorIn && (animatorIn = prepareInAnimation()) ? (currentAnimation = animatorIn.start(), 
                            currentAnimation.done(function() {
                                currentAnimation = null, end(), runner.complete();
                            }), currentAnimation) : (end(), void runner.complete());
                        }), runner = new $$AnimateRunner({
                            end: endFn,
                            cancel: endFn
                        });
                    }
                };
            }
            function prepareFromToAnchorAnimation(from, to, classes, anchors) {
                var fromAnimation = prepareRegularAnimation(from), toAnimation = prepareRegularAnimation(to), anchorAnimations = [];
                return forEach(anchors, function(anchor) {
                    var outElement = anchor.out, inElement = anchor["in"], animator = prepareAnchoredAnimation(classes, outElement, inElement);
                    animator && anchorAnimations.push(animator);
                }), fromAnimation || toAnimation || 0 !== anchorAnimations.length ? {
                    start: function() {
                        function endFn() {
                            forEach(animationRunners, function(runner) {
                                runner.end();
                            });
                        }
                        var animationRunners = [];
                        fromAnimation && animationRunners.push(fromAnimation.start()), toAnimation && animationRunners.push(toAnimation.start()), 
                        forEach(anchorAnimations, function(animation) {
                            animationRunners.push(animation.start());
                        });
                        var runner = new $$AnimateRunner({
                            end: endFn,
                            cancel: endFn
                        });
                        return $$AnimateRunner.all(animationRunners, function(status) {
                            runner.complete(status);
                        }), runner;
                    }
                } : void 0;
            }
            function prepareRegularAnimation(animationDetails) {
                var element = animationDetails.element, options = animationDetails.options || {};
                animationDetails.structural ? (options.structural = options.applyClassesEarly = !0, 
                options.event = animationDetails.event, "leave" === options.event && (options.onDone = options.domOperation)) : options.event = null;
                var animator = $animateCss(element, options);
                return animator.$$willAnimate ? animator : null;
            }
            if (!$sniffer.animations && !$sniffer.transitions) return noop;
            var bodyNode = getDomNode($document).body, rootNode = getDomNode($rootElement), rootBodyElement = jqLite(bodyNode.parentNode === rootNode ? bodyNode : rootNode);
            return function(animationDetails) {
                return animationDetails.from && animationDetails.to ? prepareFromToAnchorAnimation(animationDetails.from, animationDetails.to, animationDetails.classes, animationDetails.anchors) : prepareRegularAnimation(animationDetails);
            };
        } ];
    } ], $$AnimateJsProvider = [ "$animateProvider", function($animateProvider) {
        this.$get = [ "$injector", "$$AnimateRunner", "$$rAFMutex", "$$jqLite", function($injector, $$AnimateRunner, $$rAFMutex, $$jqLite) {
            function lookupAnimations(classes) {
                classes = isArray(classes) ? classes : classes.split(" ");
                for (var matches = [], flagMap = {}, i = 0; i < classes.length; i++) {
                    var klass = classes[i], animationFactory = $animateProvider.$$registeredAnimations[klass];
                    animationFactory && !flagMap[klass] && (matches.push($injector.get(animationFactory)), 
                    flagMap[klass] = !0);
                }
                return matches;
            }
            var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
            return function(element, event, classes, options) {
                function applyOptions() {
                    options.domOperation(), applyAnimationClasses(element, options);
                }
                function executeAnimationFn(fn, element, event, options, onDone) {
                    var args;
                    switch (event) {
                      case "animate":
                        args = [ element, options.from, options.to, onDone ];
                        break;

                      case "setClass":
                        args = [ element, classesToAdd, classesToRemove, onDone ];
                        break;

                      case "addClass":
                        args = [ element, classesToAdd, onDone ];
                        break;

                      case "removeClass":
                        args = [ element, classesToRemove, onDone ];
                        break;

                      default:
                        args = [ element, onDone ];
                    }
                    args.push(options);
                    var value = fn.apply(fn, args);
                    if (value) if (isFunction(value.start) && (value = value.start()), value instanceof $$AnimateRunner) value.done(onDone); else if (isFunction(value)) return value;
                    return noop;
                }
                function groupEventedAnimations(element, event, options, animations, fnName) {
                    var operations = [];
                    return forEach(animations, function(ani) {
                        var animation = ani[fnName];
                        animation && operations.push(function() {
                            var runner, endProgressCb, resolved = !1, onAnimationComplete = function(rejected) {
                                resolved || (resolved = !0, (endProgressCb || noop)(rejected), runner.complete(!rejected));
                            };
                            return runner = new $$AnimateRunner({
                                end: function() {
                                    onAnimationComplete();
                                },
                                cancel: function() {
                                    onAnimationComplete(!0);
                                }
                            }), endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {
                                var cancelled = result === !1;
                                onAnimationComplete(cancelled);
                            }), runner;
                        });
                    }), operations;
                }
                function packageAnimations(element, event, options, animations, fnName) {
                    var operations = groupEventedAnimations(element, event, options, animations, fnName);
                    if (0 === operations.length) {
                        var a, b;
                        "beforeSetClass" === fnName ? (a = groupEventedAnimations(element, "removeClass", options, animations, "beforeRemoveClass"), 
                        b = groupEventedAnimations(element, "addClass", options, animations, "beforeAddClass")) : "setClass" === fnName && (a = groupEventedAnimations(element, "removeClass", options, animations, "removeClass"), 
                        b = groupEventedAnimations(element, "addClass", options, animations, "addClass")), 
                        a && (operations = operations.concat(a)), b && (operations = operations.concat(b));
                    }
                    if (0 !== operations.length) return function(callback) {
                        var runners = [];
                        return operations.length && forEach(operations, function(animateFn) {
                            runners.push(animateFn());
                        }), runners.length ? $$AnimateRunner.all(runners, callback) : callback(), function(reject) {
                            forEach(runners, function(runner) {
                                reject ? runner.cancel() : runner.end();
                            });
                        };
                    };
                }
                3 === arguments.length && isObject(classes) && (options = classes, classes = null), 
                options = prepareAnimationOptions(options), classes || (classes = element.attr("class") || "", 
                options.addClass && (classes += " " + options.addClass), options.removeClass && (classes += " " + options.removeClass));
                var before, after, classesToAdd = options.addClass, classesToRemove = options.removeClass, animations = lookupAnimations(classes);
                if (animations.length) {
                    var afterFn, beforeFn;
                    "leave" == event ? (beforeFn = "leave", afterFn = "afterLeave") : (beforeFn = "before" + event.charAt(0).toUpperCase() + event.substr(1), 
                    afterFn = event), "enter" !== event && "move" !== event && (before = packageAnimations(element, event, options, animations, beforeFn)), 
                    after = packageAnimations(element, event, options, animations, afterFn);
                }
                return before || after ? {
                    start: function() {
                        function onComplete(success) {
                            animationClosed = !0, applyOptions(), applyAnimationStyles(element, options), runner.complete(success);
                        }
                        function endAnimations(cancelled) {
                            animationClosed || ((closeActiveAnimations || noop)(cancelled), onComplete(cancelled));
                        }
                        var closeActiveAnimations, chain = [];
                        before && chain.push(function(fn) {
                            closeActiveAnimations = before(fn);
                        }), chain.length ? chain.push(function(fn) {
                            applyOptions(), fn(!0);
                        }) : applyOptions(), after && chain.push(function(fn) {
                            closeActiveAnimations = after(fn);
                        });
                        var animationClosed = !1, runner = new $$AnimateRunner({
                            end: function() {
                                endAnimations();
                            },
                            cancel: function() {
                                endAnimations(!0);
                            }
                        });
                        return $$AnimateRunner.chain(chain, onComplete), runner;
                    }
                } : void 0;
            };
        } ];
    } ], $$AnimateJsDriverProvider = [ "$$animationProvider", function($$animationProvider) {
        $$animationProvider.drivers.push("$$animateJsDriver"), this.$get = [ "$$animateJs", "$$AnimateRunner", function($$animateJs, $$AnimateRunner) {
            function prepareAnimation(animationDetails) {
                var element = animationDetails.element, event = animationDetails.event, options = animationDetails.options, classes = animationDetails.classes;
                return $$animateJs(element, event, classes, options);
            }
            return function(animationDetails) {
                if (animationDetails.from && animationDetails.to) {
                    var fromAnimation = prepareAnimation(animationDetails.from), toAnimation = prepareAnimation(animationDetails.to);
                    if (!fromAnimation && !toAnimation) return;
                    return {
                        start: function() {
                            function endFnFactory() {
                                return function() {
                                    forEach(animationRunners, function(runner) {
                                        runner.end();
                                    });
                                };
                            }
                            function done(status) {
                                runner.complete(status);
                            }
                            var animationRunners = [];
                            fromAnimation && animationRunners.push(fromAnimation.start()), toAnimation && animationRunners.push(toAnimation.start()), 
                            $$AnimateRunner.all(animationRunners, done);
                            var runner = new $$AnimateRunner({
                                end: endFnFactory(),
                                cancel: endFnFactory()
                            });
                            return runner;
                        }
                    };
                }
                return prepareAnimation(animationDetails);
            };
        } ];
    } ], NG_ANIMATE_ATTR_NAME = "data-ng-animate", NG_ANIMATE_PIN_DATA = "$ngAnimatePin", $$AnimateQueueProvider = [ "$animateProvider", function($animateProvider) {
        function isAllowed(ruleType, element, currentAnimation, previousAnimation) {
            return rules[ruleType].some(function(fn) {
                return fn(element, currentAnimation, previousAnimation);
            });
        }
        function hasAnimationClasses(options, and) {
            options = options || {};
            var a = (options.addClass || "").length > 0, b = (options.removeClass || "").length > 0;
            return and ? a && b : a || b;
        }
        var PRE_DIGEST_STATE = 1, RUNNING_STATE = 2, rules = this.rules = {
            skip: [],
            cancel: [],
            join: []
        };
        rules.join.push(function(element, newAnimation, currentAnimation) {
            return !newAnimation.structural && hasAnimationClasses(newAnimation.options);
        }), rules.skip.push(function(element, newAnimation, currentAnimation) {
            return !newAnimation.structural && !hasAnimationClasses(newAnimation.options);
        }), rules.skip.push(function(element, newAnimation, currentAnimation) {
            return "leave" == currentAnimation.event && newAnimation.structural;
        }), rules.skip.push(function(element, newAnimation, currentAnimation) {
            return currentAnimation.structural && !newAnimation.structural;
        }), rules.cancel.push(function(element, newAnimation, currentAnimation) {
            return currentAnimation.structural && newAnimation.structural;
        }), rules.cancel.push(function(element, newAnimation, currentAnimation) {
            return currentAnimation.state === RUNNING_STATE && newAnimation.structural;
        }), rules.cancel.push(function(element, newAnimation, currentAnimation) {
            var nO = newAnimation.options, cO = currentAnimation.options;
            return nO.addClass && nO.addClass === cO.removeClass || nO.removeClass && nO.removeClass === cO.addClass;
        }), this.$get = [ "$$rAF", "$rootScope", "$rootElement", "$document", "$$HashMap", "$$animation", "$$AnimateRunner", "$templateRequest", "$$jqLite", function($$rAF, $rootScope, $rootElement, $document, $$HashMap, $$animation, $$AnimateRunner, $templateRequest, $$jqLite) {
            function normalizeAnimationOptions(element, options) {
                return mergeAnimationOptions(element, options, {});
            }
            function findCallbacks(element, event) {
                var targetNode = getDomNode(element), matches = [], entries = callbackRegistry[event];
                return entries && forEach(entries, function(entry) {
                    entry.node.contains(targetNode) && matches.push(entry.callback);
                }), matches;
            }
            function triggerCallback(event, element, phase, data) {
                $$rAF(function() {
                    forEach(findCallbacks(element, event), function(callback) {
                        callback(element, phase, data);
                    });
                });
            }
            function queueAnimation(element, event, options) {
                function notifyProgress(runner, event, phase, data) {
                    triggerCallback(event, element, phase, data), runner.progress(event, phase, data);
                }
                function close(reject) {
                    applyAnimationClasses(element, options), applyAnimationStyles(element, options), 
                    options.domOperation(), runner.complete(!reject);
                }
                var node, parent;
                element = stripCommentsFromElement(element), element && (node = getDomNode(element), 
                parent = element.parent()), options = prepareAnimationOptions(options);
                var runner = new $$AnimateRunner();
                if (!node) return close(), runner;
                isArray(options.addClass) && (options.addClass = options.addClass.join(" ")), isArray(options.removeClass) && (options.removeClass = options.removeClass.join(" ")), 
                options.from && !isObject(options.from) && (options.from = null), options.to && !isObject(options.to) && (options.to = null);
                var className = [ node.className, options.addClass, options.removeClass ].join(" ");
                if (!isAnimatableClassName(className)) return close(), runner;
                var isStructural = [ "enter", "move", "leave" ].indexOf(event) >= 0, skipAnimations = !animationsEnabled || disabledElementsLookup.get(node), existingAnimation = !skipAnimations && activeAnimationsLookup.get(node) || {}, hasExistingAnimation = !!existingAnimation.state;
                if (skipAnimations || hasExistingAnimation && existingAnimation.state == PRE_DIGEST_STATE || (skipAnimations = !areAnimationsAllowed(element, parent, event)), 
                skipAnimations) return close(), runner;
                isStructural && closeChildAnimations(element);
                var newAnimation = {
                    structural: isStructural,
                    element: element,
                    event: event,
                    close: close,
                    options: options,
                    runner: runner
                };
                if (hasExistingAnimation) {
                    var skipAnimationFlag = isAllowed("skip", element, newAnimation, existingAnimation);
                    if (skipAnimationFlag) return existingAnimation.state === RUNNING_STATE ? (close(), 
                    runner) : (mergeAnimationOptions(element, existingAnimation.options, options), existingAnimation.runner);
                    var cancelAnimationFlag = isAllowed("cancel", element, newAnimation, existingAnimation);
                    if (cancelAnimationFlag) existingAnimation.state === RUNNING_STATE ? existingAnimation.runner.end() : existingAnimation.structural ? existingAnimation.close() : mergeAnimationOptions(element, newAnimation.options, existingAnimation.options); else {
                        var joinAnimationFlag = isAllowed("join", element, newAnimation, existingAnimation);
                        if (joinAnimationFlag) {
                            if (existingAnimation.state !== RUNNING_STATE) return event = newAnimation.event = existingAnimation.event, 
                            options = mergeAnimationOptions(element, existingAnimation.options, newAnimation.options), 
                            runner;
                            normalizeAnimationOptions(element, options);
                        }
                    }
                } else normalizeAnimationOptions(element, options);
                var isValidAnimation = newAnimation.structural;
                if (isValidAnimation || (isValidAnimation = "animate" === newAnimation.event && Object.keys(newAnimation.options.to || {}).length > 0 || hasAnimationClasses(newAnimation.options)), 
                !isValidAnimation) return close(), clearElementAnimationState(element), runner;
                isStructural && closeParentClassBasedAnimations(parent);
                var counter = (existingAnimation.counter || 0) + 1;
                return newAnimation.counter = counter, markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation), 
                $rootScope.$$postDigest(function() {
                    var animationDetails = activeAnimationsLookup.get(node), animationCancelled = !animationDetails;
                    animationDetails = animationDetails || {};
                    var parentElement = element.parent() || [], isValidAnimation = parentElement.length > 0 && ("animate" === animationDetails.event || animationDetails.structural || hasAnimationClasses(animationDetails.options));
                    if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) return animationCancelled && (applyAnimationClasses(element, options), 
                    applyAnimationStyles(element, options)), (animationCancelled || isStructural && animationDetails.event !== event) && (options.domOperation(), 
                    runner.end()), void (isValidAnimation || clearElementAnimationState(element));
                    event = !animationDetails.structural && hasAnimationClasses(animationDetails.options, !0) ? "setClass" : animationDetails.event, 
                    animationDetails.structural && closeParentClassBasedAnimations(parentElement), markElementAnimationState(element, RUNNING_STATE);
                    var realRunner = $$animation(element, event, animationDetails.options);
                    realRunner.done(function(status) {
                        close(!status);
                        var animationDetails = activeAnimationsLookup.get(node);
                        animationDetails && animationDetails.counter === counter && clearElementAnimationState(getDomNode(element)), 
                        notifyProgress(runner, event, "close", {});
                    }), runner.setHost(realRunner), notifyProgress(runner, event, "start", {});
                }), runner;
            }
            function closeChildAnimations(element) {
                var node = getDomNode(element), children = node.querySelectorAll("[" + NG_ANIMATE_ATTR_NAME + "]");
                forEach(children, function(child) {
                    var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME)), animationDetails = activeAnimationsLookup.get(child);
                    switch (state) {
                      case RUNNING_STATE:
                        animationDetails.runner.end();

                      case PRE_DIGEST_STATE:
                        animationDetails && activeAnimationsLookup.remove(child);
                    }
                });
            }
            function clearElementAnimationState(element) {
                var node = getDomNode(element);
                node.removeAttribute(NG_ANIMATE_ATTR_NAME), activeAnimationsLookup.remove(node);
            }
            function isMatchingElement(nodeOrElmA, nodeOrElmB) {
                return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);
            }
            function closeParentClassBasedAnimations(startingElement) {
                function examineParentAnimation(node, animationDetails) {
                    !animationDetails.structural && hasAnimationClasses(animationDetails.options) && (animationDetails.state === RUNNING_STATE && animationDetails.runner.end(), 
                    clearElementAnimationState(node));
                }
                for (var parentNode = getDomNode(startingElement); ;) {
                    if (!parentNode || parentNode.nodeType !== ELEMENT_NODE) break;
                    var animationDetails = activeAnimationsLookup.get(parentNode);
                    animationDetails && examineParentAnimation(parentNode, animationDetails), parentNode = parentNode.parentNode;
                }
            }
            function areAnimationsAllowed(element, parentElement, event) {
                var animateChildren, bodyElementDetected = !1, rootElementDetected = !1, parentAnimationDetected = !1, parentHost = element.data(NG_ANIMATE_PIN_DATA);
                for (parentHost && (parentElement = parentHost); parentElement && parentElement.length; ) {
                    rootElementDetected || (rootElementDetected = isMatchingElement(parentElement, $rootElement));
                    var parentNode = parentElement[0];
                    if (parentNode.nodeType !== ELEMENT_NODE) break;
                    var details = activeAnimationsLookup.get(parentNode) || {};
                    if (parentAnimationDetected || (parentAnimationDetected = details.structural || disabledElementsLookup.get(parentNode)), 
                    isUndefined(animateChildren) || animateChildren === !0) {
                        var value = parentElement.data(NG_ANIMATE_CHILDREN_DATA);
                        isDefined(value) && (animateChildren = value);
                    }
                    if (parentAnimationDetected && animateChildren === !1) break;
                    rootElementDetected || (rootElementDetected = isMatchingElement(parentElement, $rootElement), 
                    rootElementDetected || (parentHost = parentElement.data(NG_ANIMATE_PIN_DATA), parentHost && (parentElement = parentHost))), 
                    bodyElementDetected || (bodyElementDetected = isMatchingElement(parentElement, bodyElement)), 
                    parentElement = parentElement.parent();
                }
                var allowAnimation = !parentAnimationDetected || animateChildren;
                return allowAnimation && rootElementDetected && bodyElementDetected;
            }
            function markElementAnimationState(element, state, details) {
                details = details || {}, details.state = state;
                var node = getDomNode(element);
                node.setAttribute(NG_ANIMATE_ATTR_NAME, state);
                var oldValue = activeAnimationsLookup.get(node), newValue = oldValue ? extend(oldValue, details) : details;
                activeAnimationsLookup.put(node, newValue);
            }
            var activeAnimationsLookup = new $$HashMap(), disabledElementsLookup = new $$HashMap(), animationsEnabled = null, deregisterWatch = $rootScope.$watch(function() {
                return 0 === $templateRequest.totalPendingRequests;
            }, function(isEmpty) {
                isEmpty && (deregisterWatch(), $rootScope.$$postDigest(function() {
                    $rootScope.$$postDigest(function() {
                        null === animationsEnabled && (animationsEnabled = !0);
                    });
                }));
            }), bodyElement = jqLite($document[0].body), callbackRegistry = {}, classNameFilter = $animateProvider.classNameFilter(), isAnimatableClassName = classNameFilter ? function(className) {
                return classNameFilter.test(className);
            } : function() {
                return !0;
            }, applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
            return {
                on: function(event, container, callback) {
                    var node = extractElementNode(container);
                    callbackRegistry[event] = callbackRegistry[event] || [], callbackRegistry[event].push({
                        node: node,
                        callback: callback
                    });
                },
                off: function(event, container, callback) {
                    function filterFromRegistry(list, matchContainer, matchCallback) {
                        var containerNode = extractElementNode(matchContainer);
                        return list.filter(function(entry) {
                            var isMatch = entry.node === containerNode && (!matchCallback || entry.callback === matchCallback);
                            return !isMatch;
                        });
                    }
                    var entries = callbackRegistry[event];
                    entries && (callbackRegistry[event] = 1 === arguments.length ? null : filterFromRegistry(entries, container, callback));
                },
                pin: function(element, parentElement) {
                    assertArg(isElement(element), "element", "not an element"), assertArg(isElement(parentElement), "parentElement", "not an element"), 
                    element.data(NG_ANIMATE_PIN_DATA, parentElement);
                },
                push: function(element, event, options, domOperation) {
                    return options = options || {}, options.domOperation = domOperation, queueAnimation(element, event, options);
                },
                enabled: function(element, bool) {
                    var argCount = arguments.length;
                    if (0 === argCount) bool = !!animationsEnabled; else {
                        var hasElement = isElement(element);
                        if (hasElement) {
                            var node = getDomNode(element), recordExists = disabledElementsLookup.get(node);
                            1 === argCount ? bool = !recordExists : (bool = !!bool, bool ? recordExists && disabledElementsLookup.remove(node) : disabledElementsLookup.put(node, !0));
                        } else bool = animationsEnabled = !!element;
                    }
                    return bool;
                }
            };
        } ];
    } ], $$rAFMutexFactory = [ "$$rAF", function($$rAF) {
        return function() {
            var passed = !1;
            return $$rAF(function() {
                passed = !0;
            }), function(fn) {
                passed ? fn() : $$rAF(fn);
            };
        };
    } ], $$AnimateRunnerFactory = [ "$q", "$$rAFMutex", function($q, $$rAFMutex) {
        function AnimateRunner(host) {
            this.setHost(host), this._doneCallbacks = [], this._runInAnimationFrame = $$rAFMutex(), 
            this._state = 0;
        }
        var INITIAL_STATE = 0, DONE_PENDING_STATE = 1, DONE_COMPLETE_STATE = 2;
        return AnimateRunner.chain = function(chain, callback) {
            function next() {
                return index === chain.length ? void callback(!0) : void chain[index](function(response) {
                    return response === !1 ? void callback(!1) : (index++, void next());
                });
            }
            var index = 0;
            next();
        }, AnimateRunner.all = function(runners, callback) {
            function onProgress(response) {
                status = status && response, ++count === runners.length && callback(status);
            }
            var count = 0, status = !0;
            forEach(runners, function(runner) {
                runner.done(onProgress);
            });
        }, AnimateRunner.prototype = {
            setHost: function(host) {
                this.host = host || {};
            },
            done: function(fn) {
                this._state === DONE_COMPLETE_STATE ? fn() : this._doneCallbacks.push(fn);
            },
            progress: noop,
            getPromise: function() {
                if (!this.promise) {
                    var self = this;
                    this.promise = $q(function(resolve, reject) {
                        self.done(function(status) {
                            status === !1 ? reject() : resolve();
                        });
                    });
                }
                return this.promise;
            },
            then: function(resolveHandler, rejectHandler) {
                return this.getPromise().then(resolveHandler, rejectHandler);
            },
            "catch": function(handler) {
                return this.getPromise()["catch"](handler);
            },
            "finally": function(handler) {
                return this.getPromise()["finally"](handler);
            },
            pause: function() {
                this.host.pause && this.host.pause();
            },
            resume: function() {
                this.host.resume && this.host.resume();
            },
            end: function() {
                this.host.end && this.host.end(), this._resolve(!0);
            },
            cancel: function() {
                this.host.cancel && this.host.cancel(), this._resolve(!1);
            },
            complete: function(response) {
                var self = this;
                self._state === INITIAL_STATE && (self._state = DONE_PENDING_STATE, self._runInAnimationFrame(function() {
                    self._resolve(response);
                }));
            },
            _resolve: function(response) {
                this._state !== DONE_COMPLETE_STATE && (forEach(this._doneCallbacks, function(fn) {
                    fn(response);
                }), this._doneCallbacks.length = 0, this._state = DONE_COMPLETE_STATE);
            }
        }, AnimateRunner;
    } ], $$AnimationProvider = [ "$animateProvider", function($animateProvider) {
        function setRunner(element, runner) {
            element.data(RUNNER_STORAGE_KEY, runner);
        }
        function removeRunner(element) {
            element.removeData(RUNNER_STORAGE_KEY);
        }
        function getRunner(element) {
            return element.data(RUNNER_STORAGE_KEY);
        }
        var NG_ANIMATE_REF_ATTR = "ng-animate-ref", drivers = this.drivers = [], RUNNER_STORAGE_KEY = "$$animationRunner";
        this.$get = [ "$$jqLite", "$rootScope", "$injector", "$$AnimateRunner", "$$rAFScheduler", function($$jqLite, $rootScope, $injector, $$AnimateRunner, $$rAFScheduler) {
            var animationQueue = [], applyAnimationClasses = applyAnimationClassesFactory($$jqLite), totalPendingClassBasedAnimations = 0, totalActiveClassBasedAnimations = 0, classBasedAnimationsQueue = [];
            return function(element, event, options) {
                function getAnchorNodes(node) {
                    var SELECTOR = "[" + NG_ANIMATE_REF_ATTR + "]", items = node.hasAttribute(NG_ANIMATE_REF_ATTR) ? [ node ] : node.querySelectorAll(SELECTOR), anchors = [];
                    return forEach(items, function(node) {
                        var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
                        attr && attr.length && anchors.push(node);
                    }), anchors;
                }
                function groupAnimations(animations) {
                    var preparedAnimations = [], refLookup = {};
                    forEach(animations, function(animation, index) {
                        var element = animation.element, node = getDomNode(element), event = animation.event, enterOrMove = [ "enter", "move" ].indexOf(event) >= 0, anchorNodes = animation.structural ? getAnchorNodes(node) : [];
                        if (anchorNodes.length) {
                            var direction = enterOrMove ? "to" : "from";
                            forEach(anchorNodes, function(anchor) {
                                var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
                                refLookup[key] = refLookup[key] || {}, refLookup[key][direction] = {
                                    animationID: index,
                                    element: jqLite(anchor)
                                };
                            });
                        } else preparedAnimations.push(animation);
                    });
                    var usedIndicesLookup = {}, anchorGroups = {};
                    return forEach(refLookup, function(operations, key) {
                        var from = operations.from, to = operations.to;
                        if (!from || !to) {
                            var index = from ? from.animationID : to.animationID, indexKey = index.toString();
                            return void (usedIndicesLookup[indexKey] || (usedIndicesLookup[indexKey] = !0, preparedAnimations.push(animations[index])));
                        }
                        var fromAnimation = animations[from.animationID], toAnimation = animations[to.animationID], lookupKey = from.animationID.toString();
                        if (!anchorGroups[lookupKey]) {
                            var group = anchorGroups[lookupKey] = {
                                structural: !0,
                                beforeStart: function() {
                                    fromAnimation.beforeStart(), toAnimation.beforeStart();
                                },
                                close: function() {
                                    fromAnimation.close(), toAnimation.close();
                                },
                                classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
                                from: fromAnimation,
                                to: toAnimation,
                                anchors: []
                            };
                            group.classes.length ? preparedAnimations.push(group) : (preparedAnimations.push(fromAnimation), 
                            preparedAnimations.push(toAnimation));
                        }
                        anchorGroups[lookupKey].anchors.push({
                            out: from.element,
                            "in": to.element
                        });
                    }), preparedAnimations;
                }
                function cssClassesIntersection(a, b) {
                    a = a.split(" "), b = b.split(" ");
                    for (var matches = [], i = 0; i < a.length; i++) {
                        var aa = a[i];
                        if ("ng-" !== aa.substring(0, 3)) for (var j = 0; j < b.length; j++) if (aa === b[j]) {
                            matches.push(aa);
                            break;
                        }
                    }
                    return matches.join(" ");
                }
                function invokeFirstDriver(animationDetails) {
                    for (var i = drivers.length - 1; i >= 0; i--) {
                        var driverName = drivers[i];
                        if ($injector.has(driverName)) {
                            var factory = $injector.get(driverName), driver = factory(animationDetails);
                            if (driver) return driver;
                        }
                    }
                }
                function beforeStart() {
                    element.addClass(NG_ANIMATE_CLASSNAME), tempClasses && $$jqLite.addClass(element, tempClasses);
                }
                function updateAnimationRunners(animation, newRunner) {
                    function update(element) {
                        getRunner(element).setHost(newRunner);
                    }
                    animation.from && animation.to ? (update(animation.from.element), update(animation.to.element)) : update(animation.element);
                }
                function handleDestroyedElement() {
                    var runner = getRunner(element);
                    !runner || "leave" === event && options.$$domOperationFired || runner.end();
                }
                function close(rejected) {
                    element.off("$destroy", handleDestroyedElement), removeRunner(element), applyAnimationClasses(element, options), 
                    applyAnimationStyles(element, options), options.domOperation(), tempClasses && $$jqLite.removeClass(element, tempClasses), 
                    element.removeClass(NG_ANIMATE_CLASSNAME), runner.complete(!rejected);
                }
                options = prepareAnimationOptions(options);
                var isStructural = [ "enter", "move", "leave" ].indexOf(event) >= 0, runner = new $$AnimateRunner({
                    end: function() {
                        close();
                    },
                    cancel: function() {
                        close(!0);
                    }
                });
                if (!drivers.length) return close(), runner;
                setRunner(element, runner);
                var classes = mergeClasses(element.attr("class"), mergeClasses(options.addClass, options.removeClass)), tempClasses = options.tempClasses;
                tempClasses && (classes += " " + tempClasses, options.tempClasses = null);
                var classBasedIndex;
                return isStructural || (classBasedIndex = totalPendingClassBasedAnimations, totalPendingClassBasedAnimations += 1), 
                animationQueue.push({
                    element: element,
                    classes: classes,
                    event: event,
                    classBasedIndex: classBasedIndex,
                    structural: isStructural,
                    options: options,
                    beforeStart: beforeStart,
                    close: close
                }), element.on("$destroy", handleDestroyedElement), animationQueue.length > 1 ? runner : ($rootScope.$$postDigest(function() {
                    totalActiveClassBasedAnimations = totalPendingClassBasedAnimations, totalPendingClassBasedAnimations = 0, 
                    classBasedAnimationsQueue.length = 0;
                    var animations = [];
                    forEach(animationQueue, function(entry) {
                        getRunner(entry.element) && animations.push(entry);
                    }), animationQueue.length = 0, forEach(groupAnimations(animations), function(animationEntry) {
                        function triggerAnimationStart() {
                            animationEntry.beforeStart();
                            var startAnimationFn, closeFn = animationEntry.close, targetElement = animationEntry.anchors ? animationEntry.from.element || animationEntry.to.element : animationEntry.element;
                            if (getRunner(targetElement) && getDomNode(targetElement).parentNode) {
                                var operation = invokeFirstDriver(animationEntry);
                                operation && (startAnimationFn = operation.start);
                            }
                            if (startAnimationFn) {
                                var animationRunner = startAnimationFn();
                                animationRunner.done(function(status) {
                                    closeFn(!status);
                                }), updateAnimationRunners(animationEntry, animationRunner);
                            } else closeFn();
                        }
                        animationEntry.structural ? triggerAnimationStart() : (classBasedAnimationsQueue.push({
                            node: getDomNode(animationEntry.element),
                            fn: triggerAnimationStart
                        }), animationEntry.classBasedIndex === totalActiveClassBasedAnimations - 1 && (classBasedAnimationsQueue = classBasedAnimationsQueue.sort(function(a, b) {
                            return b.node.contains(a.node);
                        }).map(function(entry) {
                            return entry.fn;
                        }), $$rAFScheduler(classBasedAnimationsQueue)));
                    });
                }), runner);
            };
        } ];
    } ];
    angular.module("ngAnimate", []).directive("ngAnimateChildren", $$AnimateChildrenDirective).factory("$$rAFMutex", $$rAFMutexFactory).factory("$$rAFScheduler", $$rAFSchedulerFactory).factory("$$AnimateRunner", $$AnimateRunnerFactory).provider("$$animateQueue", $$AnimateQueueProvider).provider("$$animation", $$AnimationProvider).provider("$animateCss", $AnimateCssProvider).provider("$$animateCssDriver", $$AnimateCssDriverProvider).provider("$$animateJs", $$AnimateJsProvider).provider("$$animateJsDriver", $$AnimateJsDriverProvider);
}(window, window.angular), function(window, angular, undefined) {
    "use strict";
    function $SanitizeProvider() {
        this.$get = [ "$$sanitizeUri", function($$sanitizeUri) {
            return function(html) {
                var buf = [];
                return htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
                    return !/^unsafe/.test($$sanitizeUri(uri, isImage));
                })), buf.join("");
            };
        } ];
    }
    function sanitizeText(chars) {
        var buf = [], writer = htmlSanitizeWriter(buf, angular.noop);
        return writer.chars(chars), buf.join("");
    }
    function makeMap(str, lowercaseKeys) {
        var i, obj = {}, items = str.split(",");
        for (i = 0; i < items.length; i++) obj[lowercaseKeys ? angular.lowercase(items[i]) : items[i]] = !0;
        return obj;
    }
    function htmlParser(html, handler) {
        function parseStartTag(tag, tagName, rest, unary) {
            if (tagName = angular.lowercase(tagName), blockElements[tagName]) for (;stack.last() && inlineElements[stack.last()]; ) parseEndTag("", stack.last());
            optionalEndTagElements[tagName] && stack.last() == tagName && parseEndTag("", tagName), 
            unary = voidElements[tagName] || !!unary, unary || stack.push(tagName);
            var attrs = {};
            rest.replace(ATTR_REGEXP, function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {
                var value = doubleQuotedValue || singleQuotedValue || unquotedValue || "";
                attrs[name] = decodeEntities(value);
            }), handler.start && handler.start(tagName, attrs, unary);
        }
        function parseEndTag(tag, tagName) {
            var i, pos = 0;
            if (tagName = angular.lowercase(tagName)) for (pos = stack.length - 1; pos >= 0 && stack[pos] != tagName; pos--) ;
            if (pos >= 0) {
                for (i = stack.length - 1; i >= pos; i--) handler.end && handler.end(stack[i]);
                stack.length = pos;
            }
        }
        "string" != typeof html && (html = null === html || "undefined" == typeof html ? "" : "" + html);
        var index, chars, match, text, stack = [], last = html;
        for (stack.last = function() {
            return stack[stack.length - 1];
        }; html; ) {
            if (text = "", chars = !0, stack.last() && specialElements[stack.last()] ? (html = html.replace(new RegExp("([\\W\\w]*)<\\s*\\/\\s*" + stack.last() + "[^>]*>", "i"), function(all, text) {
                return text = text.replace(COMMENT_REGEXP, "$1").replace(CDATA_REGEXP, "$1"), handler.chars && handler.chars(decodeEntities(text)), 
                "";
            }), parseEndTag("", stack.last())) : (0 === html.indexOf("<!--") ? (index = html.indexOf("--", 4), 
            index >= 0 && html.lastIndexOf("-->", index) === index && (handler.comment && handler.comment(html.substring(4, index)), 
            html = html.substring(index + 3), chars = !1)) : DOCTYPE_REGEXP.test(html) ? (match = html.match(DOCTYPE_REGEXP), 
            match && (html = html.replace(match[0], ""), chars = !1)) : BEGING_END_TAGE_REGEXP.test(html) ? (match = html.match(END_TAG_REGEXP), 
            match && (html = html.substring(match[0].length), match[0].replace(END_TAG_REGEXP, parseEndTag), 
            chars = !1)) : BEGIN_TAG_REGEXP.test(html) && (match = html.match(START_TAG_REGEXP), 
            match ? (match[4] && (html = html.substring(match[0].length), match[0].replace(START_TAG_REGEXP, parseStartTag)), 
            chars = !1) : (text += "<", html = html.substring(1))), chars && (index = html.indexOf("<"), 
            text += 0 > index ? html : html.substring(0, index), html = 0 > index ? "" : html.substring(index), 
            handler.chars && handler.chars(decodeEntities(text)))), html == last) throw $sanitizeMinErr("badparse", "The sanitizer was unable to parse the following block of html: {0}", html);
            last = html;
        }
        parseEndTag();
    }
    function decodeEntities(value) {
        return value ? (hiddenPre.innerHTML = value.replace(/</g, "&lt;"), hiddenPre.textContent) : "";
    }
    function encodeEntities(value) {
        return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, function(value) {
            var hi = value.charCodeAt(0), low = value.charCodeAt(1);
            return "&#" + (1024 * (hi - 55296) + (low - 56320) + 65536) + ";";
        }).replace(NON_ALPHANUMERIC_REGEXP, function(value) {
            return "&#" + value.charCodeAt(0) + ";";
        }).replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    function htmlSanitizeWriter(buf, uriValidator) {
        var ignore = !1, out = angular.bind(buf, buf.push);
        return {
            start: function(tag, attrs, unary) {
                tag = angular.lowercase(tag), !ignore && specialElements[tag] && (ignore = tag), 
                ignore || validElements[tag] !== !0 || (out("<"), out(tag), angular.forEach(attrs, function(value, key) {
                    var lkey = angular.lowercase(key), isImage = "img" === tag && "src" === lkey || "background" === lkey;
                    validAttrs[lkey] !== !0 || uriAttrs[lkey] === !0 && !uriValidator(value, isImage) || (out(" "), 
                    out(key), out('="'), out(encodeEntities(value)), out('"'));
                }), out(unary ? "/>" : ">"));
            },
            end: function(tag) {
                tag = angular.lowercase(tag), ignore || validElements[tag] !== !0 || (out("</"), 
                out(tag), out(">")), tag == ignore && (ignore = !1);
            },
            chars: function(chars) {
                ignore || out(encodeEntities(chars));
            }
        };
    }
    var $sanitizeMinErr = angular.$$minErr("$sanitize"), START_TAG_REGEXP = /^<((?:[a-zA-Z])[\w:-]*)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*(>?)/, END_TAG_REGEXP = /^<\/\s*([\w:-]+)[^>]*>/, ATTR_REGEXP = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g, BEGIN_TAG_REGEXP = /^</, BEGING_END_TAGE_REGEXP = /^<\//, COMMENT_REGEXP = /<!--(.*?)-->/g, DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i, CDATA_REGEXP = /<!\[CDATA\[(.*?)]]>/g, SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g, voidElements = makeMap("area,br,col,hr,img,wbr"), optionalEndTagBlockElements = makeMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), optionalEndTagInlineElements = makeMap("rp,rt"), optionalEndTagElements = angular.extend({}, optionalEndTagInlineElements, optionalEndTagBlockElements), blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap("address,article,aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul")), inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap("a,abbr,acronym,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,samp,small,span,strike,strong,sub,sup,time,tt,u,var")), svgElements = makeMap("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,radialGradient,rect,stop,svg,switch,text,title,tspan,use"), specialElements = makeMap("script,style"), validElements = angular.extend({}, voidElements, blockElements, inlineElements, optionalEndTagElements, svgElements), uriAttrs = makeMap("background,cite,href,longdesc,src,usemap,xlink:href"), htmlAttrs = makeMap("abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,valign,value,vspace,width"), svgAttrs = makeMap("accent-height,accumulate,additive,alphabetic,arabic-form,ascent,baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan", !0), validAttrs = angular.extend({}, uriAttrs, svgAttrs, htmlAttrs), hiddenPre = document.createElement("pre");
    angular.module("ngSanitize", []).provider("$sanitize", $SanitizeProvider), angular.module("ngSanitize").filter("linky", [ "$sanitize", function($sanitize) {
        var LINKY_URL_REGEXP = /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"”’]/i, MAILTO_REGEXP = /^mailto:/i;
        return function(text, target) {
            function addText(text) {
                text && html.push(sanitizeText(text));
            }
            function addLink(url, text) {
                html.push("<a "), angular.isDefined(target) && html.push('target="', target, '" '), 
                html.push('href="', url.replace(/"/g, "&quot;"), '">'), addText(text), html.push("</a>");
            }
            if (!text) return text;
            for (var match, url, i, raw = text, html = []; match = raw.match(LINKY_URL_REGEXP); ) url = match[0], 
            match[2] || match[4] || (url = (match[3] ? "http://" : "mailto:") + url), i = match.index, 
            addText(raw.substr(0, i)), addLink(url, match[0].replace(MAILTO_REGEXP, "")), raw = raw.substring(i + match[0].length);
            return addText(raw), $sanitize(html.join(""));
        };
    } ]);
}(window, window.angular), "undefined" != typeof module && "undefined" != typeof exports && module.exports === exports && (module.exports = "ui.router"), 
function(window, angular, undefined) {
    "use strict";
    function inherit(parent, extra) {
        return extend(new (extend(function() {}, {
            prototype: parent
        }))(), extra);
    }
    function merge(dst) {
        return forEach(arguments, function(obj) {
            obj !== dst && forEach(obj, function(value, key) {
                dst.hasOwnProperty(key) || (dst[key] = value);
            });
        }), dst;
    }
    function ancestors(first, second) {
        var path = [];
        for (var n in first.path) {
            if (first.path[n] !== second.path[n]) break;
            path.push(first.path[n]);
        }
        return path;
    }
    function objectKeys(object) {
        if (Object.keys) return Object.keys(object);
        var result = [];
        return angular.forEach(object, function(val, key) {
            result.push(key);
        }), result;
    }
    function indexOf(array, value) {
        if (Array.prototype.indexOf) return array.indexOf(value, Number(arguments[2]) || 0);
        var len = array.length >>> 0, from = Number(arguments[2]) || 0;
        for (from = 0 > from ? Math.ceil(from) : Math.floor(from), 0 > from && (from += len); len > from; from++) if (from in array && array[from] === value) return from;
        return -1;
    }
    function inheritParams(currentParams, newParams, $current, $to) {
        var parentParams, parents = ancestors($current, $to), inherited = {}, inheritList = [];
        for (var i in parents) if (parents[i].params && (parentParams = objectKeys(parents[i].params), 
        parentParams.length)) for (var j in parentParams) indexOf(inheritList, parentParams[j]) >= 0 || (inheritList.push(parentParams[j]), 
        inherited[parentParams[j]] = currentParams[parentParams[j]]);
        return extend({}, inherited, newParams);
    }
    function equalForKeys(a, b, keys) {
        if (!keys) {
            keys = [];
            for (var n in a) keys.push(n);
        }
        for (var i = 0; i < keys.length; i++) {
            var k = keys[i];
            if (a[k] != b[k]) return !1;
        }
        return !0;
    }
    function filterByKeys(keys, values) {
        var filtered = {};
        return forEach(keys, function(name) {
            filtered[name] = values[name];
        }), filtered;
    }
    function omit(obj) {
        var copy = {}, keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        for (var key in obj) -1 == indexOf(keys, key) && (copy[key] = obj[key]);
        return copy;
    }
    function filter(collection, callback) {
        var array = isArray(collection), result = array ? [] : {};
        return forEach(collection, function(val, i) {
            callback(val, i) && (result[array ? result.length : i] = val);
        }), result;
    }
    function map(collection, callback) {
        var result = isArray(collection) ? [] : {};
        return forEach(collection, function(val, i) {
            result[i] = callback(val, i);
        }), result;
    }
    function $Resolve($q, $injector) {
        var VISIT_IN_PROGRESS = 1, VISIT_DONE = 2, NOTHING = {}, NO_DEPENDENCIES = [], NO_LOCALS = NOTHING, NO_PARENT = extend($q.when(NOTHING), {
            $$promises: NOTHING,
            $$values: NOTHING
        });
        this.study = function(invocables) {
            function visit(value, key) {
                if (visited[key] !== VISIT_DONE) {
                    if (cycle.push(key), visited[key] === VISIT_IN_PROGRESS) throw cycle.splice(0, indexOf(cycle, key)), 
                    new Error("Cyclic dependency: " + cycle.join(" -> "));
                    if (visited[key] = VISIT_IN_PROGRESS, isString(value)) plan.push(key, [ function() {
                        return $injector.get(value);
                    } ], NO_DEPENDENCIES); else {
                        var params = $injector.annotate(value);
                        forEach(params, function(param) {
                            param !== key && invocables.hasOwnProperty(param) && visit(invocables[param], param);
                        }), plan.push(key, value, params);
                    }
                    cycle.pop(), visited[key] = VISIT_DONE;
                }
            }
            function isResolve(value) {
                return isObject(value) && value.then && value.$$promises;
            }
            if (!isObject(invocables)) throw new Error("'invocables' must be an object");
            var invocableKeys = objectKeys(invocables || {}), plan = [], cycle = [], visited = {};
            return forEach(invocables, visit), invocables = cycle = visited = null, function(locals, parent, self) {
                function done() {
                    --wait || (merged || merge(values, parent.$$values), result.$$values = values, result.$$promises = result.$$promises || !0, 
                    delete result.$$inheritedValues, resolution.resolve(values));
                }
                function fail(reason) {
                    result.$$failure = reason, resolution.reject(reason);
                }
                function invoke(key, invocable, params) {
                    function onfailure(reason) {
                        invocation.reject(reason), fail(reason);
                    }
                    function proceed() {
                        if (!isDefined(result.$$failure)) try {
                            invocation.resolve($injector.invoke(invocable, self, values)), invocation.promise.then(function(result) {
                                values[key] = result, done();
                            }, onfailure);
                        } catch (e) {
                            onfailure(e);
                        }
                    }
                    var invocation = $q.defer(), waitParams = 0;
                    forEach(params, function(dep) {
                        promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep) && (waitParams++, promises[dep].then(function(result) {
                            values[dep] = result, --waitParams || proceed();
                        }, onfailure));
                    }), waitParams || proceed(), promises[key] = invocation.promise;
                }
                if (isResolve(locals) && self === undefined && (self = parent, parent = locals, 
                locals = null), locals) {
                    if (!isObject(locals)) throw new Error("'locals' must be an object");
                } else locals = NO_LOCALS;
                if (parent) {
                    if (!isResolve(parent)) throw new Error("'parent' must be a promise returned by $resolve.resolve()");
                } else parent = NO_PARENT;
                var resolution = $q.defer(), result = resolution.promise, promises = result.$$promises = {}, values = extend({}, locals), wait = 1 + plan.length / 3, merged = !1;
                if (isDefined(parent.$$failure)) return fail(parent.$$failure), result;
                parent.$$inheritedValues && merge(values, omit(parent.$$inheritedValues, invocableKeys)), 
                extend(promises, parent.$$promises), parent.$$values ? (merged = merge(values, omit(parent.$$values, invocableKeys)), 
                result.$$inheritedValues = omit(parent.$$values, invocableKeys), done()) : (parent.$$inheritedValues && (result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys)), 
                parent.then(done, fail));
                for (var i = 0, ii = plan.length; ii > i; i += 3) locals.hasOwnProperty(plan[i]) ? done() : invoke(plan[i], plan[i + 1], plan[i + 2]);
                return result;
            };
        }, this.resolve = function(invocables, locals, parent, self) {
            return this.study(invocables)(locals, parent, self);
        };
    }
    function $TemplateFactory($http, $templateCache, $injector) {
        this.fromConfig = function(config, params, locals) {
            return isDefined(config.template) ? this.fromString(config.template, params) : isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) : isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) : null;
        }, this.fromString = function(template, params) {
            return isFunction(template) ? template(params) : template;
        }, this.fromUrl = function(url, params) {
            return isFunction(url) && (url = url(params)), null == url ? null : $http.get(url, {
                cache: $templateCache,
                headers: {
                    Accept: "text/html"
                }
            }).then(function(response) {
                return response.data;
            });
        }, this.fromProvider = function(provider, params, locals) {
            return $injector.invoke(provider, null, locals || {
                params: params
            });
        };
    }
    function UrlMatcher(pattern, config, parentMatcher) {
        function addParameter(id, type, config, location) {
            if (paramNames.push(id), parentParams[id]) return parentParams[id];
            if (!/^\w+(-+\w+)*(?:\[\])?$/.test(id)) throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
            if (params[id]) throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
            return params[id] = new $$UMFP.Param(id, type, config, location), params[id];
        }
        function quoteRegExp(string, pattern, squash) {
            var surroundPattern = [ "", "" ], result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
            if (!pattern) return result;
            switch (squash) {
              case !1:
                surroundPattern = [ "(", ")" ];
                break;

              case !0:
                surroundPattern = [ "?(", ")?" ];
                break;

              default:
                surroundPattern = [ "(" + squash + "|", ")?" ];
            }
            return result + surroundPattern[0] + pattern + surroundPattern[1];
        }
        function matchDetails(m, isSearch) {
            var id, regexp, segment, type, cfg;
            return id = m[2] || m[3], cfg = config.params[id], segment = pattern.substring(last, m.index), 
            regexp = isSearch ? m[4] : m[4] || ("*" == m[1] ? ".*" : null), type = $$UMFP.type(regexp || "string") || inherit($$UMFP.type("string"), {
                pattern: new RegExp(regexp)
            }), {
                id: id,
                regexp: regexp,
                segment: segment,
                type: type,
                cfg: cfg
            };
        }
        config = extend({
            params: {}
        }, isObject(config) ? config : {});
        var m, placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, searchPlaceholder = /([:]?)([\w\[\]-]+)|\{([\w\[\]-]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, compiled = "^", last = 0, segments = this.segments = [], parentParams = parentMatcher ? parentMatcher.params : {}, params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(), paramNames = [];
        this.source = pattern;
        for (var p, param, segment; (m = placeholder.exec(pattern)) && (p = matchDetails(m, !1), 
        !(p.segment.indexOf("?") >= 0)); ) param = addParameter(p.id, p.type, p.cfg, "path"), 
        compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash), segments.push(p.segment), 
        last = placeholder.lastIndex;
        segment = pattern.substring(last);
        var i = segment.indexOf("?");
        if (i >= 0) {
            var search = this.sourceSearch = segment.substring(i);
            if (segment = segment.substring(0, i), this.sourcePath = pattern.substring(0, last + i), 
            search.length > 0) for (last = 0; m = searchPlaceholder.exec(search); ) p = matchDetails(m, !0), 
            param = addParameter(p.id, p.type, p.cfg, "search"), last = placeholder.lastIndex;
        } else this.sourcePath = pattern, this.sourceSearch = "";
        compiled += quoteRegExp(segment) + (config.strict === !1 ? "/?" : "") + "$", segments.push(segment), 
        this.regexp = new RegExp(compiled, config.caseInsensitive ? "i" : undefined), this.prefix = segments[0], 
        this.$$paramNames = paramNames;
    }
    function Type(config) {
        extend(this, config);
    }
    function $UrlMatcherFactory() {
        function valToString(val) {
            return null != val ? val.toString().replace(/\//g, "%2F") : val;
        }
        function valFromString(val) {
            return null != val ? val.toString().replace(/%2F/g, "/") : val;
        }
        function regexpMatches(val) {
            return this.pattern.test(val);
        }
        function getDefaultConfig() {
            return {
                strict: isStrictMode,
                caseInsensitive: isCaseInsensitive
            };
        }
        function isInjectable(value) {
            return isFunction(value) || isArray(value) && isFunction(value[value.length - 1]);
        }
        function flushTypeQueue() {
            for (;typeQueue.length; ) {
                var type = typeQueue.shift();
                if (type.pattern) throw new Error("You cannot override a type's .pattern at runtime.");
                angular.extend($types[type.name], injector.invoke(type.def));
            }
        }
        function ParamSet(params) {
            extend(this, params || {});
        }
        $$UMFP = this;
        var injector, isCaseInsensitive = !1, isStrictMode = !0, defaultSquashPolicy = !1, $types = {}, enqueue = !0, typeQueue = [], defaultTypes = {
            string: {
                encode: valToString,
                decode: valFromString,
                is: regexpMatches,
                pattern: /[^\/]*/
            },
            "int": {
                encode: valToString,
                decode: function(val) {
                    return parseInt(val, 10);
                },
                is: function(val) {
                    return isDefined(val) && this.decode(val.toString()) === val;
                },
                pattern: /\d+/
            },
            bool: {
                encode: function(val) {
                    return val ? 1 : 0;
                },
                decode: function(val) {
                    return 0 !== parseInt(val, 10);
                },
                is: function(val) {
                    return val === !0 || val === !1;
                },
                pattern: /0|1/
            },
            date: {
                encode: function(val) {
                    return this.is(val) ? [ val.getFullYear(), ("0" + (val.getMonth() + 1)).slice(-2), ("0" + val.getDate()).slice(-2) ].join("-") : undefined;
                },
                decode: function(val) {
                    if (this.is(val)) return val;
                    var match = this.capture.exec(val);
                    return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
                },
                is: function(val) {
                    return val instanceof Date && !isNaN(val.valueOf());
                },
                equals: function(a, b) {
                    return this.is(a) && this.is(b) && a.toISOString() === b.toISOString();
                },
                pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
            },
            json: {
                encode: angular.toJson,
                decode: angular.fromJson,
                is: angular.isObject,
                equals: angular.equals,
                pattern: /[^\/]*/
            },
            any: {
                encode: angular.identity,
                decode: angular.identity,
                is: angular.identity,
                equals: angular.equals,
                pattern: /.*/
            }
        };
        $UrlMatcherFactory.$$getDefaultValue = function(config) {
            if (!isInjectable(config.value)) return config.value;
            if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
            return injector.invoke(config.value);
        }, this.caseInsensitive = function(value) {
            return isDefined(value) && (isCaseInsensitive = value), isCaseInsensitive;
        }, this.strictMode = function(value) {
            return isDefined(value) && (isStrictMode = value), isStrictMode;
        }, this.defaultSquashPolicy = function(value) {
            if (!isDefined(value)) return defaultSquashPolicy;
            if (value !== !0 && value !== !1 && !isString(value)) throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
            return defaultSquashPolicy = value, value;
        }, this.compile = function(pattern, config) {
            return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
        }, this.isMatcher = function(o) {
            if (!isObject(o)) return !1;
            var result = !0;
            return forEach(UrlMatcher.prototype, function(val, name) {
                isFunction(val) && (result = result && isDefined(o[name]) && isFunction(o[name]));
            }), result;
        }, this.type = function(name, definition, definitionFn) {
            if (!isDefined(definition)) return $types[name];
            if ($types.hasOwnProperty(name)) throw new Error("A type named '" + name + "' has already been defined.");
            return $types[name] = new Type(extend({
                name: name
            }, definition)), definitionFn && (typeQueue.push({
                name: name,
                def: definitionFn
            }), enqueue || flushTypeQueue()), this;
        }, forEach(defaultTypes, function(type, name) {
            $types[name] = new Type(extend({
                name: name
            }, type));
        }), $types = inherit($types, {}), this.$get = [ "$injector", function($injector) {
            return injector = $injector, enqueue = !1, flushTypeQueue(), forEach(defaultTypes, function(type, name) {
                $types[name] || ($types[name] = new Type(type));
            }), this;
        } ], this.Param = function(id, type, config, location) {
            function unwrapShorthand(config) {
                var keys = isObject(config) ? objectKeys(config) : [], isShorthand = -1 === indexOf(keys, "value") && -1 === indexOf(keys, "type") && -1 === indexOf(keys, "squash") && -1 === indexOf(keys, "array");
                return isShorthand && (config = {
                    value: config
                }), config.$$fn = isInjectable(config.value) ? config.value : function() {
                    return config.value;
                }, config;
            }
            function getType(config, urlType, location) {
                if (config.type && urlType) throw new Error("Param '" + id + "' has two type configurations.");
                return urlType ? urlType : config.type ? config.type instanceof Type ? config.type : new Type(config.type) : "config" === location ? $types.any : $types.string;
            }
            function getArrayMode() {
                var arrayDefaults = {
                    array: "search" === location ? "auto" : !1
                }, arrayParamNomenclature = id.match(/\[\]$/) ? {
                    array: !0
                } : {};
                return extend(arrayDefaults, arrayParamNomenclature, config).array;
            }
            function getSquashPolicy(config, isOptional) {
                var squash = config.squash;
                if (!isOptional || squash === !1) return !1;
                if (!isDefined(squash) || null == squash) return defaultSquashPolicy;
                if (squash === !0 || isString(squash)) return squash;
                throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
            }
            function getReplace(config, arrayMode, isOptional, squash) {
                var replace, configuredKeys, defaultPolicy = [ {
                    from: "",
                    to: isOptional || arrayMode ? undefined : ""
                }, {
                    from: null,
                    to: isOptional || arrayMode ? undefined : ""
                } ];
                return replace = isArray(config.replace) ? config.replace : [], isString(squash) && replace.push({
                    from: squash,
                    to: undefined
                }), configuredKeys = map(replace, function(item) {
                    return item.from;
                }), filter(defaultPolicy, function(item) {
                    return -1 === indexOf(configuredKeys, item.from);
                }).concat(replace);
            }
            function $$getDefaultValue() {
                if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
                return injector.invoke(config.$$fn);
            }
            function $value(value) {
                function hasReplaceVal(val) {
                    return function(obj) {
                        return obj.from === val;
                    };
                }
                function $replace(value) {
                    var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) {
                        return obj.to;
                    });
                    return replacement.length ? replacement[0] : value;
                }
                return value = $replace(value), isDefined(value) ? self.type.decode(value) : $$getDefaultValue();
            }
            function toString() {
                return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}";
            }
            var self = this;
            config = unwrapShorthand(config), type = getType(config, type, location);
            var arrayMode = getArrayMode();
            type = arrayMode ? type.$asArray(arrayMode, "search" === location) : type, "string" !== type.name || arrayMode || "path" !== location || config.value !== undefined || (config.value = "");
            var isOptional = config.value !== undefined, squash = getSquashPolicy(config, isOptional), replace = getReplace(config, arrayMode, isOptional, squash);
            extend(this, {
                id: id,
                type: type,
                location: location,
                array: arrayMode,
                squash: squash,
                replace: replace,
                isOptional: isOptional,
                value: $value,
                dynamic: undefined,
                config: config,
                toString: toString
            });
        }, ParamSet.prototype = {
            $$new: function() {
                return inherit(this, extend(new ParamSet(), {
                    $$parent: this
                }));
            },
            $$keys: function() {
                for (var keys = [], chain = [], parent = this, ignore = objectKeys(ParamSet.prototype); parent; ) chain.push(parent), 
                parent = parent.$$parent;
                return chain.reverse(), forEach(chain, function(paramset) {
                    forEach(objectKeys(paramset), function(key) {
                        -1 === indexOf(keys, key) && -1 === indexOf(ignore, key) && keys.push(key);
                    });
                }), keys;
            },
            $$values: function(paramValues) {
                var values = {}, self = this;
                return forEach(self.$$keys(), function(key) {
                    values[key] = self[key].value(paramValues && paramValues[key]);
                }), values;
            },
            $$equals: function(paramValues1, paramValues2) {
                var equal = !0, self = this;
                return forEach(self.$$keys(), function(key) {
                    var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];
                    self[key].type.equals(left, right) || (equal = !1);
                }), equal;
            },
            $$validates: function(paramValues) {
                var isOptional, val, param, result = !0, self = this;
                return forEach(this.$$keys(), function(key) {
                    param = self[key], val = paramValues[key], isOptional = !val && param.isOptional, 
                    result = result && (isOptional || !!param.type.is(val));
                }), result;
            },
            $$parent: undefined
        }, this.ParamSet = ParamSet;
    }
    function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {
        function regExpPrefix(re) {
            var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
            return null != prefix ? prefix[1].replace(/\\(.)/g, "$1") : "";
        }
        function interpolate(pattern, match) {
            return pattern.replace(/\$(\$|\d{1,2})/, function(m, what) {
                return match["$" === what ? 0 : Number(what)];
            });
        }
        function handleIfMatch($injector, handler, match) {
            if (!match) return !1;
            var result = $injector.invoke(handler, handler, {
                $match: match
            });
            return isDefined(result) ? result : !0;
        }
        function $get($location, $rootScope, $injector, $browser) {
            function appendBasePath(url, isHtml5, absolute) {
                return "/" === baseHref ? url : isHtml5 ? baseHref.slice(0, -1) + url : absolute ? baseHref.slice(1) + url : url;
            }
            function update(evt) {
                function check(rule) {
                    var handled = rule($injector, $location);
                    return handled ? (isString(handled) && $location.replace().url(handled), !0) : !1;
                }
                if (!evt || !evt.defaultPrevented) {
                    var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;
                    if (lastPushedUrl = undefined, ignoreUpdate) return !0;
                    var i, n = rules.length;
                    for (i = 0; n > i; i++) if (check(rules[i])) return;
                    otherwise && check(otherwise);
                }
            }
            function listen() {
                return listener = listener || $rootScope.$on("$locationChangeSuccess", update);
            }
            var lastPushedUrl, baseHref = $browser.baseHref(), location = $location.url();
            return interceptDeferred || listen(), {
                sync: function() {
                    update();
                },
                listen: function() {
                    return listen();
                },
                update: function(read) {
                    return read ? void (location = $location.url()) : void ($location.url() !== location && ($location.url(location), 
                    $location.replace()));
                },
                push: function(urlMatcher, params, options) {
                    $location.url(urlMatcher.format(params || {})), lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined, 
                    options && options.replace && $location.replace();
                },
                href: function(urlMatcher, params, options) {
                    if (!urlMatcher.validates(params)) return null;
                    var isHtml5 = $locationProvider.html5Mode();
                    angular.isObject(isHtml5) && (isHtml5 = isHtml5.enabled);
                    var url = urlMatcher.format(params);
                    if (options = options || {}, isHtml5 || null === url || (url = "#" + $locationProvider.hashPrefix() + url), 
                    url = appendBasePath(url, isHtml5, options.absolute), !options.absolute || !url) return url;
                    var slash = !isHtml5 && url ? "/" : "", port = $location.port();
                    return port = 80 === port || 443 === port ? "" : ":" + port, [ $location.protocol(), "://", $location.host(), port, slash, url ].join("");
                }
            };
        }
        var listener, rules = [], otherwise = null, interceptDeferred = !1;
        this.rule = function(rule) {
            if (!isFunction(rule)) throw new Error("'rule' must be a function");
            return rules.push(rule), this;
        }, this.otherwise = function(rule) {
            if (isString(rule)) {
                var redirect = rule;
                rule = function() {
                    return redirect;
                };
            } else if (!isFunction(rule)) throw new Error("'rule' must be a function");
            return otherwise = rule, this;
        }, this.when = function(what, handler) {
            var redirect, handlerIsString = isString(handler);
            if (isString(what) && (what = $urlMatcherFactory.compile(what)), !handlerIsString && !isFunction(handler) && !isArray(handler)) throw new Error("invalid 'handler' in when()");
            var strategies = {
                matcher: function(what, handler) {
                    return handlerIsString && (redirect = $urlMatcherFactory.compile(handler), handler = [ "$match", function($match) {
                        return redirect.format($match);
                    } ]), extend(function($injector, $location) {
                        return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
                    }, {
                        prefix: isString(what.prefix) ? what.prefix : ""
                    });
                },
                regex: function(what, handler) {
                    if (what.global || what.sticky) throw new Error("when() RegExp must not be global or sticky");
                    return handlerIsString && (redirect = handler, handler = [ "$match", function($match) {
                        return interpolate(redirect, $match);
                    } ]), extend(function($injector, $location) {
                        return handleIfMatch($injector, handler, what.exec($location.path()));
                    }, {
                        prefix: regExpPrefix(what)
                    });
                }
            }, check = {
                matcher: $urlMatcherFactory.isMatcher(what),
                regex: what instanceof RegExp
            };
            for (var n in check) if (check[n]) return this.rule(strategies[n](what, handler));
            throw new Error("invalid 'what' in when()");
        }, this.deferIntercept = function(defer) {
            defer === undefined && (defer = !0), interceptDeferred = defer;
        }, this.$get = $get, $get.$inject = [ "$location", "$rootScope", "$injector", "$browser" ];
    }
    function $StateProvider($urlRouterProvider, $urlMatcherFactory) {
        function isRelative(stateName) {
            return 0 === stateName.indexOf(".") || 0 === stateName.indexOf("^");
        }
        function findState(stateOrName, base) {
            if (!stateOrName) return undefined;
            var isStr = isString(stateOrName), name = isStr ? stateOrName : stateOrName.name, path = isRelative(name);
            if (path) {
                if (!base) throw new Error("No reference point given for path '" + name + "'");
                base = findState(base);
                for (var rel = name.split("."), i = 0, pathLength = rel.length, current = base; pathLength > i; i++) if ("" !== rel[i] || 0 !== i) {
                    if ("^" !== rel[i]) break;
                    if (!current.parent) throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
                    current = current.parent;
                } else current = base;
                rel = rel.slice(i).join("."), name = current.name + (current.name && rel ? "." : "") + rel;
            }
            var state = states[name];
            return !state || !isStr && (isStr || state !== stateOrName && state.self !== stateOrName) ? undefined : state;
        }
        function queueState(parentName, state) {
            queue[parentName] || (queue[parentName] = []), queue[parentName].push(state);
        }
        function flushQueuedChildren(parentName) {
            for (var queued = queue[parentName] || []; queued.length; ) registerState(queued.shift());
        }
        function registerState(state) {
            state = inherit(state, {
                self: state,
                resolve: state.resolve || {},
                toString: function() {
                    return this.name;
                }
            });
            var name = state.name;
            if (!isString(name) || name.indexOf("@") >= 0) throw new Error("State must have a valid name");
            if (states.hasOwnProperty(name)) throw new Error("State '" + name + "'' is already defined");
            var parentName = -1 !== name.indexOf(".") ? name.substring(0, name.lastIndexOf(".")) : isString(state.parent) ? state.parent : isObject(state.parent) && isString(state.parent.name) ? state.parent.name : "";
            if (parentName && !states[parentName]) return queueState(parentName, state.self);
            for (var key in stateBuilder) isFunction(stateBuilder[key]) && (state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]));
            return states[name] = state, !state[abstractKey] && state.url && $urlRouterProvider.when(state.url, [ "$match", "$stateParams", function($match, $stateParams) {
                $state.$current.navigable == state && equalForKeys($match, $stateParams) || $state.transitionTo(state, $match, {
                    inherit: !0,
                    location: !1
                });
            } ]), flushQueuedChildren(name), state;
        }
        function isGlob(text) {
            return text.indexOf("*") > -1;
        }
        function doesStateMatchGlob(glob) {
            var globSegments = glob.split("."), segments = $state.$current.name.split(".");
            if ("**" === globSegments[0] && (segments = segments.slice(indexOf(segments, globSegments[1])), 
            segments.unshift("**")), "**" === globSegments[globSegments.length - 1] && (segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE), 
            segments.push("**")), globSegments.length != segments.length) return !1;
            for (var i = 0, l = globSegments.length; l > i; i++) "*" === globSegments[i] && (segments[i] = "*");
            return segments.join("") === globSegments.join("");
        }
        function decorator(name, func) {
            return isString(name) && !isDefined(func) ? stateBuilder[name] : isFunction(func) && isString(name) ? (stateBuilder[name] && !stateBuilder.$delegates[name] && (stateBuilder.$delegates[name] = stateBuilder[name]), 
            stateBuilder[name] = func, this) : this;
        }
        function state(name, definition) {
            return isObject(name) ? definition = name : definition.name = name, registerState(definition), 
            this;
        }
        function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $urlRouter, $location, $urlMatcherFactory) {
            function handleRedirect(redirect, state, params, options) {
                var evt = $rootScope.$broadcast("$stateNotFound", redirect, state, params);
                if (evt.defaultPrevented) return $urlRouter.update(), TransitionAborted;
                if (!evt.retry) return null;
                if (options.$retry) return $urlRouter.update(), TransitionFailed;
                var retryTransition = $state.transition = $q.when(evt.retry);
                return retryTransition.then(function() {
                    return retryTransition !== $state.transition ? TransitionSuperseded : (redirect.options.$retry = !0, 
                    $state.transitionTo(redirect.to, redirect.toParams, redirect.options));
                }, function() {
                    return TransitionAborted;
                }), $urlRouter.update(), retryTransition;
            }
            function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
                var $stateParams = paramsAreFiltered ? params : filterByKeys(state.params.$$keys(), params), locals = {
                    $stateParams: $stateParams
                };
                dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
                var promises = [ dst.resolve.then(function(globals) {
                    dst.globals = globals;
                }) ];
                return inherited && promises.push(inherited), forEach(state.views, function(view, name) {
                    var injectables = view.resolve && view.resolve !== state.resolve ? view.resolve : {};
                    injectables.$template = [ function() {
                        return $view.load(name, {
                            view: view,
                            locals: locals,
                            params: $stateParams,
                            notify: options.notify
                        }) || "";
                    } ], promises.push($resolve.resolve(injectables, locals, dst.resolve, state).then(function(result) {
                        if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
                            var injectLocals = angular.extend({}, injectables, locals);
                            result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
                        } else result.$$controller = view.controller;
                        result.$$state = state, result.$$controllerAs = view.controllerAs, dst[name] = result;
                    }));
                }), $q.all(promises).then(function(values) {
                    return dst;
                });
            }
            var TransitionSuperseded = $q.reject(new Error("transition superseded")), TransitionPrevented = $q.reject(new Error("transition prevented")), TransitionAborted = $q.reject(new Error("transition aborted")), TransitionFailed = $q.reject(new Error("transition failed"));
            return root.locals = {
                resolve: null,
                globals: {
                    $stateParams: {}
                }
            }, $state = {
                params: {},
                current: root.self,
                $current: root,
                transition: null
            }, $state.reload = function() {
                return $state.transitionTo($state.current, $stateParams, {
                    reload: !0,
                    inherit: !1,
                    notify: !0
                });
            }, $state.go = function(to, params, options) {
                return $state.transitionTo(to, params, extend({
                    inherit: !0,
                    relative: $state.$current
                }, options));
            }, $state.transitionTo = function(to, toParams, options) {
                toParams = toParams || {}, options = extend({
                    location: !0,
                    inherit: !1,
                    relative: null,
                    notify: !0,
                    reload: !1,
                    $retry: !1
                }, options || {});
                var evt, from = $state.$current, fromParams = $state.params, fromPath = from.path, toState = findState(to, options.relative);
                if (!isDefined(toState)) {
                    var redirect = {
                        to: to,
                        toParams: toParams,
                        options: options
                    }, redirectResult = handleRedirect(redirect, from.self, fromParams, options);
                    if (redirectResult) return redirectResult;
                    if (to = redirect.to, toParams = redirect.toParams, options = redirect.options, 
                    toState = findState(to, options.relative), !isDefined(toState)) {
                        if (!options.relative) throw new Error("No such state '" + to + "'");
                        throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
                    }
                }
                if (toState[abstractKey]) throw new Error("Cannot transition to abstract state '" + to + "'");
                if (options.inherit && (toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState)), 
                !toState.params.$$validates(toParams)) return TransitionFailed;
                toParams = toState.params.$$values(toParams), to = toState;
                var toPath = to.path, keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];
                if (!options.reload) for (;state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams); ) locals = toLocals[keep] = state.locals, 
                keep++, state = toPath[keep];
                if (shouldTriggerReload(to, from, locals, options)) return to.self.reloadOnSearch !== !1 && $urlRouter.update(), 
                $state.transition = null, $q.when($state.current);
                if (toParams = filterByKeys(to.params.$$keys(), toParams || {}), options.notify && $rootScope.$broadcast("$stateChangeStart", to.self, toParams, from.self, fromParams).defaultPrevented) return $urlRouter.update(), 
                TransitionPrevented;
                for (var resolved = $q.when(locals), l = keep; l < toPath.length; l++, state = toPath[l]) locals = toLocals[l] = inherit(locals), 
                resolved = resolveState(state, toParams, state === to, resolved, locals, options);
                var transition = $state.transition = resolved.then(function() {
                    var l, entering, exiting;
                    if ($state.transition !== transition) return TransitionSuperseded;
                    for (l = fromPath.length - 1; l >= keep; l--) exiting = fromPath[l], exiting.self.onExit && $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals), 
                    exiting.locals = null;
                    for (l = keep; l < toPath.length; l++) entering = toPath[l], entering.locals = toLocals[l], 
                    entering.self.onEnter && $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
                    return $state.transition !== transition ? TransitionSuperseded : ($state.$current = to, 
                    $state.current = to.self, $state.params = toParams, copy($state.params, $stateParams), 
                    $state.transition = null, options.location && to.navigable && $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
                        $$avoidResync: !0,
                        replace: "replace" === options.location
                    }), options.notify && $rootScope.$broadcast("$stateChangeSuccess", to.self, toParams, from.self, fromParams), 
                    $urlRouter.update(!0), $state.current);
                }, function(error) {
                    return $state.transition !== transition ? TransitionSuperseded : ($state.transition = null, 
                    evt = $rootScope.$broadcast("$stateChangeError", to.self, toParams, from.self, fromParams, error), 
                    evt.defaultPrevented || $urlRouter.update(), $q.reject(error));
                });
                return transition;
            }, $state.is = function(stateOrName, params, options) {
                options = extend({
                    relative: $state.$current
                }, options || {});
                var state = findState(stateOrName, options.relative);
                return isDefined(state) ? $state.$current !== state ? !1 : params ? equalForKeys(state.params.$$values(params), $stateParams) : !0 : undefined;
            }, $state.includes = function(stateOrName, params, options) {
                if (options = extend({
                    relative: $state.$current
                }, options || {}), isString(stateOrName) && isGlob(stateOrName)) {
                    if (!doesStateMatchGlob(stateOrName)) return !1;
                    stateOrName = $state.$current.name;
                }
                var state = findState(stateOrName, options.relative);
                return isDefined(state) ? isDefined($state.$current.includes[state.name]) ? params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : !0 : !1 : undefined;
            }, $state.href = function(stateOrName, params, options) {
                options = extend({
                    lossy: !0,
                    inherit: !0,
                    absolute: !1,
                    relative: $state.$current
                }, options || {});
                var state = findState(stateOrName, options.relative);
                if (!isDefined(state)) return null;
                options.inherit && (params = inheritParams($stateParams, params || {}, $state.$current, state));
                var nav = state && options.lossy ? state.navigable : state;
                return nav && nav.url !== undefined && null !== nav.url ? $urlRouter.href(nav.url, filterByKeys(state.params.$$keys(), params || {}), {
                    absolute: options.absolute
                }) : null;
            }, $state.get = function(stateOrName, context) {
                if (0 === arguments.length) return map(objectKeys(states), function(name) {
                    return states[name].self;
                });
                var state = findState(stateOrName, context || $state.$current);
                return state && state.self ? state.self : null;
            }, $state;
        }
        function shouldTriggerReload(to, from, locals, options) {
            return to !== from || (locals !== from.locals || options.reload) && to.self.reloadOnSearch !== !1 ? void 0 : !0;
        }
        var root, $state, states = {}, queue = {}, abstractKey = "abstract", stateBuilder = {
            parent: function(state) {
                if (isDefined(state.parent) && state.parent) return findState(state.parent);
                var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
                return compositeName ? findState(compositeName[1]) : root;
            },
            data: function(state) {
                return state.parent && state.parent.data && (state.data = state.self.data = extend({}, state.parent.data, state.data)), 
                state.data;
            },
            url: function(state) {
                var url = state.url, config = {
                    params: state.params || {}
                };
                if (isString(url)) return "^" == url.charAt(0) ? $urlMatcherFactory.compile(url.substring(1), config) : (state.parent.navigable || root).url.concat(url, config);
                if (!url || $urlMatcherFactory.isMatcher(url)) return url;
                throw new Error("Invalid url '" + url + "' in state '" + state + "'");
            },
            navigable: function(state) {
                return state.url ? state : state.parent ? state.parent.navigable : null;
            },
            ownParams: function(state) {
                var params = state.url && state.url.params || new $$UMFP.ParamSet();
                return forEach(state.params || {}, function(config, id) {
                    params[id] || (params[id] = new $$UMFP.Param(id, null, config, "config"));
                }), params;
            },
            params: function(state) {
                return state.parent && state.parent.params ? extend(state.parent.params.$$new(), state.ownParams) : new $$UMFP.ParamSet();
            },
            views: function(state) {
                var views = {};
                return forEach(isDefined(state.views) ? state.views : {
                    "": state
                }, function(view, name) {
                    name.indexOf("@") < 0 && (name += "@" + state.parent.name), views[name] = view;
                }), views;
            },
            path: function(state) {
                return state.parent ? state.parent.path.concat(state) : [];
            },
            includes: function(state) {
                var includes = state.parent ? extend({}, state.parent.includes) : {};
                return includes[state.name] = !0, includes;
            },
            $delegates: {}
        };
        root = registerState({
            name: "",
            url: "^",
            views: null,
            "abstract": !0
        }), root.navigable = null, this.decorator = decorator, this.state = state, this.$get = $get, 
        $get.$inject = [ "$rootScope", "$q", "$view", "$injector", "$resolve", "$stateParams", "$urlRouter", "$location", "$urlMatcherFactory" ];
    }
    function $ViewProvider() {
        function $get($rootScope, $templateFactory) {
            return {
                load: function(name, options) {
                    var result, defaults = {
                        template: null,
                        controller: null,
                        view: null,
                        locals: null,
                        notify: !0,
                        async: !0,
                        params: {}
                    };
                    return options = extend(defaults, options), options.view && (result = $templateFactory.fromConfig(options.view, options.params, options.locals)), 
                    result && options.notify && $rootScope.$broadcast("$viewContentLoading", options), 
                    result;
                }
            };
        }
        this.$get = $get, $get.$inject = [ "$rootScope", "$templateFactory" ];
    }
    function $ViewScrollProvider() {
        var useAnchorScroll = !1;
        this.useAnchorScroll = function() {
            useAnchorScroll = !0;
        }, this.$get = [ "$anchorScroll", "$timeout", function($anchorScroll, $timeout) {
            return useAnchorScroll ? $anchorScroll : function($element) {
                $timeout(function() {
                    $element[0].scrollIntoView();
                }, 0, !1);
            };
        } ];
    }
    function $ViewDirective($state, $injector, $uiViewScroll, $interpolate) {
        function getService() {
            return $injector.has ? function(service) {
                return $injector.has(service) ? $injector.get(service) : null;
            } : function(service) {
                try {
                    return $injector.get(service);
                } catch (e) {
                    return null;
                }
            };
        }
        function getRenderer(attrs, scope) {
            var statics = function() {
                return {
                    enter: function(element, target, cb) {
                        target.after(element), cb();
                    },
                    leave: function(element, cb) {
                        element.remove(), cb();
                    }
                };
            };
            if ($animate) return {
                enter: function(element, target, cb) {
                    var promise = $animate.enter(element, null, target, cb);
                    promise && promise.then && promise.then(cb);
                },
                leave: function(element, cb) {
                    var promise = $animate.leave(element, cb);
                    promise && promise.then && promise.then(cb);
                }
            };
            if ($animator) {
                var animate = $animator && $animator(scope, attrs);
                return {
                    enter: function(element, target, cb) {
                        animate.enter(element, null, target), cb();
                    },
                    leave: function(element, cb) {
                        animate.leave(element), cb();
                    }
                };
            }
            return statics();
        }
        var service = getService(), $animator = service("$animator"), $animate = service("$animate"), directive = {
            restrict: "ECA",
            terminal: !0,
            priority: 400,
            transclude: "element",
            compile: function(tElement, tAttrs, $transclude) {
                return function(scope, $element, attrs) {
                    function cleanupLastView() {
                        previousEl && (previousEl.remove(), previousEl = null), currentScope && (currentScope.$destroy(), 
                        currentScope = null), currentEl && (renderer.leave(currentEl, function() {
                            previousEl = null;
                        }), previousEl = currentEl, currentEl = null);
                    }
                    function updateView(firstTime) {
                        var newScope, name = getUiViewName(scope, attrs, $element, $interpolate), previousLocals = name && $state.$current && $state.$current.locals[name];
                        if (firstTime || previousLocals !== latestLocals) {
                            newScope = scope.$new(), latestLocals = $state.$current.locals[name];
                            var clone = $transclude(newScope, function(clone) {
                                renderer.enter(clone, $element, function() {
                                    currentScope && currentScope.$emit("$viewContentAnimationEnded"), (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) && $uiViewScroll(clone);
                                }), cleanupLastView();
                            });
                            currentEl = clone, currentScope = newScope, currentScope.$emit("$viewContentLoaded"), 
                            currentScope.$eval(onloadExp);
                        }
                    }
                    var previousEl, currentEl, currentScope, latestLocals, onloadExp = attrs.onload || "", autoScrollExp = attrs.autoscroll, renderer = getRenderer(attrs, scope);
                    scope.$on("$stateChangeSuccess", function() {
                        updateView(!1);
                    }), scope.$on("$viewContentLoading", function() {
                        updateView(!1);
                    }), updateView(!0);
                };
            }
        };
        return directive;
    }
    function $ViewDirectiveFill($compile, $controller, $state, $interpolate) {
        return {
            restrict: "ECA",
            priority: -400,
            compile: function(tElement) {
                var initial = tElement.html();
                return function(scope, $element, attrs) {
                    var current = $state.$current, name = getUiViewName(scope, attrs, $element, $interpolate), locals = current && current.locals[name];
                    if (locals) {
                        $element.data("$uiView", {
                            name: name,
                            state: locals.$$state
                        }), $element.html(locals.$template ? locals.$template : initial);
                        var link = $compile($element.contents());
                        if (locals.$$controller) {
                            locals.$scope = scope;
                            var controller = $controller(locals.$$controller, locals);
                            locals.$$controllerAs && (scope[locals.$$controllerAs] = controller), $element.data("$ngControllerController", controller), 
                            $element.children().data("$ngControllerController", controller);
                        }
                        link(scope);
                    }
                };
            }
        };
    }
    function getUiViewName(scope, attrs, element, $interpolate) {
        var name = $interpolate(attrs.uiView || attrs.name || "")(scope), inherited = element.inheritedData("$uiView");
        return name.indexOf("@") >= 0 ? name : name + "@" + (inherited ? inherited.state.name : "");
    }
    function parseStateRef(ref, current) {
        var parsed, preparsed = ref.match(/^\s*({[^}]*})\s*$/);
        if (preparsed && (ref = current + "(" + preparsed[1] + ")"), parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/), 
        !parsed || 4 !== parsed.length) throw new Error("Invalid state ref '" + ref + "'");
        return {
            state: parsed[1],
            paramExpr: parsed[3] || null
        };
    }
    function stateContext(el) {
        var stateData = el.parent().inheritedData("$uiView");
        return stateData && stateData.state && stateData.state.name ? stateData.state : void 0;
    }
    function $StateRefDirective($state, $timeout) {
        var allowedOptions = [ "location", "inherit", "reload" ];
        return {
            restrict: "A",
            require: [ "?^uiSrefActive", "?^uiSrefActiveEq" ],
            link: function(scope, element, attrs, uiSrefActive) {
                var ref = parseStateRef(attrs.uiSref, $state.current.name), params = null, base = stateContext(element) || $state.$current, newHref = null, isAnchor = "A" === element.prop("tagName"), isForm = "FORM" === element[0].nodeName, attr = isForm ? "action" : "href", nav = !0, options = {
                    relative: base,
                    inherit: !0
                }, optionsOverride = scope.$eval(attrs.uiSrefOpts) || {};
                angular.forEach(allowedOptions, function(option) {
                    option in optionsOverride && (options[option] = optionsOverride[option]);
                });
                var update = function(newVal) {
                    if (newVal && (params = angular.copy(newVal)), nav) {
                        newHref = $state.href(ref.state, params, options);
                        var activeDirective = uiSrefActive[1] || uiSrefActive[0];
                        return activeDirective && activeDirective.$$setStateInfo(ref.state, params), null === newHref ? (nav = !1, 
                        !1) : void attrs.$set(attr, newHref);
                    }
                };
                ref.paramExpr && (scope.$watch(ref.paramExpr, function(newVal, oldVal) {
                    newVal !== params && update(newVal);
                }, !0), params = angular.copy(scope.$eval(ref.paramExpr))), update(), isForm || element.bind("click", function(e) {
                    var button = e.which || e.button;
                    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr("target"))) {
                        var transition = $timeout(function() {
                            $state.go(ref.state, params, options);
                        });
                        e.preventDefault();
                        var ignorePreventDefaultCount = isAnchor && !newHref ? 1 : 0;
                        e.preventDefault = function() {
                            ignorePreventDefaultCount-- <= 0 && $timeout.cancel(transition);
                        };
                    }
                });
            }
        };
    }
    function $StateRefActiveDirective($state, $stateParams, $interpolate) {
        return {
            restrict: "A",
            controller: [ "$scope", "$element", "$attrs", function($scope, $element, $attrs) {
                function update() {
                    isMatch() ? $element.addClass(activeClass) : $element.removeClass(activeClass);
                }
                function isMatch() {
                    return "undefined" != typeof $attrs.uiSrefActiveEq ? state && $state.is(state.name, params) : state && $state.includes(state.name, params);
                }
                var state, params, activeClass;
                activeClass = $interpolate($attrs.uiSrefActiveEq || $attrs.uiSrefActive || "", !1)($scope), 
                this.$$setStateInfo = function(newState, newParams) {
                    state = $state.get(newState, stateContext($element)), params = newParams, update();
                }, $scope.$on("$stateChangeSuccess", update);
            } ]
        };
    }
    function $IsStateFilter($state) {
        var isFilter = function(state) {
            return $state.is(state);
        };
        return isFilter.$stateful = !0, isFilter;
    }
    function $IncludedByStateFilter($state) {
        var includesFilter = function(state) {
            return $state.includes(state);
        };
        return includesFilter.$stateful = !0, includesFilter;
    }
    var isDefined = angular.isDefined, isFunction = angular.isFunction, isString = angular.isString, isObject = angular.isObject, isArray = angular.isArray, forEach = angular.forEach, extend = angular.extend, copy = angular.copy;
    angular.module("ui.router.util", [ "ng" ]), angular.module("ui.router.router", [ "ui.router.util" ]), 
    angular.module("ui.router.state", [ "ui.router.router", "ui.router.util" ]), angular.module("ui.router", [ "ui.router.state" ]), 
    angular.module("ui.router.compat", [ "ui.router" ]), $Resolve.$inject = [ "$q", "$injector" ], 
    angular.module("ui.router.util").service("$resolve", $Resolve), $TemplateFactory.$inject = [ "$http", "$templateCache", "$injector" ], 
    angular.module("ui.router.util").service("$templateFactory", $TemplateFactory);
    var $$UMFP;
    UrlMatcher.prototype.concat = function(pattern, config) {
        var defaultConfig = {
            caseInsensitive: $$UMFP.caseInsensitive(),
            strict: $$UMFP.strictMode(),
            squash: $$UMFP.defaultSquashPolicy()
        };
        return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
    }, UrlMatcher.prototype.toString = function() {
        return this.source;
    }, UrlMatcher.prototype.exec = function(path, searchParams) {
        function decodePathArray(string) {
            function reverseString(str) {
                return str.split("").reverse().join("");
            }
            function unquoteDashes(str) {
                return str.replace(/\\-/, "-");
            }
            var split = reverseString(string).split(/-(?!\\)/), allReversed = map(split, reverseString);
            return map(allReversed, unquoteDashes).reverse();
        }
        var m = this.regexp.exec(path);
        if (!m) return null;
        searchParams = searchParams || {};
        var i, j, paramName, paramNames = this.parameters(), nTotal = paramNames.length, nPath = this.segments.length - 1, values = {};
        if (nPath !== m.length - 1) throw new Error("Unbalanced capture group in route '" + this.source + "'");
        for (i = 0; nPath > i; i++) {
            paramName = paramNames[i];
            var param = this.params[paramName], paramVal = m[i + 1];
            for (j = 0; j < param.replace; j++) param.replace[j].from === paramVal && (paramVal = param.replace[j].to);
            paramVal && param.array === !0 && (paramVal = decodePathArray(paramVal)), values[paramName] = param.value(paramVal);
        }
        for (;nTotal > i; i++) paramName = paramNames[i], values[paramName] = this.params[paramName].value(searchParams[paramName]);
        return values;
    }, UrlMatcher.prototype.parameters = function(param) {
        return isDefined(param) ? this.params[param] || null : this.$$paramNames;
    }, UrlMatcher.prototype.validates = function(params) {
        return this.params.$$validates(params);
    }, UrlMatcher.prototype.format = function(values) {
        function encodeDashes(str) {
            return encodeURIComponent(str).replace(/-/g, function(c) {
                return "%5C%" + c.charCodeAt(0).toString(16).toUpperCase();
            });
        }
        values = values || {};
        var segments = this.segments, params = this.parameters(), paramset = this.params;
        if (!this.validates(values)) return null;
        var i, search = !1, nPath = segments.length - 1, nTotal = params.length, result = segments[0];
        for (i = 0; nTotal > i; i++) {
            var isPathParam = nPath > i, name = params[i], param = paramset[name], value = param.value(values[name]), isDefaultValue = param.isOptional && param.type.equals(param.value(), value), squash = isDefaultValue ? param.squash : !1, encoded = param.type.encode(value);
            if (isPathParam) {
                var nextSegment = segments[i + 1];
                if (squash === !1) null != encoded && (result += isArray(encoded) ? map(encoded, encodeDashes).join("-") : encodeURIComponent(encoded)), 
                result += nextSegment; else if (squash === !0) {
                    var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
                    result += nextSegment.match(capture)[1];
                } else isString(squash) && (result += squash + nextSegment);
            } else {
                if (null == encoded || isDefaultValue && squash !== !1) continue;
                isArray(encoded) || (encoded = [ encoded ]), encoded = map(encoded, encodeURIComponent).join("&" + name + "="), 
                result += (search ? "&" : "?") + (name + "=" + encoded), search = !0;
            }
        }
        return result;
    }, Type.prototype.is = function(val, key) {
        return !0;
    }, Type.prototype.encode = function(val, key) {
        return val;
    }, Type.prototype.decode = function(val, key) {
        return val;
    }, Type.prototype.equals = function(a, b) {
        return a == b;
    }, Type.prototype.$subPattern = function() {
        var sub = this.pattern.toString();
        return sub.substr(1, sub.length - 2);
    }, Type.prototype.pattern = /.*/, Type.prototype.toString = function() {
        return "{Type:" + this.name + "}";
    }, Type.prototype.$asArray = function(mode, isSearch) {
        function ArrayType(type, mode) {
            function bindTo(type, callbackName) {
                return function() {
                    return type[callbackName].apply(type, arguments);
                };
            }
            function arrayWrap(val) {
                return isArray(val) ? val : isDefined(val) ? [ val ] : [];
            }
            function arrayUnwrap(val) {
                switch (val.length) {
                  case 0:
                    return undefined;

                  case 1:
                    return "auto" === mode ? val[0] : val;

                  default:
                    return val;
                }
            }
            function falsey(val) {
                return !val;
            }
            function arrayHandler(callback, allTruthyMode) {
                return function(val) {
                    val = arrayWrap(val);
                    var result = map(val, callback);
                    return allTruthyMode === !0 ? 0 === filter(result, falsey).length : arrayUnwrap(result);
                };
            }
            function arrayEqualsHandler(callback) {
                return function(val1, val2) {
                    var left = arrayWrap(val1), right = arrayWrap(val2);
                    if (left.length !== right.length) return !1;
                    for (var i = 0; i < left.length; i++) if (!callback(left[i], right[i])) return !1;
                    return !0;
                };
            }
            this.encode = arrayHandler(bindTo(type, "encode")), this.decode = arrayHandler(bindTo(type, "decode")), 
            this.is = arrayHandler(bindTo(type, "is"), !0), this.equals = arrayEqualsHandler(bindTo(type, "equals")), 
            this.pattern = type.pattern, this.$arrayMode = mode;
        }
        if (!mode) return this;
        if ("auto" === mode && !isSearch) throw new Error("'auto' array mode is for query parameters only");
        return new ArrayType(this, mode);
    }, angular.module("ui.router.util").provider("$urlMatcherFactory", $UrlMatcherFactory), 
    angular.module("ui.router.util").run([ "$urlMatcherFactory", function($urlMatcherFactory) {} ]), 
    $UrlRouterProvider.$inject = [ "$locationProvider", "$urlMatcherFactoryProvider" ], 
    angular.module("ui.router.router").provider("$urlRouter", $UrlRouterProvider), $StateProvider.$inject = [ "$urlRouterProvider", "$urlMatcherFactoryProvider" ], 
    angular.module("ui.router.state").value("$stateParams", {}).provider("$state", $StateProvider), 
    $ViewProvider.$inject = [], angular.module("ui.router.state").provider("$view", $ViewProvider), 
    angular.module("ui.router.state").provider("$uiViewScroll", $ViewScrollProvider), 
    $ViewDirective.$inject = [ "$state", "$injector", "$uiViewScroll", "$interpolate" ], 
    $ViewDirectiveFill.$inject = [ "$compile", "$controller", "$state", "$interpolate" ], 
    angular.module("ui.router.state").directive("uiView", $ViewDirective), angular.module("ui.router.state").directive("uiView", $ViewDirectiveFill), 
    $StateRefDirective.$inject = [ "$state", "$timeout" ], $StateRefActiveDirective.$inject = [ "$state", "$stateParams", "$interpolate" ], 
    angular.module("ui.router.state").directive("uiSref", $StateRefDirective).directive("uiSrefActive", $StateRefActiveDirective).directive("uiSrefActiveEq", $StateRefActiveDirective), 
    $IsStateFilter.$inject = [ "$state" ], $IncludedByStateFilter.$inject = [ "$state" ], 
    angular.module("ui.router.state").filter("isState", $IsStateFilter).filter("includedByState", $IncludedByStateFilter);
}(window, window.angular), function() {
    function CollectionRepeatDirective($ionicCollectionManager, $parse, $window, $$rAF, $rootScope, $timeout) {
        function postLink(scope, element, attr, scrollCtrl, transclude) {
            function onResize() {
                changeValidator.resizeRequiresRefresh(scrollView.__clientWidth, scrollView.__clientHeight) && refreshDimensions();
            }
            function makeChangeValidator() {
                var self;
                return self = {
                    dataLength: 0,
                    width: 0,
                    height: 0,
                    resizeRequiresRefresh: function(newWidth, newHeight) {
                        var requiresRefresh = self.dataLength && newWidth && newHeight && (newWidth !== self.width || newHeight !== self.height);
                        return self.width = newWidth, self.height = newHeight, !!requiresRefresh;
                    },
                    dataChangeRequiresRefresh: function(newData) {
                        var requiresRefresh = newData.length > 0 || newData.length < self.dataLength;
                        return self.dataLength = newData.length, !!requiresRefresh;
                    }
                };
            }
            function getRepeatManager() {
                return repeatManager || (repeatManager = new $ionicCollectionManager({
                    afterItemsNode: afterItemsContainer[0],
                    containerNode: containerNode,
                    heightData: heightData,
                    widthData: widthData,
                    forceRefreshImages: !(!isDefined(attr.forceRefreshImages) || "false" === attr.forceRefreshImages),
                    keyExpression: keyExpr,
                    renderBuffer: renderBuffer,
                    scope: scope,
                    scrollView: scrollCtrl.scrollView,
                    transclude: transclude
                }));
            }
            function initAfterItemsContainer() {
                var container = angular.element(scrollView.__content.querySelector(".collection-repeat-after-container"));
                if (!container.length) {
                    var elementIsAfterRepeater = !1, afterNodes = [].filter.call(scrollView.__content.childNodes, function(node) {
                        return ionic.DomUtil.contains(node, containerNode) ? (elementIsAfterRepeater = !0, 
                        !1) : elementIsAfterRepeater;
                    });
                    container = angular.element('<span class="collection-repeat-after-container">'), 
                    scrollView.options.scrollingX && container.addClass("horizontal"), container.append(afterNodes), 
                    scrollView.__content.appendChild(container[0]);
                }
                return container;
            }
            function initDimensions() {
                heightExpr ? parseDimensionAttr(heightExpr, heightData) : heightData.computed = !0, 
                widthExpr ? parseDimensionAttr(widthExpr, widthData) : widthData.computed = !0;
            }
            function refreshDimensions() {
                var hasData = data.length > 0;
                if (hasData && (heightData.computed || widthData.computed) && computeStyleDimensions(), 
                hasData && heightData.computed) {
                    if (heightData.value = computedStyleDimensions.height, !heightData.value) throw new Error('collection-repeat tried to compute the height of repeated elements "' + repeatExpr + '", but was unable to. Please provide the "item-height" attribute. http://ionicframework.com/docs/api/directive/collectionRepeat/');
                } else !heightData.dynamic && heightData.getValue && (heightData.value = heightData.getValue());
                if (hasData && widthData.computed) {
                    if (widthData.value = computedStyleDimensions.width, !widthData.value) throw new Error('collection-repeat tried to compute the width of repeated elements "' + repeatExpr + '", but was unable to. Please provide the "item-width" attribute. http://ionicframework.com/docs/api/directive/collectionRepeat/');
                } else !widthData.dynamic && widthData.getValue && (widthData.value = widthData.getValue());
                getRepeatManager().refreshLayout();
            }
            function parseDimensionAttr(attrValue, dimensionData) {
                if (attrValue) {
                    var parsedValue;
                    try {
                        parsedValue = $parse(attrValue);
                    } catch (e) {
                        attrValue.trim().match(/\d+(px|%)$/) && (attrValue = '"' + attrValue + '"'), parsedValue = $parse(attrValue);
                    }
                    var constantAttrValue = attrValue.replace(/(\'|\"|px|%)/g, "").trim(), isConstant = constantAttrValue.length && !/([a-zA-Z]|\$|:|\?)/.test(constantAttrValue);
                    if (dimensionData.attrValue = attrValue, isConstant) if (attrValue.indexOf("%") > -1) {
                        var decimalValue = parseFloat(parsedValue()) / 100;
                        dimensionData.getValue = dimensionData === heightData ? function() {
                            return Math.floor(decimalValue * scrollView.__clientHeight);
                        } : function() {
                            return Math.floor(decimalValue * scrollView.__clientWidth);
                        };
                    } else dimensionData.value = parseInt(parsedValue()); else dimensionData.dynamic = !0, 
                    dimensionData.getValue = dimensionData === heightData ? function(scope, locals) {
                        var result = parsedValue(scope, locals);
                        return result.charAt && "%" === result.charAt(result.length - 1) ? Math.floor(parseFloat(result) / 100 * scrollView.__clientHeight) : parseInt(result);
                    } : function(scope, locals) {
                        var result = parsedValue(scope, locals);
                        return result.charAt && "%" === result.charAt(result.length - 1) ? Math.floor(parseFloat(result) / 100 * scrollView.__clientWidth) : parseInt(result);
                    };
                }
            }
            function computeStyleDimensions() {
                computedStyleNode || transclude(computedStyleScope = scope.$new(), function(clone) {
                    clone[0].removeAttribute("collection-repeat"), computedStyleNode = clone[0];
                }), computedStyleScope[keyExpr] = (listGetter(scope) || [])[0], $rootScope.$$phase || computedStyleScope.$digest(), 
                containerNode.appendChild(computedStyleNode);
                var style = $window.getComputedStyle(computedStyleNode);
                computedStyleDimensions.width = parseInt(style.width), computedStyleDimensions.height = parseInt(style.height), 
                containerNode.removeChild(computedStyleNode);
            }
            var scrollView = scrollCtrl.scrollView, node = element[0], containerNode = angular.element('<div class="collection-repeat-container">')[0];
            if (node.parentNode.replaceChild(containerNode, node), scrollView.options.scrollingX && scrollView.options.scrollingY) throw new Error("collection-repeat expected a parent x or y scrollView, not an xy scrollView.");
            var repeatExpr = attr.collectionRepeat, match = repeatExpr.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
            if (!match) throw new Error("collection-repeat expected expression in form of '_item_ in _collection_[ track by _id_]' but got '" + attr.collectionRepeat + "'.");
            var repeatManager, keyExpr = match[1], listExpr = match[2], listGetter = $parse(listExpr), heightData = {}, widthData = {}, computedStyleDimensions = {}, data = [], renderBufferExpr = attr.itemRenderBuffer || attr.collectionBufferSize, renderBuffer = angular.isDefined(renderBufferExpr) ? parseInt(renderBufferExpr) : DEFAULT_RENDER_BUFFER, heightExpr = attr.itemHeight || attr.collectionItemHeight, widthExpr = attr.itemWidth || attr.collectionItemWidth, afterItemsContainer = initAfterItemsContainer(), changeValidator = makeChangeValidator();
            initDimensions(), scrollCtrl.$element.on("scroll-resize", refreshDimensions), angular.element($window).on("resize", onResize);
            var unlistenToExposeAside = $rootScope.$on("$ionicExposeAside", ionic.animationFrameThrottle(function() {
                scrollCtrl.scrollView.resize(), onResize();
            }));
            $timeout(refreshDimensions, 0, !1), scope.$watchCollection(listGetter, function(newValue) {
                if (data = newValue || (newValue = []), !angular.isArray(newValue)) throw new Error("collection-repeat expected an array for '" + listExpr + "', but got a " + typeof value);
                scope.$$postDigest(function() {
                    getRepeatManager().setData(data), changeValidator.dataChangeRequiresRefresh(data) && refreshDimensions();
                });
            }), scope.$on("$destroy", function() {
                angular.element($window).off("resize", onResize), unlistenToExposeAside(), scrollCtrl.$element && scrollCtrl.$element.off("scroll-resize", refreshDimensions), 
                computedStyleNode && computedStyleNode.parentNode && computedStyleNode.parentNode.removeChild(computedStyleNode), 
                computedStyleScope && computedStyleScope.$destroy(), computedStyleScope = computedStyleNode = null, 
                repeatManager && repeatManager.destroy(), repeatManager = null;
            });
            var computedStyleNode, computedStyleScope;
        }
        return {
            restrict: "A",
            priority: 1e3,
            transclude: "element",
            $$tlb: !0,
            require: "^^$ionicScroll",
            link: postLink
        };
    }
    function RepeatManagerFactory($rootScope, $window, $$rAF) {
        var EMPTY_DIMENSION = {
            primaryPos: 0,
            secondaryPos: 0,
            primarySize: 0,
            secondarySize: 0,
            rowPrimarySize: 0
        };
        return function(options) {
            function forceRerender() {
                return render(!0);
            }
            function render(forceRerender) {
                if (!render.destroyed) {
                    var i, ii, item, dim, scope, scrollValue = view.getScrollValue(), scrollValueEnd = scrollValue + view.scrollPrimarySize;
                    view.updateRenderRange(scrollValue, scrollValueEnd), renderStartIndex = Math.max(0, renderStartIndex - renderBuffer), 
                    renderEndIndex = Math.min(data.length - 1, renderEndIndex + renderBuffer);
                    for (i in itemsShownMap) (renderStartIndex > i || i > renderEndIndex) && (item = itemsShownMap[i], 
                    delete itemsShownMap[i], itemsLeaving.push(item), item.isShown = !1);
                    for (i = renderStartIndex; renderEndIndex >= i; i++) i >= data.length || itemsShownMap[i] && !forceRerender || (item = itemsShownMap[i] || (itemsShownMap[i] = itemsLeaving.length ? itemsLeaving.pop() : itemsPool.length ? itemsPool.shift() : new RepeatItem()), 
                    itemsEntering.push(item), item.isShown = !0, scope = item.scope, scope.$index = i, 
                    scope[keyExpression] = data[i], scope.$first = 0 === i, scope.$last = i === data.length - 1, 
                    scope.$middle = !(scope.$first || scope.$last), scope.$odd = !(scope.$even = 0 === (1 & i)), 
                    scope.$$disconnected && ionic.Utils.reconnectScope(item.scope), dim = view.getDimensions(i), 
                    (item.secondaryPos !== dim.secondaryPos || item.primaryPos !== dim.primaryPos) && (item.node.style[ionic.CSS.TRANSFORM] = TRANSLATE_TEMPLATE_STR.replace(PRIMARY, item.primaryPos = dim.primaryPos).replace(SECONDARY, item.secondaryPos = dim.secondaryPos)), 
                    (item.secondarySize !== dim.secondarySize || item.primarySize !== dim.primarySize) && (item.node.style.cssText = item.node.style.cssText.replace(WIDTH_HEIGHT_REGEX, WIDTH_HEIGHT_TEMPLATE_STR.replace(PRIMARY, (item.primarySize = dim.primarySize) + 1).replace(SECONDARY, item.secondarySize = dim.secondarySize))));
                    for (renderEndIndex === data.length - 1 && (dim = view.getDimensions(data.length - 1) || EMPTY_DIMENSION, 
                    afterItemsNode.style[ionic.CSS.TRANSFORM] = TRANSLATE_TEMPLATE_STR.replace(PRIMARY, dim.primaryPos + dim.primarySize).replace(SECONDARY, 0)); itemsLeaving.length; ) item = itemsLeaving.pop(), 
                    item.scope.$broadcast("$collectionRepeatLeave"), ionic.Utils.disconnectScope(item.scope), 
                    itemsPool.push(item), item.node.style[ionic.CSS.TRANSFORM] = "translate3d(-9999px,-9999px,0)", 
                    item.primaryPos = item.secondaryPos = null;
                    if (forceRefreshImages) for (i = 0, ii = itemsEntering.length; ii > i && (item = itemsEntering[i]); i++) if (item.images) for (var img, j = 0, jj = item.images.length; jj > j && (img = item.images[j]); j++) {
                        var src = img.src;
                        img.src = ONE_PX_TRANSPARENT_IMG_SRC, img.src = src;
                    }
                    if (forceRerender) for (var rootScopePhase = $rootScope.$$phase; itemsEntering.length; ) item = itemsEntering.pop(), 
                    rootScopePhase || item.scope.$digest(); else digestEnteringItems();
                }
            }
            function digestEnteringItems() {
                var item;
                digestEnteringItems.running || (digestEnteringItems.running = !0, $$rAF(function() {
                    for (var rootScopePhase = $rootScope.$$phase; itemsEntering.length; ) item = itemsEntering.pop(), 
                    item.isShown && (rootScopePhase || item.scope.$digest());
                    digestEnteringItems.running = !1;
                }));
            }
            function RepeatItem() {
                var self = this;
                this.scope = scope.$new(), this.id = "item" + nextItemId++, transclude(this.scope, function(clone) {
                    self.element = clone, self.element.data("$$collectionRepeatItem", self), self.node = clone[0], 
                    self.node.style[ionic.CSS.TRANSFORM] = "translate3d(-9999px,-9999px,0)", self.node.style.cssText += " height: 0px; width: 0px;", 
                    ionic.Utils.disconnectScope(self.scope), containerNode.appendChild(self.node), self.images = clone[0].getElementsByTagName("img");
                });
            }
            function VerticalViewType() {
                this.getItemPrimarySize = heightGetter, this.getItemSecondarySize = widthGetter, 
                this.getScrollValue = function() {
                    return Math.max(0, Math.min(scrollView.__scrollTop - repeaterBeforeSize, scrollView.__maxScrollTop - repeaterBeforeSize - repeaterAfterSize));
                }, this.refreshDirection = function() {
                    this.scrollPrimarySize = scrollView.__clientHeight, this.scrollSecondarySize = scrollView.__clientWidth, 
                    this.estimatedPrimarySize = estimatedHeight, this.estimatedSecondarySize = estimatedWidth, 
                    this.estimatedItemsAcross = isGridView && Math.floor(scrollView.__clientWidth / estimatedWidth) || 1;
                };
            }
            function HorizontalViewType() {
                this.getItemPrimarySize = widthGetter, this.getItemSecondarySize = heightGetter, 
                this.getScrollValue = function() {
                    return Math.max(0, Math.min(scrollView.__scrollLeft - repeaterBeforeSize, scrollView.__maxScrollLeft - repeaterBeforeSize - repeaterAfterSize));
                }, this.refreshDirection = function() {
                    this.scrollPrimarySize = scrollView.__clientWidth, this.scrollSecondarySize = scrollView.__clientHeight, 
                    this.estimatedPrimarySize = estimatedWidth, this.estimatedSecondarySize = estimatedHeight, 
                    this.estimatedItemsAcross = isGridView && Math.floor(scrollView.__clientHeight / estimatedHeight) || 1;
                };
            }
            function GridViewType() {
                this.getEstimatedSecondaryPos = function(index) {
                    return index % this.estimatedItemsAcross * this.estimatedSecondarySize;
                }, this.getEstimatedPrimaryPos = function(index) {
                    return Math.floor(index / this.estimatedItemsAcross) * this.estimatedPrimarySize;
                }, this.getEstimatedIndex = function(scrollValue) {
                    return Math.floor(scrollValue / this.estimatedPrimarySize) * this.estimatedItemsAcross;
                };
            }
            function ListViewType() {
                this.getEstimatedSecondaryPos = function() {
                    return 0;
                }, this.getEstimatedPrimaryPos = function(index) {
                    return index * this.estimatedPrimarySize;
                }, this.getEstimatedIndex = function(scrollValue) {
                    return Math.floor(scrollValue / this.estimatedPrimarySize);
                };
            }
            function StaticViewType() {
                this.getContentSize = function() {
                    return this.getEstimatedPrimaryPos(data.length - 1) + this.estimatedPrimarySize + repeaterBeforeSize + repeaterAfterSize;
                };
                var dim = {};
                this.getDimensions = function(index) {
                    return dim.primaryPos = this.getEstimatedPrimaryPos(index), dim.secondaryPos = this.getEstimatedSecondaryPos(index), 
                    dim.primarySize = this.estimatedPrimarySize, dim.secondarySize = this.estimatedSecondarySize, 
                    dim;
                }, this.updateRenderRange = function(scrollValue, scrollValueEnd) {
                    renderStartIndex = Math.max(0, this.getEstimatedIndex(scrollValue)), renderEndIndex = Math.min(data.length - 1, this.getEstimatedIndex(scrollValueEnd) + this.estimatedItemsAcross - 1), 
                    renderBeforeBoundary = Math.max(0, this.getEstimatedPrimaryPos(renderStartIndex)), 
                    renderAfterBoundary = this.getEstimatedPrimaryPos(renderEndIndex) + this.estimatedPrimarySize;
                };
            }
            function DynamicViewType() {
                function calculateDimensionsList(toIndex) {
                    var i, prevDimension, dim;
                    for (i = Math.max(0, dimensionsIndex); toIndex >= i && (dim = dimensions[i]); i++) prevDimension = dimensions[i - 1] || EMPTY_DIMENSION, 
                    dim.primarySize = self.getItemPrimarySize(i, data[i]), dim.secondarySize = self.scrollSecondarySize, 
                    dim.primaryPos = prevDimension.primaryPos + prevDimension.primarySize, dim.secondaryPos = 0;
                }
                function calculateDimensionsGrid(toIndex) {
                    var i, prevDimension, dim;
                    for (i = Math.max(dimensionsIndex, 0); toIndex >= i && (dim = dimensions[i]); i++) prevDimension = dimensions[i - 1] || EMPTY_DIMENSION, 
                    dim.secondarySize = Math.min(self.getItemSecondarySize(i, data[i]), self.scrollSecondarySize), 
                    dim.secondaryPos = prevDimension.secondaryPos + prevDimension.secondarySize, 0 === i || dim.secondaryPos + dim.secondarySize > self.scrollSecondarySize ? (dim.secondaryPos = 0, 
                    dim.primarySize = self.getItemPrimarySize(i, data[i]), dim.primaryPos = prevDimension.primaryPos + prevDimension.rowPrimarySize, 
                    dim.rowStartIndex = i, dim.rowPrimarySize = dim.primarySize) : (dim.primarySize = self.getItemPrimarySize(i, data[i]), 
                    dim.primaryPos = prevDimension.primaryPos, dim.rowStartIndex = prevDimension.rowStartIndex, 
                    dimensions[dim.rowStartIndex].rowPrimarySize = dim.rowPrimarySize = Math.max(dimensions[dim.rowStartIndex].rowPrimarySize, dim.primarySize), 
                    dim.rowPrimarySize = Math.max(dim.primarySize, dim.rowPrimarySize));
                }
                var dimensionsIndex, self = this, debouncedScrollViewSetDimensions = ionic.debounce(scrollViewSetDimensions, 25, !0), calculateDimensions = isGridView ? calculateDimensionsGrid : calculateDimensionsList, dimensions = [];
                this.getContentSize = function() {
                    var dim = dimensions[dimensionsIndex] || EMPTY_DIMENSION;
                    return (dim.primaryPos + dim.primarySize || 0) + this.getEstimatedPrimaryPos(data.length - dimensionsIndex - 1) + repeaterBeforeSize + repeaterAfterSize;
                }, this.onDestroy = function() {
                    dimensions.length = 0;
                }, this.onRefreshData = function() {
                    var i, ii;
                    for (i = dimensions.length, ii = data.length; ii > i; i++) dimensions.push({});
                    dimensionsIndex = -1;
                }, this.onRefreshLayout = function() {
                    dimensionsIndex = -1;
                }, this.getDimensions = function(index) {
                    return index = Math.min(index, data.length - 1), index > dimensionsIndex && (index > .9 * data.length ? (calculateDimensions(data.length - 1), 
                    dimensionsIndex = data.length - 1, scrollViewSetDimensions()) : (calculateDimensions(index), 
                    dimensionsIndex = index, debouncedScrollViewSetDimensions())), dimensions[index];
                };
                var oldRenderStartIndex = -1, oldScrollValue = -1;
                this.updateRenderRange = function(scrollValue, scrollValueEnd) {
                    var i, len, dim;
                    if (this.getDimensions(2 * this.getEstimatedIndex(scrollValueEnd)), -1 === oldRenderStartIndex || 0 === scrollValue) i = 0; else if (scrollValue >= oldScrollValue) for (i = oldRenderStartIndex, 
                    len = data.length; len > i && !((dim = this.getDimensions(i)) && dim.primaryPos + dim.rowPrimarySize >= scrollValue); i++) ; else for (i = oldRenderStartIndex; i >= 0; i--) if ((dim = this.getDimensions(i)) && dim.primaryPos <= scrollValue) {
                        i = isGridView ? dim.rowStartIndex : i;
                        break;
                    }
                    renderStartIndex = Math.min(Math.max(0, i), data.length - 1), renderBeforeBoundary = -1 !== renderStartIndex ? this.getDimensions(renderStartIndex).primaryPos : -1;
                    var lastRowDim;
                    for (i = renderStartIndex + 1, len = data.length; len > i; i++) if ((dim = this.getDimensions(i)) && dim.primaryPos + dim.rowPrimarySize > scrollValueEnd) {
                        if (isGridView) for (lastRowDim = dim; len - 1 > i && (dim = this.getDimensions(i + 1)).primaryPos === lastRowDim.primaryPos; ) i++;
                        break;
                    }
                    renderEndIndex = Math.min(i, data.length - 1), renderAfterBoundary = -1 !== renderEndIndex ? (dim = this.getDimensions(renderEndIndex)).primaryPos + (dim.rowPrimarySize || dim.primarySize) : -1, 
                    oldScrollValue = scrollValue, oldRenderStartIndex = renderStartIndex;
                };
            }
            var estimatedHeight, estimatedWidth, afterItemsNode = options.afterItemsNode, containerNode = options.containerNode, forceRefreshImages = options.forceRefreshImages, heightData = options.heightData, widthData = options.widthData, keyExpression = options.keyExpression, renderBuffer = options.renderBuffer, scope = options.scope, scrollView = options.scrollView, transclude = options.transclude, data = [], getterLocals = {}, heightFn = heightData.getValue || function() {
                return heightData.value;
            }, heightGetter = function(index, value) {
                return getterLocals[keyExpression] = value, getterLocals.$index = index, heightFn(scope, getterLocals);
            }, widthFn = widthData.getValue || function() {
                return widthData.value;
            }, widthGetter = function(index, value) {
                return getterLocals[keyExpression] = value, getterLocals.$index = index, widthFn(scope, getterLocals);
            }, isVertical = !!scrollView.options.scrollingY, isGridView = isVertical ? widthData.dynamic || widthData.value !== scrollView.__clientWidth : heightData.dynamic || heightData.value !== scrollView.__clientHeight, isStaticView = !heightData.dynamic && !widthData.dynamic, PRIMARY = "PRIMARY", SECONDARY = "SECONDARY", TRANSLATE_TEMPLATE_STR = isVertical ? "translate3d(SECONDARYpx,PRIMARYpx,0)" : "translate3d(PRIMARYpx,SECONDARYpx,0)", WIDTH_HEIGHT_TEMPLATE_STR = isVertical ? "height: PRIMARYpx; width: SECONDARYpx;" : "height: SECONDARYpx; width: PRIMARYpx;", repeaterBeforeSize = 0, repeaterAfterSize = 0, renderStartIndex = -1, renderEndIndex = -1, renderAfterBoundary = -1, renderBeforeBoundary = -1, itemsPool = [], itemsLeaving = [], itemsEntering = [], itemsShownMap = {}, nextItemId = 0, scrollViewSetDimensions = isVertical ? function() {
                scrollView.setDimensions(null, null, null, view.getContentSize(), !0);
            } : function() {
                scrollView.setDimensions(null, null, view.getContentSize(), null, !0);
            }, view = isVertical ? new VerticalViewType() : new HorizontalViewType();
            (isGridView ? GridViewType : ListViewType).call(view), (isStaticView ? StaticViewType : DynamicViewType).call(view);
            var contentSizeStr = isVertical ? "getContentHeight" : "getContentWidth", originalGetContentSize = scrollView.options[contentSizeStr];
            scrollView.options[contentSizeStr] = angular.bind(view, view.getContentSize), scrollView.__$callback = scrollView.__callback, 
            scrollView.__callback = function(transformLeft, transformTop, zoom, wasResize) {
                var scrollValue = view.getScrollValue();
                (-1 === renderStartIndex || scrollValue + view.scrollPrimarySize > renderAfterBoundary || renderBeforeBoundary > scrollValue) && render(), 
                scrollView.__$callback(transformLeft, transformTop, zoom, wasResize);
            };
            var isLayoutReady = !1, isDataReady = !1;
            this.refreshLayout = function() {
                data.length ? (estimatedHeight = heightGetter(0, data[0]), estimatedWidth = widthGetter(0, data[0])) : (estimatedHeight = 100, 
                estimatedWidth = 100);
                var style = getComputedStyle(afterItemsNode) || {}, firstStyle = afterItemsNode.firstElementChild && getComputedStyle(afterItemsNode.firstElementChild) || {}, lastStyle = afterItemsNode.lastElementChild && getComputedStyle(afterItemsNode.lastElementChild) || {};
                repeaterAfterSize = (parseInt(style[isVertical ? "height" : "width"]) || 0) + (firstStyle && parseInt(firstStyle[isVertical ? "marginTop" : "marginLeft"]) || 0) + (lastStyle && parseInt(lastStyle[isVertical ? "marginBottom" : "marginRight"]) || 0), 
                repeaterBeforeSize = 0;
                var current = containerNode;
                do repeaterBeforeSize += current[isVertical ? "offsetTop" : "offsetLeft"]; while (ionic.DomUtil.contains(scrollView.__content, current = current.offsetParent));
                var containerPrevNode = containerNode.previousElementSibling, beforeStyle = containerPrevNode ? $window.getComputedStyle(containerPrevNode) : {}, beforeMargin = parseInt(beforeStyle[isVertical ? "marginBottom" : "marginRight"] || 0);
                if (containerNode.style[ionic.CSS.TRANSFORM] = TRANSLATE_TEMPLATE_STR.replace(PRIMARY, -beforeMargin).replace(SECONDARY, 0), 
                repeaterBeforeSize -= beforeMargin, scrollView.__clientHeight && scrollView.__clientWidth || (scrollView.__clientWidth = scrollView.__container.clientWidth, 
                scrollView.__clientHeight = scrollView.__container.clientHeight), (view.onRefreshLayout || angular.noop)(), 
                view.refreshDirection(), scrollViewSetDimensions(), !isLayoutReady) for (var poolSize = Math.max(20, 3 * renderBuffer), i = 0; poolSize > i; i++) itemsPool.push(new RepeatItem());
                isLayoutReady = !0, isLayoutReady && isDataReady && ((scrollView.__scrollLeft > scrollView.__maxScrollLeft || scrollView.__scrollTop > scrollView.__maxScrollTop) && scrollView.resize(), 
                forceRerender(!0));
            }, this.setData = function(newData) {
                data = newData, (view.onRefreshData || angular.noop)(), isDataReady = !0;
            }, this.destroy = function() {
                render.destroyed = !0, itemsPool.forEach(function(item) {
                    item.scope.$destroy(), item.scope = item.element = item.node = item.images = null;
                }), itemsPool.length = itemsEntering.length = itemsLeaving.length = 0, itemsShownMap = {}, 
                scrollView.options[contentSizeStr] = originalGetContentSize, scrollView.__callback = scrollView.__$callback, 
                scrollView.resize(), (view.onDestroy || angular.noop)();
            };
        };
    }
    function gestureDirective(directiveName) {
        return [ "$ionicGesture", "$parse", function($ionicGesture, $parse) {
            var eventType = directiveName.substr(2).toLowerCase();
            return function(scope, element, attr) {
                var fn = $parse(attr[directiveName]), listener = function(ev) {
                    scope.$apply(function() {
                        fn(scope, {
                            $event: ev
                        });
                    });
                }, gesture = $ionicGesture.on(eventType, listener, element);
                scope.$on("$destroy", function() {
                    $ionicGesture.off(gesture, eventType, listener);
                });
            };
        } ];
    }
    function headerFooterBarDirective(isHeader) {
        return [ "$document", "$timeout", function($document, $timeout) {
            return {
                restrict: "E",
                controller: "$ionicHeaderBar",
                compile: function(tElement) {
                    function prelink($scope, $element, $attr, ctrl) {
                        isHeader ? ($scope.$watch(function() {
                            return $element[0].className;
                        }, function(value) {
                            var isShown = -1 === value.indexOf("ng-hide"), isSubheader = -1 !== value.indexOf("bar-subheader");
                            $scope.$hasHeader = isShown && !isSubheader, $scope.$hasSubheader = isShown && isSubheader, 
                            $scope.$emit("$ionicSubheader", $scope.$hasSubheader);
                        }), $scope.$on("$destroy", function() {
                            delete $scope.$hasHeader, delete $scope.$hasSubheader;
                        }), ctrl.align(), $scope.$on("$ionicHeader.align", function() {
                            ionic.requestAnimationFrame(function() {
                                ctrl.align();
                            });
                        })) : ($scope.$watch(function() {
                            return $element[0].className;
                        }, function(value) {
                            var isShown = -1 === value.indexOf("ng-hide"), isSubfooter = -1 !== value.indexOf("bar-subfooter");
                            $scope.$hasFooter = isShown && !isSubfooter, $scope.$hasSubfooter = isShown && isSubfooter;
                        }), $scope.$on("$destroy", function() {
                            delete $scope.$hasFooter, delete $scope.$hasSubfooter;
                        }), $scope.$watch("$hasTabs", function(val) {
                            $element.toggleClass("has-tabs", !!val);
                        }), ctrl.align(), $scope.$on("$ionicFooter.align", function() {
                            ionic.requestAnimationFrame(function() {
                                ctrl.align();
                            });
                        }));
                    }
                    return tElement.addClass(isHeader ? "bar bar-header" : "bar bar-footer"), $timeout(function() {
                        isHeader && $document[0].getElementsByClassName("tabs-top").length && tElement.addClass("has-tabs-top");
                    }), {
                        pre: prelink
                    };
                }
            };
        } ];
    }
    function keyboardAttachGetClientHeight(element) {
        return element.clientHeight;
    }
    function eventStopPropagation(e) {
        e.stopPropagation();
    }
    var IonicModule = angular.module("ionic", [ "ngAnimate", "ngSanitize", "ui.router", "ngIOS9UIWebViewPatch" ]), extend = angular.extend, forEach = angular.forEach, isDefined = angular.isDefined, isNumber = angular.isNumber, isString = angular.isString, jqLite = angular.element, noop = angular.noop;
    IonicModule.factory("$ionicActionSheet", [ "$rootScope", "$compile", "$animate", "$timeout", "$ionicTemplateLoader", "$ionicPlatform", "$ionicBody", "IONIC_BACK_PRIORITY", function($rootScope, $compile, $animate, $timeout, $ionicTemplateLoader, $ionicPlatform, $ionicBody, IONIC_BACK_PRIORITY) {
        function actionSheet(opts) {
            function textForIcon(text) {
                text && /icon/.test(text) && (scope.$actionSheetHasIcon = !0);
            }
            var scope = $rootScope.$new(!0);
            extend(scope, {
                cancel: noop,
                destructiveButtonClicked: noop,
                buttonClicked: noop,
                $deregisterBackButton: noop,
                buttons: [],
                cancelOnStateChange: !0
            }, opts || {});
            for (var x = 0; x < scope.buttons.length; x++) textForIcon(scope.buttons[x].text);
            textForIcon(scope.cancelText), textForIcon(scope.destructiveText);
            var element = scope.element = $compile('<ion-action-sheet ng-class="cssClass" buttons="buttons"></ion-action-sheet>')(scope), sheetEl = jqLite(element[0].querySelector(".action-sheet-wrapper")), stateChangeListenDone = scope.cancelOnStateChange ? $rootScope.$on("$stateChangeSuccess", function() {
                scope.cancel();
            }) : noop;
            return scope.removeSheet = function(done) {
                scope.removed || (scope.removed = !0, sheetEl.removeClass("action-sheet-up"), $timeout(function() {
                    $ionicBody.removeClass("action-sheet-open");
                }, 400), scope.$deregisterBackButton(), stateChangeListenDone(), $animate.removeClass(element, "active").then(function() {
                    scope.$destroy(), element.remove(), scope.cancel.$scope = sheetEl = null, (done || noop)(opts.buttons);
                }));
            }, scope.showSheet = function(done) {
                scope.removed || ($ionicBody.append(element).addClass("action-sheet-open"), $animate.addClass(element, "active").then(function() {
                    scope.removed || (done || noop)();
                }), $timeout(function() {
                    scope.removed || sheetEl.addClass("action-sheet-up");
                }, 20, !1));
            }, scope.$deregisterBackButton = $ionicPlatform.registerBackButtonAction(function() {
                $timeout(scope.cancel);
            }, IONIC_BACK_PRIORITY.actionSheet), scope.cancel = function() {
                scope.removeSheet(opts.cancel);
            }, scope.buttonClicked = function(index) {
                opts.buttonClicked(index, opts.buttons[index]) === !0 && scope.removeSheet();
            }, scope.destructiveButtonClicked = function() {
                opts.destructiveButtonClicked() === !0 && scope.removeSheet();
            }, scope.showSheet(), scope.cancel.$scope = scope, scope.cancel;
        }
        return {
            show: actionSheet
        };
    } ]), jqLite.prototype.addClass = function(cssClasses) {
        var x, y, cssClass, el, splitClasses, existingClasses;
        if (cssClasses && "ng-scope" != cssClasses && "ng-isolate-scope" != cssClasses) for (x = 0; x < this.length; x++) if (el = this[x], 
        el.setAttribute) if (cssClasses.indexOf(" ") < 0 && el.classList.add) el.classList.add(cssClasses); else {
            for (existingClasses = (" " + (el.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " "), 
            splitClasses = cssClasses.split(" "), y = 0; y < splitClasses.length; y++) cssClass = splitClasses[y].trim(), 
            -1 === existingClasses.indexOf(" " + cssClass + " ") && (existingClasses += cssClass + " ");
            el.setAttribute("class", existingClasses.trim());
        }
        return this;
    }, jqLite.prototype.removeClass = function(cssClasses) {
        var x, y, splitClasses, cssClass, el;
        if (cssClasses) for (x = 0; x < this.length; x++) if (el = this[x], el.getAttribute) if (cssClasses.indexOf(" ") < 0 && el.classList.remove) el.classList.remove(cssClasses); else for (splitClasses = cssClasses.split(" "), 
        y = 0; y < splitClasses.length; y++) cssClass = splitClasses[y], el.setAttribute("class", (" " + (el.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").replace(" " + cssClass.trim() + " ", " ").trim());
        return this;
    }, IonicModule.factory("$ionicBackdrop", [ "$document", "$timeout", "$$rAF", "$rootScope", function($document, $timeout, $$rAF, $rootScope) {
        function retain() {
            backdropHolds++, 1 === backdropHolds && (el.addClass("visible"), $rootScope.$broadcast("backdrop.shown"), 
            $$rAF(function() {
                backdropHolds >= 1 && el.addClass("active");
            }));
        }
        function release() {
            1 === backdropHolds && (el.removeClass("active"), $rootScope.$broadcast("backdrop.hidden"), 
            $timeout(function() {
                0 === backdropHolds && el.removeClass("visible");
            }, 400, !1)), backdropHolds = Math.max(0, backdropHolds - 1);
        }
        function getElement() {
            return el;
        }
        var el = jqLite('<div class="backdrop">'), backdropHolds = 0;
        return $document[0].body.appendChild(el[0]), {
            retain: retain,
            release: release,
            getElement: getElement,
            _element: el
        };
    } ]), IonicModule.factory("$ionicBind", [ "$parse", "$interpolate", function($parse, $interpolate) {
        var LOCAL_REGEXP = /^\s*([@=&])(\??)\s*(\w*)\s*$/;
        return function(scope, attrs, bindDefinition) {
            forEach(bindDefinition || {}, function(definition, scopeName) {
                var parentGet, unwatch, match = definition.match(LOCAL_REGEXP) || [], attrName = match[3] || scopeName, mode = match[1];
                switch (mode) {
                  case "@":
                    if (!attrs[attrName]) return;
                    attrs.$observe(attrName, function(value) {
                        scope[scopeName] = value;
                    }), attrs[attrName] && (scope[scopeName] = $interpolate(attrs[attrName])(scope));
                    break;

                  case "=":
                    if (!attrs[attrName]) return;
                    unwatch = scope.$watch(attrs[attrName], function(value) {
                        scope[scopeName] = value;
                    }), scope.$on("$destroy", unwatch);
                    break;

                  case "&":
                    if (attrs[attrName] && attrs[attrName].match(RegExp(scopeName + "(.*?)"))) throw new Error('& expression binding "' + scopeName + '" looks like it will recursively call "' + attrs[attrName] + '" and cause a stack overflow! Please choose a different scopeName.');
                    parentGet = $parse(attrs[attrName]), scope[scopeName] = function(locals) {
                        return parentGet(scope, locals);
                    };
                }
            });
        };
    } ]), IonicModule.factory("$ionicBody", [ "$document", function($document) {
        return {
            addClass: function() {
                for (var x = 0; x < arguments.length; x++) $document[0].body.classList.add(arguments[x]);
                return this;
            },
            removeClass: function() {
                for (var x = 0; x < arguments.length; x++) $document[0].body.classList.remove(arguments[x]);
                return this;
            },
            enableClass: function(shouldEnableClass) {
                var args = Array.prototype.slice.call(arguments).slice(1);
                return shouldEnableClass ? this.addClass.apply(this, args) : this.removeClass.apply(this, args), 
                this;
            },
            append: function(ele) {
                return $document[0].body.appendChild(ele.length ? ele[0] : ele), this;
            },
            get: function() {
                return $document[0].body;
            }
        };
    } ]), IonicModule.factory("$ionicClickBlock", [ "$document", "$ionicBody", "$timeout", function($document, $ionicBody, $timeout) {
        function preventClick(ev) {
            ev.preventDefault(), ev.stopPropagation();
        }
        function addClickBlock() {
            pendingShow && (cbEle ? cbEle.classList.remove(CSS_HIDE) : (cbEle = $document[0].createElement("div"), 
            cbEle.className = "click-block", $ionicBody.append(cbEle), cbEle.addEventListener("touchstart", preventClick), 
            cbEle.addEventListener("mousedown", preventClick)), pendingShow = !1);
        }
        function removeClickBlock() {
            cbEle && cbEle.classList.add(CSS_HIDE);
        }
        var cbEle, fallbackTimer, pendingShow, CSS_HIDE = "click-block-hide";
        return {
            show: function(autoExpire) {
                pendingShow = !0, $timeout.cancel(fallbackTimer), fallbackTimer = $timeout(this.hide, autoExpire || 310, !1), 
                addClickBlock();
            },
            hide: function() {
                pendingShow = !1, $timeout.cancel(fallbackTimer), removeClickBlock();
            }
        };
    } ]), IonicModule.factory("$ionicGesture", [ function() {
        return {
            on: function(eventType, cb, $element, options) {
                return window.ionic.onGesture(eventType, cb, $element[0], options);
            },
            off: function(gesture, eventType, cb) {
                return window.ionic.offGesture(gesture, eventType, cb);
            }
        };
    } ]), IonicModule.factory("$ionicHistory", [ "$rootScope", "$state", "$location", "$window", "$timeout", "$ionicViewSwitcher", "$ionicNavViewDelegate", function($rootScope, $state, $location, $window, $timeout, $ionicViewSwitcher, $ionicNavViewDelegate) {
        function getViewById(viewId) {
            return viewId ? viewHistory.views[viewId] : null;
        }
        function getBackView(view) {
            return view ? getViewById(view.backViewId) : null;
        }
        function getForwardView(view) {
            return view ? getViewById(view.forwardViewId) : null;
        }
        function getHistoryById(historyId) {
            return historyId ? viewHistory.histories[historyId] : null;
        }
        function getHistory(scope) {
            var histObj = getParentHistoryObj(scope);
            return viewHistory.histories[histObj.historyId] || (viewHistory.histories[histObj.historyId] = {
                historyId: histObj.historyId,
                parentHistoryId: getParentHistoryObj(histObj.scope.$parent).historyId,
                stack: [],
                cursor: -1
            }), getHistoryById(histObj.historyId);
        }
        function getParentHistoryObj(scope) {
            for (var parentScope = scope; parentScope; ) {
                if (parentScope.hasOwnProperty("$historyId")) return {
                    historyId: parentScope.$historyId,
                    scope: parentScope
                };
                parentScope = parentScope.$parent;
            }
            return {
                historyId: "root",
                scope: $rootScope
            };
        }
        function setNavViews(viewId) {
            viewHistory.currentView = getViewById(viewId), viewHistory.backView = getBackView(viewHistory.currentView), 
            viewHistory.forwardView = getForwardView(viewHistory.currentView);
        }
        function getCurrentStateId() {
            var id;
            if ($state && $state.current && $state.current.name) {
                if (id = $state.current.name, $state.params) for (var key in $state.params) $state.params.hasOwnProperty(key) && $state.params[key] && (id += "_" + key + "=" + $state.params[key]);
                return id;
            }
            return ionic.Utils.nextUid();
        }
        function getCurrentStateParams() {
            var rtn;
            if ($state && $state.params) for (var key in $state.params) $state.params.hasOwnProperty(key) && (rtn = rtn || {}, 
            rtn[key] = $state.params[key]);
            return rtn;
        }
        function isAbstractTag(ele) {
            return ele && ele.length && /ion-side-menus|ion-tabs/i.test(ele[0].tagName);
        }
        function canSwipeBack(ele, viewLocals) {
            return viewLocals && viewLocals.$$state && viewLocals.$$state.self.canSwipeBack === !1 ? !1 : ele && "false" === ele.attr("can-swipe-back") ? !1 : !0;
        }
        var lastStateId, nextViewOptions, deregisterStateChangeListener, nextViewExpireTimer, forcedNav, ACTION_INITIAL_VIEW = "initialView", ACTION_NEW_VIEW = "newView", ACTION_MOVE_BACK = "moveBack", ACTION_MOVE_FORWARD = "moveForward", DIRECTION_BACK = "back", DIRECTION_FORWARD = "forward", DIRECTION_ENTER = "enter", DIRECTION_EXIT = "exit", DIRECTION_SWAP = "swap", DIRECTION_NONE = "none", stateChangeCounter = 0, viewHistory = {
            histories: {
                root: {
                    historyId: "root",
                    parentHistoryId: null,
                    stack: [],
                    cursor: -1
                }
            },
            views: {},
            backView: null,
            forwardView: null,
            currentView: null
        }, View = function() {};
        return View.prototype.initialize = function(data) {
            if (data) {
                for (var name in data) this[name] = data[name];
                return this;
            }
            return null;
        }, View.prototype.go = function() {
            if (this.stateName) return $state.go(this.stateName, this.stateParams);
            if (this.url && this.url !== $location.url()) {
                if (viewHistory.backView === this) return $window.history.go(-1);
                if (viewHistory.forwardView === this) return $window.history.go(1);
                $location.url(this.url);
            }
            return null;
        }, View.prototype.destroy = function() {
            this.scope && (this.scope.$destroy && this.scope.$destroy(), this.scope = null);
        }, {
            register: function(parentScope, viewLocals) {
                var tmp, x, ele, currentStateId = getCurrentStateId(), hist = getHistory(parentScope), currentView = viewHistory.currentView, backView = viewHistory.backView, forwardView = viewHistory.forwardView, viewId = null, action = null, direction = DIRECTION_NONE, historyId = hist.historyId, url = $location.url();
                if (lastStateId !== currentStateId && (lastStateId = currentStateId, stateChangeCounter++), 
                forcedNav) viewId = forcedNav.viewId, action = forcedNav.action, direction = forcedNav.direction, 
                forcedNav = null; else if (backView && backView.stateId === currentStateId) viewId = backView.viewId, 
                historyId = backView.historyId, action = ACTION_MOVE_BACK, backView.historyId === currentView.historyId ? direction = DIRECTION_BACK : currentView && (direction = DIRECTION_EXIT, 
                tmp = getHistoryById(backView.historyId), tmp && tmp.parentHistoryId === currentView.historyId ? direction = DIRECTION_ENTER : (tmp = getHistoryById(currentView.historyId), 
                tmp && tmp.parentHistoryId === hist.parentHistoryId && (direction = DIRECTION_SWAP))); else if (forwardView && forwardView.stateId === currentStateId) viewId = forwardView.viewId, 
                historyId = forwardView.historyId, action = ACTION_MOVE_FORWARD, forwardView.historyId === currentView.historyId ? direction = DIRECTION_FORWARD : currentView && (direction = DIRECTION_EXIT, 
                currentView.historyId === hist.parentHistoryId ? direction = DIRECTION_ENTER : (tmp = getHistoryById(currentView.historyId), 
                tmp && tmp.parentHistoryId === hist.parentHistoryId && (direction = DIRECTION_SWAP))), 
                tmp = getParentHistoryObj(parentScope), forwardView.historyId && tmp.scope && (tmp.scope.$historyId = forwardView.historyId, 
                historyId = forwardView.historyId); else if (currentView && currentView.historyId !== historyId && hist.cursor > -1 && hist.stack.length > 0 && hist.cursor < hist.stack.length && hist.stack[hist.cursor].stateId === currentStateId) {
                    var switchToView = hist.stack[hist.cursor];
                    viewId = switchToView.viewId, historyId = switchToView.historyId, action = ACTION_MOVE_BACK, 
                    direction = DIRECTION_SWAP, tmp = getHistoryById(currentView.historyId), tmp && tmp.parentHistoryId === historyId ? direction = DIRECTION_EXIT : (tmp = getHistoryById(historyId), 
                    tmp && tmp.parentHistoryId === currentView.historyId && (direction = DIRECTION_ENTER)), 
                    tmp = getViewById(switchToView.backViewId), tmp && switchToView.historyId !== tmp.historyId && (hist.stack[hist.cursor].backViewId = currentView.viewId);
                } else {
                    if (ele = $ionicViewSwitcher.createViewEle(viewLocals), this.isAbstractEle(ele, viewLocals)) return {
                        action: "abstractView",
                        direction: DIRECTION_NONE,
                        ele: ele
                    };
                    if (viewId = ionic.Utils.nextUid(), currentView) {
                        if (currentView.forwardViewId = viewId, action = ACTION_NEW_VIEW, forwardView && currentView.stateId !== forwardView.stateId && currentView.historyId === forwardView.historyId && (tmp = getHistoryById(forwardView.historyId))) {
                            for (x = tmp.stack.length - 1; x >= forwardView.index; x--) {
                                var stackItem = tmp.stack[x];
                                stackItem && stackItem.destroy && stackItem.destroy(), tmp.stack.splice(x);
                            }
                            historyId = forwardView.historyId;
                        }
                        hist.historyId === currentView.historyId ? direction = DIRECTION_FORWARD : currentView.historyId !== hist.historyId && (direction = DIRECTION_ENTER, 
                        tmp = getHistoryById(currentView.historyId), tmp && tmp.parentHistoryId === hist.parentHistoryId ? direction = DIRECTION_SWAP : (tmp = getHistoryById(tmp.parentHistoryId), 
                        tmp && tmp.historyId === hist.historyId && (direction = DIRECTION_EXIT)));
                    } else action = ACTION_INITIAL_VIEW;
                    2 > stateChangeCounter && (direction = DIRECTION_NONE), viewHistory.views[viewId] = this.createView({
                        viewId: viewId,
                        index: hist.stack.length,
                        historyId: hist.historyId,
                        backViewId: currentView && currentView.viewId ? currentView.viewId : null,
                        forwardViewId: null,
                        stateId: currentStateId,
                        stateName: this.currentStateName(),
                        stateParams: getCurrentStateParams(),
                        url: url,
                        canSwipeBack: canSwipeBack(ele, viewLocals)
                    }), hist.stack.push(viewHistory.views[viewId]);
                }
                if (deregisterStateChangeListener && deregisterStateChangeListener(), $timeout.cancel(nextViewExpireTimer), 
                nextViewOptions) {
                    if (nextViewOptions.disableAnimate && (direction = DIRECTION_NONE), nextViewOptions.disableBack && (viewHistory.views[viewId].backViewId = null), 
                    nextViewOptions.historyRoot) {
                        for (x = 0; x < hist.stack.length; x++) hist.stack[x].viewId === viewId ? (hist.stack[x].index = 0, 
                        hist.stack[x].backViewId = hist.stack[x].forwardViewId = null) : delete viewHistory.views[hist.stack[x].viewId];
                        hist.stack = [ viewHistory.views[viewId] ];
                    }
                    nextViewOptions = null;
                }
                if (setNavViews(viewId), viewHistory.backView && historyId == viewHistory.backView.historyId && currentStateId == viewHistory.backView.stateId && url == viewHistory.backView.url) for (x = 0; x < hist.stack.length; x++) if (hist.stack[x].viewId == viewId) {
                    action = "dupNav", direction = DIRECTION_NONE, x > 0 && (hist.stack[x - 1].forwardViewId = null), 
                    viewHistory.forwardView = null, viewHistory.currentView.index = viewHistory.backView.index, 
                    viewHistory.currentView.backViewId = viewHistory.backView.backViewId, viewHistory.backView = getBackView(viewHistory.backView), 
                    hist.stack.splice(x, 1);
                    break;
                }
                return hist.cursor = viewHistory.currentView.index, {
                    viewId: viewId,
                    action: action,
                    direction: direction,
                    historyId: historyId,
                    enableBack: this.enabledBack(viewHistory.currentView),
                    isHistoryRoot: 0 === viewHistory.currentView.index,
                    ele: ele
                };
            },
            registerHistory: function(scope) {
                scope.$historyId = ionic.Utils.nextUid();
            },
            createView: function(data) {
                var newView = new View();
                return newView.initialize(data);
            },
            getViewById: getViewById,
            viewHistory: function() {
                return viewHistory;
            },
            currentView: function(view) {
                return arguments.length && (viewHistory.currentView = view), viewHistory.currentView;
            },
            currentHistoryId: function() {
                return viewHistory.currentView ? viewHistory.currentView.historyId : null;
            },
            currentTitle: function(val) {
                return viewHistory.currentView ? (arguments.length && (viewHistory.currentView.title = val), 
                viewHistory.currentView.title) : void 0;
            },
            backView: function(view) {
                return arguments.length && (viewHistory.backView = view), viewHistory.backView;
            },
            backTitle: function(view) {
                var backView = view && getViewById(view.backViewId) || viewHistory.backView;
                return backView && backView.title;
            },
            forwardView: function(view) {
                return arguments.length && (viewHistory.forwardView = view), viewHistory.forwardView;
            },
            currentStateName: function() {
                return $state && $state.current ? $state.current.name : null;
            },
            isCurrentStateNavView: function(navView) {
                return !!($state && $state.current && $state.current.views && $state.current.views[navView]);
            },
            goToHistoryRoot: function(historyId) {
                if (historyId) {
                    var hist = getHistoryById(historyId);
                    if (hist && hist.stack.length) {
                        if (viewHistory.currentView && viewHistory.currentView.viewId === hist.stack[0].viewId) return;
                        forcedNav = {
                            viewId: hist.stack[0].viewId,
                            action: ACTION_MOVE_BACK,
                            direction: DIRECTION_BACK
                        }, hist.stack[0].go();
                    }
                }
            },
            goBack: function(backCount) {
                if (isDefined(backCount) && -1 !== backCount) {
                    if (backCount > -1) return;
                    var currentHistory = viewHistory.histories[this.currentHistoryId()], newCursor = currentHistory.cursor + backCount + 1;
                    1 > newCursor && (newCursor = 1), currentHistory.cursor = newCursor, setNavViews(currentHistory.stack[newCursor].viewId);
                    for (var cursor = newCursor - 1, clearStateIds = [], fwdView = getViewById(currentHistory.stack[cursor].forwardViewId); fwdView && (clearStateIds.push(fwdView.stateId || fwdView.viewId), 
                    cursor++, !(cursor >= currentHistory.stack.length)); ) fwdView = getViewById(currentHistory.stack[cursor].forwardViewId);
                    var self = this;
                    clearStateIds.length && $timeout(function() {
                        self.clearCache(clearStateIds);
                    }, 600);
                }
                viewHistory.backView && viewHistory.backView.go();
            },
            enabledBack: function(view) {
                var backView = getBackView(view);
                return !(!backView || backView.historyId !== view.historyId);
            },
            clearHistory: function() {
                var histories = viewHistory.histories, currentView = viewHistory.currentView;
                if (histories) for (var historyId in histories) histories[historyId].stack && (histories[historyId].stack = [], 
                histories[historyId].cursor = -1), currentView && currentView.historyId === historyId ? (currentView.backViewId = currentView.forwardViewId = null, 
                histories[historyId].stack.push(currentView)) : histories[historyId].destroy && histories[historyId].destroy();
                for (var viewId in viewHistory.views) viewId !== currentView.viewId && delete viewHistory.views[viewId];
                currentView && setNavViews(currentView.viewId);
            },
            clearCache: function(stateIds) {
                return $timeout(function() {
                    $ionicNavViewDelegate._instances.forEach(function(instance) {
                        instance.clearCache(stateIds);
                    });
                });
            },
            nextViewOptions: function(opts) {
                return deregisterStateChangeListener && deregisterStateChangeListener(), arguments.length && ($timeout.cancel(nextViewExpireTimer), 
                null === opts ? nextViewOptions = opts : (nextViewOptions = nextViewOptions || {}, 
                extend(nextViewOptions, opts), nextViewOptions.expire && (deregisterStateChangeListener = $rootScope.$on("$stateChangeSuccess", function() {
                    nextViewExpireTimer = $timeout(function() {
                        nextViewOptions = null;
                    }, nextViewOptions.expire);
                })))), nextViewOptions;
            },
            isAbstractEle: function(ele, viewLocals) {
                return viewLocals && viewLocals.$$state && viewLocals.$$state.self["abstract"] ? !0 : !(!ele || !isAbstractTag(ele) && !isAbstractTag(ele.children()));
            },
            isActiveScope: function(scope) {
                if (!scope) return !1;
                for (var foundHistoryId, climbScope = scope, currentHistoryId = this.currentHistoryId(); climbScope; ) {
                    if (climbScope.$$disconnected) return !1;
                    if (!foundHistoryId && climbScope.hasOwnProperty("$historyId") && (foundHistoryId = !0), 
                    currentHistoryId) {
                        if (climbScope.hasOwnProperty("$historyId") && currentHistoryId == climbScope.$historyId) return !0;
                        if (climbScope.hasOwnProperty("$activeHistoryId") && currentHistoryId == climbScope.$activeHistoryId) {
                            if (climbScope.hasOwnProperty("$historyId")) return !0;
                            if (!foundHistoryId) return !0;
                        }
                    }
                    foundHistoryId && climbScope.hasOwnProperty("$activeHistoryId") && (foundHistoryId = !1), 
                    climbScope = climbScope.$parent;
                }
                return currentHistoryId ? "root" == currentHistoryId : !0;
            }
        };
    } ]).run([ "$rootScope", "$state", "$location", "$document", "$ionicPlatform", "$ionicHistory", "IONIC_BACK_PRIORITY", function($rootScope, $state, $location, $document, $ionicPlatform, $ionicHistory, IONIC_BACK_PRIORITY) {
        function onHardwareBackButton(e) {
            var backView = $ionicHistory.backView();
            return backView ? backView.go() : ionic.Platform.exitApp(), e.preventDefault(), 
            !1;
        }
        $rootScope.$on("$ionicView.beforeEnter", function() {
            ionic.keyboard && ionic.keyboard.hide && ionic.keyboard.hide();
        }), $rootScope.$on("$ionicHistory.change", function(e, data) {
            if (!data) return null;
            var viewHistory = $ionicHistory.viewHistory(), hist = data.historyId ? viewHistory.histories[data.historyId] : null;
            if (hist && hist.cursor > -1 && hist.cursor < hist.stack.length) {
                var view = hist.stack[hist.cursor];
                return view.go(data);
            }
            !data.url && data.uiSref && (data.url = $state.href(data.uiSref)), data.url && (0 === data.url.indexOf("#") && (data.url = data.url.replace("#", "")), 
            data.url !== $location.url() && $location.url(data.url));
        }), $rootScope.$ionicGoBack = function(backCount) {
            $ionicHistory.goBack(backCount);
        }, $rootScope.$on("$ionicView.afterEnter", function(ev, data) {
            data && data.title && ($document[0].title = data.title);
        }), $ionicPlatform.registerBackButtonAction(onHardwareBackButton, IONIC_BACK_PRIORITY.view);
    } ]), IonicModule.provider("$ionicConfig", function() {
        function setPlatformConfig(platformName, platformConfigs) {
            configProperties.platform[platformName] = platformConfigs, provider.platform[platformName] = {}, 
            addConfig(configProperties, configProperties.platform[platformName]), createConfig(configProperties.platform[platformName], provider.platform[platformName], "");
        }
        function addConfig(configObj, platformObj) {
            for (var n in configObj) n != PLATFORM && configObj.hasOwnProperty(n) && (angular.isObject(configObj[n]) ? (isDefined(platformObj[n]) || (platformObj[n] = {}), 
            addConfig(configObj[n], platformObj[n])) : isDefined(platformObj[n]) || (platformObj[n] = null));
        }
        function createConfig(configObj, providerObj, platformPath) {
            forEach(configObj, function(value, namespace) {
                angular.isObject(configObj[namespace]) ? (providerObj[namespace] = {}, createConfig(configObj[namespace], providerObj[namespace], platformPath + "." + namespace)) : providerObj[namespace] = function(newValue) {
                    if (arguments.length) return configObj[namespace] = newValue, providerObj;
                    if (configObj[namespace] == PLATFORM) {
                        var platformConfig = stringObj(configProperties.platform, ionic.Platform.platform() + platformPath + "." + namespace);
                        return platformConfig || platformConfig === !1 ? platformConfig : stringObj(configProperties.platform, "default" + platformPath + "." + namespace);
                    }
                    return configObj[namespace];
                };
            });
        }
        function stringObj(obj, str) {
            str = str.split(".");
            for (var i = 0; i < str.length; i++) {
                if (!obj || !isDefined(obj[str[i]])) return null;
                obj = obj[str[i]];
            }
            return obj;
        }
        var provider = this;
        provider.platform = {};
        var PLATFORM = "platform", configProperties = {
            views: {
                maxCache: PLATFORM,
                forwardCache: PLATFORM,
                transition: PLATFORM,
                swipeBackEnabled: PLATFORM,
                swipeBackHitWidth: PLATFORM
            },
            navBar: {
                alignTitle: PLATFORM,
                positionPrimaryButtons: PLATFORM,
                positionSecondaryButtons: PLATFORM,
                transition: PLATFORM
            },
            backButton: {
                icon: PLATFORM,
                text: PLATFORM,
                previousTitleText: PLATFORM
            },
            form: {
                checkbox: PLATFORM,
                toggle: PLATFORM
            },
            scrolling: {
                jsScrolling: PLATFORM
            },
            spinner: {
                icon: PLATFORM
            },
            tabs: {
                style: PLATFORM,
                position: PLATFORM
            },
            templates: {
                maxPrefetch: PLATFORM
            },
            platform: {}
        };
        createConfig(configProperties, provider, ""), setPlatformConfig("default", {
            views: {
                maxCache: 10,
                forwardCache: !1,
                transition: "ios",
                swipeBackEnabled: !0,
                swipeBackHitWidth: 45
            },
            navBar: {
                alignTitle: "center",
                positionPrimaryButtons: "left",
                positionSecondaryButtons: "right",
                transition: "view"
            },
            backButton: {
                icon: "ion-ios-arrow-back",
                text: "Back",
                previousTitleText: !0
            },
            form: {
                checkbox: "circle",
                toggle: "large"
            },
            scrolling: {
                jsScrolling: !1
            },
            spinner: {
                icon: "ios"
            },
            tabs: {
                style: "standard",
                position: "bottom"
            },
            templates: {
                maxPrefetch: 30
            }
        }), setPlatformConfig("ios", {}), setPlatformConfig("android", {
            views: {
                transition: "android",
                swipeBackEnabled: !1
            },
            navBar: {
                alignTitle: "left",
                positionPrimaryButtons: "right",
                positionSecondaryButtons: "right"
            },
            backButton: {
                icon: "ion-android-arrow-back",
                text: !1,
                previousTitleText: !1
            },
            form: {
                checkbox: "square",
                toggle: "small"
            },
            spinner: {
                icon: "android"
            },
            tabs: {
                style: "striped",
                position: "top"
            }
        }), setPlatformConfig("windowsphone", {
            spinner: {
                icon: "android"
            }
        }), provider.transitions = {
            views: {},
            navBar: {}
        }, provider.transitions.views.ios = function(enteringEle, leavingEle, direction, shouldAnimate) {
            function setStyles(ele, opacity, x, boxShadowOpacity) {
                var css = {};
                css[ionic.CSS.TRANSITION_DURATION] = d.shouldAnimate ? "" : 0, css.opacity = opacity, 
                boxShadowOpacity > -1 && (css.boxShadow = "0 0 10px rgba(0,0,0," + (d.shouldAnimate ? .45 * boxShadowOpacity : .3) + ")"), 
                css[ionic.CSS.TRANSFORM] = "translate3d(" + x + "%,0,0)", ionic.DomUtil.cachedStyles(ele, css);
            }
            var d = {
                run: function(step) {
                    "forward" == direction ? (setStyles(enteringEle, 1, 99 * (1 - step), 1 - step), 
                    setStyles(leavingEle, 1 - .1 * step, -33 * step, -1)) : "back" == direction ? (setStyles(enteringEle, 1 - .1 * (1 - step), -33 * (1 - step), -1), 
                    setStyles(leavingEle, 1, 100 * step, 1 - step)) : (setStyles(enteringEle, 1, 0, -1), 
                    setStyles(leavingEle, 0, 0, -1));
                },
                shouldAnimate: shouldAnimate && ("forward" == direction || "back" == direction)
            };
            return d;
        }, provider.transitions.navBar.ios = function(enteringHeaderBar, leavingHeaderBar, direction, shouldAnimate) {
            function setStyles(ctrl, opacity, titleX, backTextX) {
                var css = {};
                css[ionic.CSS.TRANSITION_DURATION] = d.shouldAnimate ? "" : "0ms", css.opacity = 1 === opacity ? "" : opacity, 
                ctrl.setCss("buttons-left", css), ctrl.setCss("buttons-right", css), ctrl.setCss("back-button", css), 
                css[ionic.CSS.TRANSFORM] = "translate3d(" + backTextX + "px,0,0)", ctrl.setCss("back-text", css), 
                css[ionic.CSS.TRANSFORM] = "translate3d(" + titleX + "px,0,0)", ctrl.setCss("title", css);
            }
            function enter(ctrlA, ctrlB, step) {
                if (ctrlA && ctrlB) {
                    var titleX = (ctrlA.titleTextX() + ctrlA.titleWidth()) * (1 - step), backTextX = ctrlB && (ctrlB.titleTextX() - ctrlA.backButtonTextLeft()) * (1 - step) || 0;
                    setStyles(ctrlA, step, titleX, backTextX);
                }
            }
            function leave(ctrlA, ctrlB, step) {
                if (ctrlA && ctrlB) {
                    var titleX = (-(ctrlA.titleTextX() - ctrlB.backButtonTextLeft()) - ctrlA.titleLeftRight()) * step;
                    setStyles(ctrlA, 1 - step, titleX, 0);
                }
            }
            var d = {
                run: function(step) {
                    var enteringHeaderCtrl = enteringHeaderBar.controller(), leavingHeaderCtrl = leavingHeaderBar && leavingHeaderBar.controller();
                    "back" == d.direction ? (leave(enteringHeaderCtrl, leavingHeaderCtrl, 1 - step), 
                    enter(leavingHeaderCtrl, enteringHeaderCtrl, 1 - step)) : (enter(enteringHeaderCtrl, leavingHeaderCtrl, step), 
                    leave(leavingHeaderCtrl, enteringHeaderCtrl, step));
                },
                direction: direction,
                shouldAnimate: shouldAnimate && ("forward" == direction || "back" == direction)
            };
            return d;
        }, provider.transitions.views.android = function(enteringEle, leavingEle, direction, shouldAnimate) {
            function setStyles(ele, x) {
                var css = {};
                css[ionic.CSS.TRANSITION_DURATION] = d.shouldAnimate ? "" : 0, css[ionic.CSS.TRANSFORM] = "translate3d(" + x + "%,0,0)", 
                ionic.DomUtil.cachedStyles(ele, css);
            }
            shouldAnimate = shouldAnimate && ("forward" == direction || "back" == direction);
            var d = {
                run: function(step) {
                    "forward" == direction ? (setStyles(enteringEle, 99 * (1 - step)), setStyles(leavingEle, -100 * step)) : "back" == direction ? (setStyles(enteringEle, -100 * (1 - step)), 
                    setStyles(leavingEle, 100 * step)) : (setStyles(enteringEle, 0), setStyles(leavingEle, 0));
                },
                shouldAnimate: shouldAnimate
            };
            return d;
        }, provider.transitions.navBar.android = function(enteringHeaderBar, leavingHeaderBar, direction, shouldAnimate) {
            function setStyles(ctrl, opacity) {
                if (ctrl) {
                    var css = {};
                    css.opacity = 1 === opacity ? "" : opacity, ctrl.setCss("buttons-left", css), ctrl.setCss("buttons-right", css), 
                    ctrl.setCss("back-button", css), ctrl.setCss("back-text", css), ctrl.setCss("title", css);
                }
            }
            return {
                run: function(step) {
                    setStyles(enteringHeaderBar.controller(), step), setStyles(leavingHeaderBar && leavingHeaderBar.controller(), 1 - step);
                },
                shouldAnimate: shouldAnimate && ("forward" == direction || "back" == direction)
            };
        }, provider.transitions.views.none = function(enteringEle, leavingEle) {
            return {
                run: function(step) {
                    provider.transitions.views.android(enteringEle, leavingEle, !1, !1).run(step);
                },
                shouldAnimate: !1
            };
        }, provider.transitions.navBar.none = function(enteringHeaderBar, leavingHeaderBar) {
            return {
                run: function(step) {
                    provider.transitions.navBar.ios(enteringHeaderBar, leavingHeaderBar, !1, !1).run(step), 
                    provider.transitions.navBar.android(enteringHeaderBar, leavingHeaderBar, !1, !1).run(step);
                },
                shouldAnimate: !1
            };
        }, provider.setPlatformConfig = setPlatformConfig, provider.$get = function() {
            return provider;
        };
    }).config([ "$compileProvider", function($compileProvider) {
        $compileProvider.aHrefSanitizationWhitelist(/^\s*(https?|sms|tel|geo|ftp|mailto|file|ghttps?|ms-appx-web|ms-appx|x-wmapp0):/), 
        $compileProvider.imgSrcSanitizationWhitelist(/^\s*(https?|ftp|file|content|blob|ms-appx|ms-appx-web|x-wmapp0):|data:image\//);
    } ]);
    var LOADING_TPL = '<div class="loading-container"><div class="loading"></div></div>', LOADING_HIDE_DEPRECATED = "$ionicLoading instance.hide() has been deprecated. Use $ionicLoading.hide().", LOADING_SHOW_DEPRECATED = "$ionicLoading instance.show() has been deprecated. Use $ionicLoading.show().", LOADING_SET_DEPRECATED = "$ionicLoading instance.setContent() has been deprecated. Use $ionicLoading.show({ template: 'my content' }).";
    IonicModule.constant("$ionicLoadingConfig", {
        template: "<ion-spinner></ion-spinner>"
    }).factory("$ionicLoading", [ "$ionicLoadingConfig", "$ionicBody", "$ionicTemplateLoader", "$ionicBackdrop", "$timeout", "$q", "$log", "$compile", "$ionicPlatform", "$rootScope", "IONIC_BACK_PRIORITY", function($ionicLoadingConfig, $ionicBody, $ionicTemplateLoader, $ionicBackdrop, $timeout, $q, $log, $compile, $ionicPlatform, $rootScope, IONIC_BACK_PRIORITY) {
        function getLoader() {
            return loaderInstance || (loaderInstance = $ionicTemplateLoader.compile({
                template: LOADING_TPL,
                appendTo: $ionicBody.get()
            }).then(function(self) {
                return self.show = function(options) {
                    var templatePromise = options.templateUrl ? $ionicTemplateLoader.load(options.templateUrl) : $q.when(options.template || options.content || "");
                    self.scope = options.scope || self.scope, self.isShown || (self.hasBackdrop = !options.noBackdrop && options.showBackdrop !== !1, 
                    self.hasBackdrop && ($ionicBackdrop.retain(), $ionicBackdrop.getElement().addClass("backdrop-loading"))), 
                    options.duration && ($timeout.cancel(self.durationTimeout), self.durationTimeout = $timeout(angular.bind(self, self.hide), +options.duration)), 
                    deregisterBackAction(), deregisterBackAction = $ionicPlatform.registerBackButtonAction(noop, IONIC_BACK_PRIORITY.loading), 
                    templatePromise.then(function(html) {
                        if (html) {
                            var loading = self.element.children();
                            loading.html(html), $compile(loading.contents())(self.scope);
                        }
                        self.isShown && (self.element.addClass("visible"), ionic.requestAnimationFrame(function() {
                            self.isShown && (self.element.addClass("active"), $ionicBody.addClass("loading-active"));
                        }));
                    }), self.isShown = !0;
                }, self.hide = function() {
                    deregisterBackAction(), self.isShown && (self.hasBackdrop && ($ionicBackdrop.release(), 
                    $ionicBackdrop.getElement().removeClass("backdrop-loading")), self.element.removeClass("active"), 
                    $ionicBody.removeClass("loading-active"), self.element.removeClass("visible"), ionic.requestAnimationFrame(function() {
                        !self.isShown && self.element.removeClass("visible");
                    })), $timeout.cancel(self.durationTimeout), self.isShown = !1;
                    var loading = self.element.children();
                    loading.html("");
                }, self;
            })), loaderInstance;
        }
        function showLoader(options) {
            options = extend({}, $ionicLoadingConfig || {}, options || {});
            var delay = options.delay || options.showDelay || 0;
            return deregisterStateListener1(), deregisterStateListener2(), options.hideOnStateChange && (deregisterStateListener1 = $rootScope.$on("$stateChangeSuccess", hideLoader), 
            deregisterStateListener2 = $rootScope.$on("$stateChangeError", hideLoader)), $timeout.cancel(loadingShowDelay), 
            loadingShowDelay = $timeout(noop, delay), loadingShowDelay.then(getLoader).then(function(loader) {
                return loader.show(options);
            }), {
                hide: function() {
                    return $log.error(LOADING_HIDE_DEPRECATED), hideLoader.apply(this, arguments);
                },
                show: function() {
                    return $log.error(LOADING_SHOW_DEPRECATED), showLoader.apply(this, arguments);
                },
                setContent: function(content) {
                    return $log.error(LOADING_SET_DEPRECATED), getLoader().then(function(loader) {
                        loader.show({
                            template: content
                        });
                    });
                }
            };
        }
        function hideLoader() {
            deregisterStateListener1(), deregisterStateListener2(), $timeout.cancel(loadingShowDelay), 
            getLoader().then(function(loader) {
                loader.hide();
            });
        }
        var loaderInstance, deregisterBackAction = noop, deregisterStateListener1 = noop, deregisterStateListener2 = noop, loadingShowDelay = $q.when();
        return {
            show: showLoader,
            hide: hideLoader,
            _getLoader: getLoader
        };
    } ]), IonicModule.factory("$ionicModal", [ "$rootScope", "$ionicBody", "$compile", "$timeout", "$ionicPlatform", "$ionicTemplateLoader", "$$q", "$log", "$ionicClickBlock", "$window", "IONIC_BACK_PRIORITY", function($rootScope, $ionicBody, $compile, $timeout, $ionicPlatform, $ionicTemplateLoader, $$q, $log, $ionicClickBlock, $window, IONIC_BACK_PRIORITY) {
        var ModalView = ionic.views.Modal.inherit({
            initialize: function(opts) {
                ionic.views.Modal.prototype.initialize.call(this, opts), this.animation = opts.animation || "slide-in-up";
            },
            show: function(target) {
                var self = this;
                if (self.scope.$$destroyed) return $log.error("Cannot call " + self.viewType + ".show() after remove(). Please create a new " + self.viewType + " instance."), 
                $$q.when();
                $ionicClickBlock.show(600), stack.add(self);
                var modalEl = jqLite(self.modalEl);
                self.el.classList.remove("hide"), $timeout(function() {
                    self._isShown && $ionicBody.addClass(self.viewType + "-open");
                }, 400, !1), self.el.parentElement || (modalEl.addClass(self.animation), $ionicBody.append(self.el));
                var scrollCtrl = modalEl.data("$$ionicScrollController");
                return scrollCtrl && scrollCtrl.resize(), target && self.positionView && (self.positionView(target, modalEl), 
                self._onWindowResize = function() {
                    self._isShown && self.positionView(target, modalEl);
                }, ionic.on("resize", self._onWindowResize, window)), modalEl.addClass("ng-enter active").removeClass("ng-leave ng-leave-active"), 
                self._isShown = !0, self._deregisterBackButton = $ionicPlatform.registerBackButtonAction(self.hardwareBackButtonClose ? angular.bind(self, self.hide) : noop, IONIC_BACK_PRIORITY.modal), 
                ionic.views.Modal.prototype.show.call(self), $timeout(function() {
                    self._isShown && (modalEl.addClass("ng-enter-active"), ionic.trigger("resize"), 
                    self.scope.$parent && self.scope.$parent.$broadcast(self.viewType + ".shown", self), 
                    self.el.classList.add("active"), self.scope.$broadcast("$ionicHeader.align"), self.scope.$broadcast("$ionicFooter.align"));
                }, 20), $timeout(function() {
                    self._isShown && (self.$el.on("touchmove", function(e) {
                        var isInScroll = ionic.DomUtil.getParentOrSelfWithClass(e.target, "scroll");
                        isInScroll || e.preventDefault();
                    }), self.$el.on("click", function(e) {
                        self.backdropClickToClose && e.target === self.el && stack.isHighest(self) && self.hide();
                    }));
                }, 400);
            },
            hide: function() {
                var self = this, modalEl = jqLite(self.modalEl);
                return $ionicClickBlock.show(600), stack.remove(self), self.el.classList.remove("active"), 
                modalEl.addClass("ng-leave"), $timeout(function() {
                    self._isShown || modalEl.addClass("ng-leave-active").removeClass("ng-enter ng-enter-active active");
                }, 20, !1), self.$el.off("click"), self._isShown = !1, self.scope.$parent && self.scope.$parent.$broadcast(self.viewType + ".hidden", self), 
                self._deregisterBackButton && self._deregisterBackButton(), ionic.views.Modal.prototype.hide.call(self), 
                self.positionView && ionic.off("resize", self._onWindowResize, window), $timeout(function() {
                    $ionicBody.removeClass(self.viewType + "-open"), self.el.classList.add("hide");
                }, self.hideDelay || 320);
            },
            remove: function() {
                var self = this;
                return self.scope.$parent && self.scope.$parent.$broadcast(self.viewType + ".removed", self), 
                self.hide().then(function() {
                    self.scope.$destroy(), self.$el.remove();
                });
            },
            isShown: function() {
                return !!this._isShown;
            }
        }), createModal = function(templateString, options) {
            var scope = options.scope && options.scope.$new() || $rootScope.$new(!0);
            options.viewType = options.viewType || "modal", extend(scope, {
                $hasHeader: !1,
                $hasSubheader: !1,
                $hasFooter: !1,
                $hasSubfooter: !1,
                $hasTabs: !1,
                $hasTabsTop: !1
            });
            var element = $compile("<ion-" + options.viewType + ">" + templateString + "</ion-" + options.viewType + ">")(scope);
            options.$el = element, options.el = element[0], options.modalEl = options.el.querySelector("." + options.viewType);
            var modal = new ModalView(options);
            return modal.scope = scope, options.scope || (scope[options.viewType] = modal), 
            modal;
        }, modalStack = [], stack = {
            add: function(modal) {
                modalStack.push(modal);
            },
            remove: function(modal) {
                var index = modalStack.indexOf(modal);
                index > -1 && index < modalStack.length && modalStack.splice(index, 1);
            },
            isHighest: function(modal) {
                var index = modalStack.indexOf(modal);
                return index > -1 && index === modalStack.length - 1;
            }
        };
        return {
            fromTemplate: function(templateString, options) {
                var modal = createModal(templateString, options || {});
                return modal;
            },
            fromTemplateUrl: function(url, options, _) {
                var cb;
                return angular.isFunction(options) && (cb = options, options = _), $ionicTemplateLoader.load(url).then(function(templateString) {
                    var modal = createModal(templateString, options || {});
                    return cb && cb(modal), modal;
                });
            },
            stack: stack
        };
    } ]), IonicModule.service("$ionicNavBarDelegate", ionic.DelegateService([ "align", "showBackButton", "showBar", "title", "changeTitle", "setTitle", "getTitle", "back", "getPreviousTitle" ])), 
    IonicModule.service("$ionicNavViewDelegate", ionic.DelegateService([ "clearCache" ])), 
    IonicModule.constant("IONIC_BACK_PRIORITY", {
        view: 100,
        sideMenu: 150,
        modal: 200,
        actionSheet: 300,
        popup: 400,
        loading: 500
    }).provider("$ionicPlatform", function() {
        return {
            $get: [ "$q", "$ionicScrollDelegate", function($q, $ionicScrollDelegate) {
                var self = {
                    onHardwareBackButton: function(cb) {
                        ionic.Platform.ready(function() {
                            document.addEventListener("backbutton", cb, !1);
                        });
                    },
                    offHardwareBackButton: function(fn) {
                        ionic.Platform.ready(function() {
                            document.removeEventListener("backbutton", fn);
                        });
                    },
                    $backButtonActions: {},
                    registerBackButtonAction: function(fn, priority, actionId) {
                        self._hasBackButtonHandler || (self.$backButtonActions = {}, self.onHardwareBackButton(self.hardwareBackButtonClick), 
                        self._hasBackButtonHandler = !0);
                        var action = {
                            id: actionId ? actionId : ionic.Utils.nextUid(),
                            priority: priority ? priority : 0,
                            fn: fn
                        };
                        return self.$backButtonActions[action.id] = action, function() {
                            delete self.$backButtonActions[action.id];
                        };
                    },
                    hardwareBackButtonClick: function(e) {
                        var priorityAction, actionId;
                        for (actionId in self.$backButtonActions) (!priorityAction || self.$backButtonActions[actionId].priority >= priorityAction.priority) && (priorityAction = self.$backButtonActions[actionId]);
                        return priorityAction ? (priorityAction.fn(e), priorityAction) : void 0;
                    },
                    is: function(type) {
                        return ionic.Platform.is(type);
                    },
                    on: function(type, cb) {
                        return ionic.Platform.ready(function() {
                            document.addEventListener(type, cb, !1);
                        }), function() {
                            ionic.Platform.ready(function() {
                                document.removeEventListener(type, cb);
                            });
                        };
                    },
                    ready: function(cb) {
                        var q = $q.defer();
                        return ionic.Platform.ready(function() {
                            q.resolve(), cb && cb();
                        }), q.promise;
                    }
                };
                return window.addEventListener("statusTap", function() {
                    $ionicScrollDelegate.scrollTop(!0);
                }), self;
            } ]
        };
    }), IonicModule.factory("$ionicPopover", [ "$ionicModal", "$ionicPosition", "$document", "$window", function($ionicModal, $ionicPosition, $document, $window) {
        function positionView(target, popoverEle) {
            var targetEle = jqLite(target.target || target), buttonOffset = $ionicPosition.offset(targetEle), popoverWidth = popoverEle.prop("offsetWidth"), popoverHeight = popoverEle.prop("offsetHeight"), bodyWidth = $window.innerWidth, bodyHeight = $window.innerHeight, popoverCSS = {
                left: buttonOffset.left + buttonOffset.width / 2 - popoverWidth / 2
            }, arrowEle = jqLite(popoverEle[0].querySelector(".popover-arrow"));
            popoverCSS.left < POPOVER_BODY_PADDING ? popoverCSS.left = POPOVER_BODY_PADDING : popoverCSS.left + popoverWidth + POPOVER_BODY_PADDING > bodyWidth && (popoverCSS.left = bodyWidth - popoverWidth - POPOVER_BODY_PADDING), 
            buttonOffset.top + buttonOffset.height + popoverHeight > bodyHeight && buttonOffset.top - popoverHeight > 0 ? (popoverCSS.top = buttonOffset.top - popoverHeight, 
            popoverEle.addClass("popover-bottom")) : (popoverCSS.top = buttonOffset.top + buttonOffset.height, 
            popoverEle.removeClass("popover-bottom")), arrowEle.css({
                left: buttonOffset.left + buttonOffset.width / 2 - arrowEle.prop("offsetWidth") / 2 - popoverCSS.left + "px"
            }), popoverEle.css({
                top: popoverCSS.top + "px",
                left: popoverCSS.left + "px",
                marginLeft: "0",
                opacity: "1"
            });
        }
        var POPOVER_BODY_PADDING = 6, POPOVER_OPTIONS = {
            viewType: "popover",
            hideDelay: 1,
            animation: "none",
            positionView: positionView
        };
        return {
            fromTemplate: function(templateString, options) {
                return $ionicModal.fromTemplate(templateString, ionic.Utils.extend({}, POPOVER_OPTIONS, options));
            },
            fromTemplateUrl: function(url, options) {
                return $ionicModal.fromTemplateUrl(url, ionic.Utils.extend({}, POPOVER_OPTIONS, options));
            }
        };
    } ]);
    var POPUP_TPL = '<div class="popup-container" ng-class="cssClass"><div class="popup"><div class="popup-head"><h3 class="popup-title" ng-bind-html="title"></h3><h5 class="popup-sub-title" ng-bind-html="subTitle" ng-if="subTitle"></h5></div><div class="popup-body"></div><div class="popup-buttons" ng-show="buttons.length"><button ng-repeat="button in buttons" ng-click="$buttonTapped(button, $event)" class="button" ng-class="button.type || \'button-default\'" ng-bind-html="button.text"></button></div></div></div>';
    IonicModule.factory("$ionicPopup", [ "$ionicTemplateLoader", "$ionicBackdrop", "$q", "$timeout", "$rootScope", "$ionicBody", "$compile", "$ionicPlatform", "$ionicModal", "IONIC_BACK_PRIORITY", function($ionicTemplateLoader, $ionicBackdrop, $q, $timeout, $rootScope, $ionicBody, $compile, $ionicPlatform, $ionicModal, IONIC_BACK_PRIORITY) {
        function createPopup(options) {
            options = extend({
                scope: null,
                title: "",
                buttons: []
            }, options || {});
            var self = {};
            return self.scope = (options.scope || $rootScope).$new(), self.element = jqLite(POPUP_TPL), 
            self.responseDeferred = $q.defer(), $ionicBody.get().appendChild(self.element[0]), 
            $compile(self.element)(self.scope), extend(self.scope, {
                title: options.title,
                buttons: options.buttons,
                subTitle: options.subTitle,
                cssClass: options.cssClass,
                $buttonTapped: function(button, event) {
                    var result = (button.onTap || noop).apply(self, [ event ]);
                    event = event.originalEvent || event, event.defaultPrevented || self.responseDeferred.resolve(result);
                }
            }), $q.when(options.templateUrl ? $ionicTemplateLoader.load(options.templateUrl) : options.template || options.content || "").then(function(template) {
                var popupBody = jqLite(self.element[0].querySelector(".popup-body"));
                template ? (popupBody.html(template), $compile(popupBody.contents())(self.scope)) : popupBody.remove();
            }), self.show = function() {
                self.isShown || self.removed || ($ionicModal.stack.add(self), self.isShown = !0, 
                ionic.requestAnimationFrame(function() {
                    self.isShown && (self.element.removeClass("popup-hidden"), self.element.addClass("popup-showing active"), 
                    focusInput(self.element));
                }));
            }, self.hide = function(callback) {
                return callback = callback || noop, self.isShown ? ($ionicModal.stack.remove(self), 
                self.isShown = !1, self.element.removeClass("active"), self.element.addClass("popup-hidden"), 
                void $timeout(callback, 250, !1)) : callback();
            }, self.remove = function() {
                self.removed || (self.hide(function() {
                    self.element.remove(), self.scope.$destroy();
                }), self.removed = !0);
            }, self;
        }
        function onHardwareBackButton() {
            var last = popupStack[popupStack.length - 1];
            last && last.responseDeferred.resolve();
        }
        function showPopup(options) {
            function doShow() {
                popupStack.push(popup), $timeout(popup.show, showDelay, !1), popup.responseDeferred.promise.then(function(result) {
                    var index = popupStack.indexOf(popup);
                    return -1 !== index && popupStack.splice(index, 1), popup.remove(), popupStack.length > 0 ? popupStack[popupStack.length - 1].show() : ($ionicBackdrop.release(), 
                    $timeout(function() {
                        popupStack.length || $ionicBody.removeClass("popup-open");
                    }, 400, !1), ($ionicPopup._backButtonActionDone || noop)()), result;
                });
            }
            var popup = $ionicPopup._createPopup(options), showDelay = 0;
            return popupStack.length > 0 ? (showDelay = config.stackPushDelay, $timeout(popupStack[popupStack.length - 1].hide, showDelay, !1)) : ($ionicBody.addClass("popup-open"), 
            $ionicBackdrop.retain(), $ionicPopup._backButtonActionDone = $ionicPlatform.registerBackButtonAction(onHardwareBackButton, IONIC_BACK_PRIORITY.popup)), 
            popup.responseDeferred.promise.close = function(result) {
                popup.removed || popup.responseDeferred.resolve(result);
            }, popup.responseDeferred.notify({
                close: popup.responseDeferred.close
            }), doShow(), popup.responseDeferred.promise;
        }
        function focusInput(element) {
            var focusOn = element[0].querySelector("[autofocus]");
            focusOn && focusOn.focus();
        }
        function showAlert(opts) {
            return showPopup(extend({
                buttons: [ {
                    text: opts.okText || "OK",
                    type: opts.okType || "button-positive",
                    onTap: function() {
                        return !0;
                    }
                } ]
            }, opts || {}));
        }
        function showConfirm(opts) {
            return showPopup(extend({
                buttons: [ {
                    text: opts.cancelText || "Cancel",
                    type: opts.cancelType || "button-default",
                    onTap: function() {
                        return !1;
                    }
                }, {
                    text: opts.okText || "OK",
                    type: opts.okType || "button-positive",
                    onTap: function() {
                        return !0;
                    }
                } ]
            }, opts || {}));
        }
        function showPrompt(opts) {
            var scope = $rootScope.$new(!0);
            scope.data = {}, scope.data.fieldtype = opts.inputType ? opts.inputType : "text", 
            scope.data.response = opts.defaultText ? opts.defaultText : "", scope.data.placeholder = opts.inputPlaceholder ? opts.inputPlaceholder : "", 
            scope.data.maxlength = opts.maxLength ? parseInt(opts.maxLength) : "";
            var text = "";
            return opts.template && /<[a-z][\s\S]*>/i.test(opts.template) === !1 && (text = "<span>" + opts.template + "</span>", 
            delete opts.template), showPopup(extend({
                template: text + '<input ng-model="data.response" type="{{ data.fieldtype }}"maxlength="{{ data.maxlength }}"placeholder="{{ data.placeholder }}">',
                scope: scope,
                buttons: [ {
                    text: opts.cancelText || "Cancel",
                    type: opts.cancelType || "button-default",
                    onTap: function() {}
                }, {
                    text: opts.okText || "OK",
                    type: opts.okType || "button-positive",
                    onTap: function() {
                        return scope.data.response || "";
                    }
                } ]
            }, opts || {}));
        }
        var config = {
            stackPushDelay: 75
        }, popupStack = [], $ionicPopup = {
            show: showPopup,
            alert: showAlert,
            confirm: showConfirm,
            prompt: showPrompt,
            _createPopup: createPopup,
            _popupStack: popupStack
        };
        return $ionicPopup;
    } ]), IonicModule.factory("$ionicPosition", [ "$document", "$window", function($document, $window) {
        function getStyle(el, cssprop) {
            return el.currentStyle ? el.currentStyle[cssprop] : $window.getComputedStyle ? $window.getComputedStyle(el)[cssprop] : el.style[cssprop];
        }
        function isStaticPositioned(element) {
            return "static" === (getStyle(element, "position") || "static");
        }
        var parentOffsetEl = function(element) {
            for (var docDomEl = $document[0], offsetParent = element.offsetParent || docDomEl; offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent); ) offsetParent = offsetParent.offsetParent;
            return offsetParent || docDomEl;
        };
        return {
            position: function(element) {
                var elBCR = this.offset(element), offsetParentBCR = {
                    top: 0,
                    left: 0
                }, offsetParentEl = parentOffsetEl(element[0]);
                offsetParentEl != $document[0] && (offsetParentBCR = this.offset(jqLite(offsetParentEl)), 
                offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop, offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft);
                var boundingClientRect = element[0].getBoundingClientRect();
                return {
                    width: boundingClientRect.width || element.prop("offsetWidth"),
                    height: boundingClientRect.height || element.prop("offsetHeight"),
                    top: elBCR.top - offsetParentBCR.top,
                    left: elBCR.left - offsetParentBCR.left
                };
            },
            offset: function(element) {
                var boundingClientRect = element[0].getBoundingClientRect();
                return {
                    width: boundingClientRect.width || element.prop("offsetWidth"),
                    height: boundingClientRect.height || element.prop("offsetHeight"),
                    top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
                    left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
                };
            }
        };
    } ]), IonicModule.service("$ionicScrollDelegate", ionic.DelegateService([ "resize", "scrollTop", "scrollBottom", "scrollTo", "scrollBy", "zoomTo", "zoomBy", "getScrollPosition", "anchorScroll", "freezeScroll", "freezeAllScrolls", "getScrollView" ])), 
    IonicModule.service("$ionicSideMenuDelegate", ionic.DelegateService([ "toggleLeft", "toggleRight", "getOpenRatio", "isOpen", "isOpenLeft", "isOpenRight", "canDragContent", "edgeDragThreshold" ])), 
    IonicModule.service("$ionicSlideBoxDelegate", ionic.DelegateService([ "update", "slide", "select", "enableSlide", "previous", "next", "stop", "autoPlay", "start", "currentIndex", "selected", "slidesCount", "count", "loop" ])), 
    IonicModule.service("$ionicTabsDelegate", ionic.DelegateService([ "select", "selectedIndex", "showBar" ])), 
    function() {
        var templatesToCache = [];
        IonicModule.factory("$ionicTemplateCache", [ "$http", "$templateCache", "$timeout", function($http, $templateCache, $timeout) {
            function $ionicTemplateCache(templates) {
                return "undefined" == typeof templates ? run() : (isString(templates) && (templates = [ templates ]), 
                forEach(templates, function(template) {
                    toCache.push(template);
                }), void (hasRun && run()));
            }
            function run() {
                var template;
                if ($ionicTemplateCache._runCount++, hasRun = !0, 0 !== toCache.length) {
                    for (var i = 0; 4 > i && (template = toCache.pop()); ) isString(template) && $http.get(template, {
                        cache: $templateCache
                    }), i++;
                    toCache.length && $timeout(run, 1e3);
                }
            }
            var hasRun, toCache = templatesToCache;
            return $ionicTemplateCache._runCount = 0, $ionicTemplateCache;
        } ]).config([ "$stateProvider", "$ionicConfigProvider", function($stateProvider, $ionicConfigProvider) {
            var stateProviderState = $stateProvider.state;
            $stateProvider.state = function(stateName, definition) {
                if ("object" == typeof definition) {
                    var enabled = definition.prefetchTemplate !== !1 && templatesToCache.length < $ionicConfigProvider.templates.maxPrefetch();
                    if (enabled && isString(definition.templateUrl) && templatesToCache.push(definition.templateUrl), 
                    angular.isObject(definition.views)) for (var key in definition.views) enabled = definition.views[key].prefetchTemplate !== !1 && templatesToCache.length < $ionicConfigProvider.templates.maxPrefetch(), 
                    enabled && isString(definition.views[key].templateUrl) && templatesToCache.push(definition.views[key].templateUrl);
                }
                return stateProviderState.call($stateProvider, stateName, definition);
            };
        } ]).run([ "$ionicTemplateCache", function($ionicTemplateCache) {
            $ionicTemplateCache();
        } ]);
    }(), IonicModule.factory("$ionicTemplateLoader", [ "$compile", "$controller", "$http", "$q", "$rootScope", "$templateCache", function($compile, $controller, $http, $q, $rootScope, $templateCache) {
        function fetchTemplate(url) {
            return $http.get(url, {
                cache: $templateCache
            }).then(function(response) {
                return response.data && response.data.trim();
            });
        }
        function loadAndCompile(options) {
            options = extend({
                template: "",
                templateUrl: "",
                scope: null,
                controller: null,
                locals: {},
                appendTo: null
            }, options || {});
            var templatePromise = options.templateUrl ? this.load(options.templateUrl) : $q.when(options.template);
            return templatePromise.then(function(template) {
                var controller, scope = options.scope || $rootScope.$new(), element = jqLite("<div>").html(template).contents();
                return options.controller && (controller = $controller(options.controller, extend(options.locals, {
                    $scope: scope
                })), element.children().data("$ngControllerController", controller)), options.appendTo && jqLite(options.appendTo).append(element), 
                $compile(element)(scope), {
                    element: element,
                    scope: scope
                };
            });
        }
        return {
            load: fetchTemplate,
            compile: loadAndCompile
        };
    } ]), IonicModule.factory("$ionicViewService", [ "$ionicHistory", "$log", function($ionicHistory, $log) {
        function warn(oldMethod, newMethod) {
            $log.warn("$ionicViewService" + oldMethod + " is deprecated, please use $ionicHistory" + newMethod + " instead: http://ionicframework.com/docs/nightly/api/service/$ionicHistory/");
        }
        warn("", "");
        var methodsMap = {
            getCurrentView: "currentView",
            getBackView: "backView",
            getForwardView: "forwardView",
            getCurrentStateName: "currentStateName",
            nextViewOptions: "nextViewOptions",
            clearHistory: "clearHistory"
        };
        return forEach(methodsMap, function(newMethod, oldMethod) {
            methodsMap[oldMethod] = function() {
                return warn("." + oldMethod, "." + newMethod), $ionicHistory[newMethod].apply(this, arguments);
            };
        }), methodsMap;
    } ]), IonicModule.factory("$ionicViewSwitcher", [ "$timeout", "$document", "$q", "$ionicClickBlock", "$ionicConfig", "$ionicNavBarDelegate", function($timeout, $document, $q, $ionicClickBlock, $ionicConfig, $ionicNavBarDelegate) {
        function getViewElementIdentifier(locals, view) {
            return viewState(locals)["abstract"] ? viewState(locals).name : view ? view.stateId || view.viewId : ionic.Utils.nextUid();
        }
        function viewState(locals) {
            return locals && locals.$$state && locals.$$state.self || {};
        }
        function getTransitionData(viewLocals, enteringEle, direction, view) {
            var state = viewState(viewLocals), viewTransition = nextTransition || cachedAttr(enteringEle, "view-transition") || state.viewTransition || $ionicConfig.views.transition() || "ios", navBarTransition = $ionicConfig.navBar.transition();
            return direction = nextDirection || cachedAttr(enteringEle, "view-direction") || state.viewDirection || direction || "none", 
            extend(getViewData(view), {
                transition: viewTransition,
                navBarTransition: "view" === navBarTransition ? viewTransition : navBarTransition,
                direction: direction,
                shouldAnimate: "none" !== viewTransition && "none" !== direction
            });
        }
        function getViewData(view) {
            return view = view || {}, {
                viewId: view.viewId,
                historyId: view.historyId,
                stateId: view.stateId,
                stateName: view.stateName,
                stateParams: view.stateParams
            };
        }
        function navViewAttr(ele, value) {
            return arguments.length > 1 ? void cachedAttr(ele, NAV_VIEW_ATTR, value) : cachedAttr(ele, NAV_VIEW_ATTR);
        }
        function destroyViewEle(ele) {
            if (ele && ele.length) {
                var viewScope = ele.scope();
                viewScope && (viewScope.$emit("$ionicView.unloaded", ele.data(DATA_VIEW)), viewScope.$destroy()), 
                ele.remove();
            }
        }
        var nextTransition, nextDirection, TRANSITIONEND_EVENT = "webkitTransitionEnd transitionend", DATA_NO_CACHE = "$noCache", DATA_DESTROY_ELE = "$destroyEle", DATA_ELE_IDENTIFIER = "$eleId", DATA_VIEW_ACCESSED = "$accessed", DATA_FALLBACK_TIMER = "$fallbackTimer", DATA_VIEW = "$viewData", NAV_VIEW_ATTR = "nav-view", VIEW_STATUS_ACTIVE = "active", VIEW_STATUS_CACHED = "cached", VIEW_STATUS_STAGED = "stage", transitionCounter = 0;
        ionic.transition = ionic.transition || {}, ionic.transition.isActive = !1;
        var isActiveTimer, cachedAttr = ionic.DomUtil.cachedAttr, transitionPromises = [], defaultTimeout = 1100, ionicViewSwitcher = {
            create: function(navViewCtrl, viewLocals, enteringView, leavingView, renderStart, renderEnd) {
                var enteringEle, leavingEle, alreadyInDom, transitionId = ++transitionCounter, switcher = {
                    init: function(registerData, callback) {
                        ionicViewSwitcher.isTransitioning(!0), switcher.loadViewElements(registerData), 
                        switcher.render(registerData, function() {
                            callback && callback();
                        });
                    },
                    loadViewElements: function(registerData) {
                        var x, l, viewEle, viewElements = navViewCtrl.getViewElements(), enteringEleIdentifier = getViewElementIdentifier(viewLocals, enteringView), navViewActiveEleId = navViewCtrl.activeEleId();
                        for (x = 0, l = viewElements.length; l > x && (viewEle = viewElements.eq(x), viewEle.data(DATA_ELE_IDENTIFIER) === enteringEleIdentifier ? viewEle.data(DATA_NO_CACHE) ? (viewEle.data(DATA_ELE_IDENTIFIER, enteringEleIdentifier + ionic.Utils.nextUid()), 
                        viewEle.data(DATA_DESTROY_ELE, !0)) : enteringEle = viewEle : isDefined(navViewActiveEleId) && viewEle.data(DATA_ELE_IDENTIFIER) === navViewActiveEleId && (leavingEle = viewEle), 
                        !enteringEle || !leavingEle); x++) ;
                        alreadyInDom = !!enteringEle, alreadyInDom || (enteringEle = registerData.ele || ionicViewSwitcher.createViewEle(viewLocals), 
                        enteringEle.data(DATA_ELE_IDENTIFIER, enteringEleIdentifier)), renderEnd && navViewCtrl.activeEleId(enteringEleIdentifier), 
                        registerData.ele = null;
                    },
                    render: function(registerData, callback) {
                        if (alreadyInDom) ionic.Utils.reconnectScope(enteringEle.scope()); else {
                            navViewAttr(enteringEle, VIEW_STATUS_STAGED);
                            var enteringData = getTransitionData(viewLocals, enteringEle, registerData.direction, enteringView), transitionFn = $ionicConfig.transitions.views[enteringData.transition] || $ionicConfig.transitions.views.none;
                            transitionFn(enteringEle, null, enteringData.direction, !0).run(0), enteringEle.data(DATA_VIEW, {
                                viewId: enteringData.viewId,
                                historyId: enteringData.historyId,
                                stateName: enteringData.stateName,
                                stateParams: enteringData.stateParams
                            }), (viewState(viewLocals).cache === !1 || "false" === viewState(viewLocals).cache || "false" == enteringEle.attr("cache-view") || 0 === $ionicConfig.views.maxCache()) && enteringEle.data(DATA_NO_CACHE, !0);
                            var viewScope = navViewCtrl.appendViewElement(enteringEle, viewLocals);
                            delete enteringData.direction, delete enteringData.transition, viewScope.$emit("$ionicView.loaded", enteringData);
                        }
                        enteringEle.data(DATA_VIEW_ACCESSED, Date.now()), callback && callback();
                    },
                    transition: function(direction, enableBack, allowAnimate) {
                        function onReflow() {
                            navViewAttr(enteringEle, viewTransition.shouldAnimate ? "entering" : VIEW_STATUS_ACTIVE), 
                            navViewAttr(leavingEle, viewTransition.shouldAnimate ? "leaving" : VIEW_STATUS_CACHED), 
                            viewTransition.run(1), $ionicNavBarDelegate._instances.forEach(function(instance) {
                                instance.triggerTransitionStart(transitionId);
                            }), viewTransition.shouldAnimate || transitionComplete();
                        }
                        function completeOnTransitionEnd(ev) {
                            ev.target === this && transitionComplete();
                        }
                        function transitionComplete() {
                            transitionComplete.x || (transitionComplete.x = !0, enteringEle.off(TRANSITIONEND_EVENT, completeOnTransitionEnd), 
                            $timeout.cancel(enteringEle.data(DATA_FALLBACK_TIMER)), leavingEle && $timeout.cancel(leavingEle.data(DATA_FALLBACK_TIMER)), 
                            deferred && deferred.resolve(navViewCtrl), transitionId === transitionCounter && ($q.all(transitionPromises).then(ionicViewSwitcher.transitionEnd), 
                            switcher.emit("after", enteringData, leavingData), switcher.cleanup(enteringData)), 
                            $ionicNavBarDelegate._instances.forEach(function(instance) {
                                instance.triggerTransitionEnd();
                            }), nextTransition = nextDirection = enteringView = leavingView = enteringEle = leavingEle = null);
                        }
                        function cancelOnTransitionEnd(ev) {
                            ev.target === this && cancelTransition();
                        }
                        function cancelTransition() {
                            navViewAttr(enteringEle, VIEW_STATUS_CACHED), navViewAttr(leavingEle, VIEW_STATUS_ACTIVE), 
                            enteringEle.off(TRANSITIONEND_EVENT, cancelOnTransitionEnd), $timeout.cancel(enteringEle.data(DATA_FALLBACK_TIMER)), 
                            ionicViewSwitcher.transitionEnd([ navViewCtrl ]);
                        }
                        var deferred, enteringData = getTransitionData(viewLocals, enteringEle, direction, enteringView), leavingData = extend(extend({}, enteringData), getViewData(leavingView));
                        enteringData.transitionId = leavingData.transitionId = transitionId, enteringData.fromCache = !!alreadyInDom, 
                        enteringData.enableBack = !!enableBack, enteringData.renderStart = renderStart, 
                        enteringData.renderEnd = renderEnd, cachedAttr(enteringEle.parent(), "nav-view-transition", enteringData.transition), 
                        cachedAttr(enteringEle.parent(), "nav-view-direction", enteringData.direction), 
                        $timeout.cancel(enteringEle.data(DATA_FALLBACK_TIMER));
                        var transitionFn = $ionicConfig.transitions.views[enteringData.transition] || $ionicConfig.transitions.views.none, viewTransition = transitionFn(enteringEle, leavingEle, enteringData.direction, enteringData.shouldAnimate && allowAnimate && renderEnd);
                        if (viewTransition.shouldAnimate && (enteringEle.on(TRANSITIONEND_EVENT, completeOnTransitionEnd), 
                        enteringEle.data(DATA_FALLBACK_TIMER, $timeout(transitionComplete, defaultTimeout)), 
                        $ionicClickBlock.show(defaultTimeout)), renderStart && (switcher.emit("before", enteringData, leavingData), 
                        navViewAttr(enteringEle, VIEW_STATUS_STAGED), viewTransition.run(0)), renderEnd && (deferred = $q.defer(), 
                        transitionPromises.push(deferred.promise)), renderStart && renderEnd) $timeout(function() {
                            ionic.requestAnimationFrame(onReflow);
                        }); else {
                            if (!renderEnd) return navViewAttr(enteringEle, "entering"), navViewAttr(leavingEle, "leaving"), 
                            {
                                run: viewTransition.run,
                                cancel: function(shouldAnimate) {
                                    shouldAnimate ? (enteringEle.on(TRANSITIONEND_EVENT, cancelOnTransitionEnd), enteringEle.data(DATA_FALLBACK_TIMER, $timeout(cancelTransition, defaultTimeout)), 
                                    $ionicClickBlock.show(defaultTimeout)) : cancelTransition(), viewTransition.shouldAnimate = shouldAnimate, 
                                    viewTransition.run(0), viewTransition = null;
                                }
                            };
                            renderEnd && onReflow();
                        }
                    },
                    emit: function(step, enteringData, leavingData) {
                        var enteringScope = enteringEle.scope(), leavingScope = leavingEle && leavingEle.scope();
                        "after" == step && (enteringScope && enteringScope.$emit("$ionicView.enter", enteringData), 
                        leavingScope ? leavingScope.$emit("$ionicView.leave", leavingData) : enteringScope && leavingData && leavingData.viewId && enteringScope.$emit("$ionicNavView.leave", leavingData)), 
                        enteringScope && enteringScope.$emit("$ionicView." + step + "Enter", enteringData), 
                        leavingScope ? leavingScope.$emit("$ionicView." + step + "Leave", leavingData) : enteringScope && leavingData && leavingData.viewId && enteringScope.$emit("$ionicNavView." + step + "Leave", leavingData);
                    },
                    cleanup: function(transData) {
                        leavingEle && "back" == transData.direction && !$ionicConfig.views.forwardCache() && destroyViewEle(leavingEle);
                        var x, viewElement, removableEle, viewElements = navViewCtrl.getViewElements(), viewElementsLength = viewElements.length, removeOldestAccess = viewElementsLength - 1 > $ionicConfig.views.maxCache(), oldestAccess = Date.now();
                        for (x = 0; viewElementsLength > x; x++) viewElement = viewElements.eq(x), removeOldestAccess && viewElement.data(DATA_VIEW_ACCESSED) < oldestAccess ? (oldestAccess = viewElement.data(DATA_VIEW_ACCESSED), 
                        removableEle = viewElements.eq(x)) : viewElement.data(DATA_DESTROY_ELE) && navViewAttr(viewElement) != VIEW_STATUS_ACTIVE && destroyViewEle(viewElement);
                        destroyViewEle(removableEle), enteringEle.data(DATA_NO_CACHE) && enteringEle.data(DATA_DESTROY_ELE, !0);
                    },
                    enteringEle: function() {
                        return enteringEle;
                    },
                    leavingEle: function() {
                        return leavingEle;
                    }
                };
                return switcher;
            },
            transitionEnd: function(navViewCtrls) {
                forEach(navViewCtrls, function(navViewCtrl) {
                    navViewCtrl.transitionEnd();
                }), ionicViewSwitcher.isTransitioning(!1), $ionicClickBlock.hide(), transitionPromises = [];
            },
            nextTransition: function(val) {
                nextTransition = val;
            },
            nextDirection: function(val) {
                nextDirection = val;
            },
            isTransitioning: function(val) {
                return arguments.length && (ionic.transition.isActive = !!val, $timeout.cancel(isActiveTimer), 
                val && (isActiveTimer = $timeout(function() {
                    ionicViewSwitcher.isTransitioning(!1);
                }, 999))), ionic.transition.isActive;
            },
            createViewEle: function(viewLocals) {
                var containerEle = $document[0].createElement("div");
                return viewLocals && viewLocals.$template && (containerEle.innerHTML = viewLocals.$template, 
                1 === containerEle.children.length) ? (containerEle.children[0].classList.add("pane"), 
                jqLite(containerEle.children[0])) : (containerEle.className = "pane", jqLite(containerEle));
            },
            viewEleIsActive: function(viewEle, isActiveAttr) {
                navViewAttr(viewEle, isActiveAttr ? VIEW_STATUS_ACTIVE : VIEW_STATUS_CACHED);
            },
            getTransitionData: getTransitionData,
            navViewAttr: navViewAttr,
            destroyViewEle: destroyViewEle
        };
        return ionicViewSwitcher;
    } ]), angular.module("ngIOS9UIWebViewPatch", [ "ng" ]).config([ "$provide", function($provide) {
        "use strict";
        $provide.decorator("$browser", [ "$delegate", "$window", function($delegate, $window) {
            function isIOS9UIWebView(userAgent) {
                return /(iPhone|iPad|iPod).* OS 9_\d/.test(userAgent) && !/Version\/9\./.test(userAgent);
            }
            function applyIOS9Shim(browser) {
                function clearPendingLocationUrl() {
                    pendingLocationUrl = null;
                }
                var pendingLocationUrl = null, originalUrlFn = browser.url;
                return browser.url = function() {
                    return arguments.length ? (pendingLocationUrl = arguments[0], originalUrlFn.apply(browser, arguments)) : pendingLocationUrl || originalUrlFn.apply(browser, arguments);
                }, window.addEventListener("popstate", clearPendingLocationUrl, !1), window.addEventListener("hashchange", clearPendingLocationUrl, !1), 
                browser;
            }
            return isIOS9UIWebView($window.navigator.userAgent) ? applyIOS9Shim($delegate) : $delegate;
        } ]);
    } ]), IonicModule.config([ "$provide", function($provide) {
        $provide.decorator("$compile", [ "$delegate", function($compile) {
            return $compile.$$addScopeInfo = function($element, scope, isolated, noTemplate) {
                var dataName = isolated ? noTemplate ? "$isolateScopeNoTemplate" : "$isolateScope" : "$scope";
                $element.data(dataName, scope);
            }, $compile;
        } ]);
    } ]), IonicModule.config([ "$provide", function($provide) {
        function $LocationDecorator($location, $timeout) {
            return $location.__hash = $location.hash, $location.hash = function(value) {
                return isDefined(value) && value.length > 0 && $timeout(function() {
                    var scroll = document.querySelector(".scroll-content");
                    scroll && (scroll.scrollTop = 0);
                }, 0, !1), $location.__hash(value);
            }, $location;
        }
        $provide.decorator("$location", [ "$delegate", "$timeout", $LocationDecorator ]);
    } ]), IonicModule.controller("$ionicHeaderBar", [ "$scope", "$element", "$attrs", "$q", "$ionicConfig", "$ionicHistory", function($scope, $element, $attrs, $q, $ionicConfig, $ionicHistory) {
        function getEle(className) {
            return eleCache[className] || (eleCache[className] = $element[0].querySelector("." + className)), 
            eleCache[className];
        }
        var TITLE = "title", BACK_TEXT = "back-text", BACK_BUTTON = "back-button", DEFAULT_TITLE = "default-title", PREVIOUS_TITLE = "previous-title", HIDE = "hide", self = this, titleText = "", previousTitleText = "", titleLeft = 0, titleRight = 0, titleCss = "", isBackEnabled = !1, isBackShown = !0, isNavBackShown = !0, isBackElementShown = !1, titleTextWidth = 0;
        self.beforeEnter = function(viewData) {
            $scope.$broadcast("$ionicView.beforeEnter", viewData);
        }, self.title = function(newTitleText) {
            return arguments.length && newTitleText !== titleText && (getEle(TITLE).innerHTML = newTitleText, 
            titleText = newTitleText, titleTextWidth = 0), titleText;
        }, self.enableBack = function(shouldEnable, disableReset) {
            return arguments.length && (isBackEnabled = shouldEnable, disableReset || self.updateBackButton()), 
            isBackEnabled;
        }, self.showBack = function(shouldShow, disableReset) {
            return arguments.length && (isBackShown = shouldShow, disableReset || self.updateBackButton()), 
            isBackShown;
        }, self.showNavBack = function(shouldShow) {
            isNavBackShown = shouldShow, self.updateBackButton();
        }, self.updateBackButton = function() {
            var ele;
            (isBackShown && isNavBackShown && isBackEnabled) !== isBackElementShown && (isBackElementShown = isBackShown && isNavBackShown && isBackEnabled, 
            ele = getEle(BACK_BUTTON), ele && ele.classList[isBackElementShown ? "remove" : "add"](HIDE)), 
            isBackEnabled && (ele = ele || getEle(BACK_BUTTON), ele && (self.backButtonIcon !== $ionicConfig.backButton.icon() && (ele = getEle(BACK_BUTTON + " .icon"), 
            ele && (self.backButtonIcon = $ionicConfig.backButton.icon(), ele.className = "icon " + self.backButtonIcon)), 
            self.backButtonText !== $ionicConfig.backButton.text() && (ele = getEle(BACK_BUTTON + " .back-text"), 
            ele && (ele.textContent = self.backButtonText = $ionicConfig.backButton.text()))));
        }, self.titleTextWidth = function() {
            if (!titleTextWidth) {
                var bounds = ionic.DomUtil.getTextBounds(getEle(TITLE));
                titleTextWidth = Math.min(bounds && bounds.width || 30);
            }
            return titleTextWidth;
        }, self.titleWidth = function() {
            var titleWidth = self.titleTextWidth(), offsetWidth = getEle(TITLE).offsetWidth;
            return titleWidth > offsetWidth && (titleWidth = offsetWidth + (titleLeft - titleRight - 5)), 
            titleWidth;
        }, self.titleTextX = function() {
            return $element[0].offsetWidth / 2 - self.titleWidth() / 2;
        }, self.titleLeftRight = function() {
            return titleLeft - titleRight;
        }, self.backButtonTextLeft = function() {
            for (var offsetLeft = 0, ele = getEle(BACK_TEXT); ele; ) offsetLeft += ele.offsetLeft, 
            ele = ele.parentElement;
            return offsetLeft;
        }, self.resetBackButton = function(viewData) {
            if ($ionicConfig.backButton.previousTitleText()) {
                var previousTitleEle = getEle(PREVIOUS_TITLE);
                if (previousTitleEle) {
                    previousTitleEle.classList.remove(HIDE);
                    var view = viewData && $ionicHistory.getViewById(viewData.viewId), newPreviousTitleText = $ionicHistory.backTitle(view);
                    newPreviousTitleText !== previousTitleText && (previousTitleText = previousTitleEle.innerHTML = newPreviousTitleText);
                }
                var defaultTitleEle = getEle(DEFAULT_TITLE);
                defaultTitleEle && defaultTitleEle.classList.remove(HIDE);
            }
        }, self.align = function(textAlign) {
            var titleEle = getEle(TITLE);
            textAlign = textAlign || $attrs.alignTitle || $ionicConfig.navBar.alignTitle();
            var widths = self.calcWidths(textAlign, !1);
            if (isBackShown && previousTitleText && $ionicConfig.backButton.previousTitleText()) {
                var previousTitleWidths = self.calcWidths(textAlign, !0), availableTitleWidth = $element[0].offsetWidth - previousTitleWidths.titleLeft - previousTitleWidths.titleRight;
                self.titleTextWidth() <= availableTitleWidth && (widths = previousTitleWidths);
            }
            return self.updatePositions(titleEle, widths.titleLeft, widths.titleRight, widths.buttonsLeft, widths.buttonsRight, widths.css, widths.showPrevTitle);
        }, self.calcWidths = function(textAlign, isPreviousTitle) {
            var x, y, z, b, c, d, childSize, bounds, isCountRightOfTitle, titleEle = getEle(TITLE), backBtnEle = getEle(BACK_BUTTON), childNodes = $element[0].childNodes, buttonsLeft = 0, buttonsRight = 0, updateTitleLeft = 0, updateTitleRight = 0, updateCss = "", backButtonWidth = 0;
            for (x = 0; x < childNodes.length; x++) {
                if (c = childNodes[x], childSize = 0, 1 == c.nodeType) {
                    if (c === titleEle) {
                        isCountRightOfTitle = !0;
                        continue;
                    }
                    if (c.classList.contains(HIDE)) continue;
                    if (isBackShown && c === backBtnEle) {
                        for (y = 0; y < c.childNodes.length; y++) if (b = c.childNodes[y], 1 == b.nodeType) if (b.classList.contains(BACK_TEXT)) for (z = 0; z < b.children.length; z++) if (d = b.children[z], 
                        isPreviousTitle) {
                            if (d.classList.contains(DEFAULT_TITLE)) continue;
                            backButtonWidth += d.offsetWidth;
                        } else {
                            if (d.classList.contains(PREVIOUS_TITLE)) continue;
                            backButtonWidth += d.offsetWidth;
                        } else backButtonWidth += b.offsetWidth; else 3 == b.nodeType && b.nodeValue.trim() && (bounds = ionic.DomUtil.getTextBounds(b), 
                        backButtonWidth += bounds && bounds.width || 0);
                        childSize = backButtonWidth || c.offsetWidth;
                    } else childSize = c.offsetWidth;
                } else 3 == c.nodeType && c.nodeValue.trim() && (bounds = ionic.DomUtil.getTextBounds(c), 
                childSize = bounds && bounds.width || 0);
                isCountRightOfTitle ? buttonsRight += childSize : buttonsLeft += childSize;
            }
            if ("left" == textAlign) updateCss = "title-left", buttonsLeft && (updateTitleLeft = buttonsLeft + 15), 
            buttonsRight && (updateTitleRight = buttonsRight + 15); else if ("right" == textAlign) updateCss = "title-right", 
            buttonsLeft && (updateTitleLeft = buttonsLeft + 15), buttonsRight && (updateTitleRight = buttonsRight + 15); else {
                var margin = Math.max(buttonsLeft, buttonsRight) + 10;
                margin > 10 && (updateTitleLeft = updateTitleRight = margin);
            }
            return {
                backButtonWidth: backButtonWidth,
                buttonsLeft: buttonsLeft,
                buttonsRight: buttonsRight,
                titleLeft: updateTitleLeft,
                titleRight: updateTitleRight,
                showPrevTitle: isPreviousTitle,
                css: updateCss
            };
        }, self.updatePositions = function(titleEle, updateTitleLeft, updateTitleRight, buttonsLeft, buttonsRight, updateCss, showPreviousTitle) {
            var deferred = $q.defer();
            if (titleEle && (updateTitleLeft !== titleLeft && (titleEle.style.left = updateTitleLeft ? updateTitleLeft + "px" : "", 
            titleLeft = updateTitleLeft), updateTitleRight !== titleRight && (titleEle.style.right = updateTitleRight ? updateTitleRight + "px" : "", 
            titleRight = updateTitleRight), updateCss !== titleCss && (updateCss && titleEle.classList.add(updateCss), 
            titleCss && titleEle.classList.remove(titleCss), titleCss = updateCss)), $ionicConfig.backButton.previousTitleText()) {
                var prevTitle = getEle(PREVIOUS_TITLE), defaultTitle = getEle(DEFAULT_TITLE);
                prevTitle && prevTitle.classList[showPreviousTitle ? "remove" : "add"](HIDE), defaultTitle && defaultTitle.classList[showPreviousTitle ? "add" : "remove"](HIDE);
            }
            return ionic.requestAnimationFrame(function() {
                if (titleEle && titleEle.offsetWidth + 10 < titleEle.scrollWidth) {
                    var minRight = buttonsRight + 5, testRight = $element[0].offsetWidth - titleLeft - self.titleTextWidth() - 20;
                    updateTitleRight = minRight > testRight ? minRight : testRight, updateTitleRight !== titleRight && (titleEle.style.right = updateTitleRight + "px", 
                    titleRight = updateTitleRight);
                }
                deferred.resolve();
            }), deferred.promise;
        }, self.setCss = function(elementClassname, css) {
            ionic.DomUtil.cachedStyles(getEle(elementClassname), css);
        };
        var eleCache = {};
        $scope.$on("$destroy", function() {
            for (var n in eleCache) eleCache[n] = null;
        });
    } ]), IonicModule.controller("$ionInfiniteScroll", [ "$scope", "$attrs", "$element", "$timeout", function($scope, $attrs, $element, $timeout) {
        function onInfinite() {
            ionic.requestAnimationFrame(function() {
                $element[0].classList.add("active");
            }), self.isLoading = !0, $scope.$parent && $scope.$parent.$apply($attrs.onInfinite || "");
        }
        function finishInfiniteScroll() {
            ionic.requestAnimationFrame(function() {
                $element[0].classList.remove("active");
            }), $timeout(function() {
                self.jsScrolling && self.scrollView.resize(), (self.jsScrolling && self.scrollView.__container && self.scrollView.__container.offsetHeight > 0 || !self.jsScrolling) && self.checkBounds();
            }, 30, !1), self.isLoading = !1;
        }
        function checkInfiniteBounds() {
            if (!self.isLoading) {
                var maxScroll = {};
                if (self.jsScrolling) {
                    maxScroll = self.getJSMaxScroll();
                    var scrollValues = self.scrollView.getValues();
                    (-1 !== maxScroll.left && scrollValues.left >= maxScroll.left || -1 !== maxScroll.top && scrollValues.top >= maxScroll.top) && onInfinite();
                } else maxScroll = self.getNativeMaxScroll(), (-1 !== maxScroll.left && self.scrollEl.scrollLeft >= maxScroll.left - self.scrollEl.clientWidth || -1 !== maxScroll.top && self.scrollEl.scrollTop >= maxScroll.top - self.scrollEl.clientHeight) && onInfinite();
            }
        }
        function calculateMaxValue(maximum) {
            var distance = ($attrs.distance || "2.5%").trim(), isPercent = -1 !== distance.indexOf("%");
            return isPercent ? maximum * (1 - parseFloat(distance) / 100) : maximum - parseFloat(distance);
        }
        var self = this;
        self.isLoading = !1, $scope.icon = function() {
            return isDefined($attrs.icon) ? $attrs.icon : "ion-load-d";
        }, $scope.spinner = function() {
            return isDefined($attrs.spinner) ? $attrs.spinner : "";
        }, $scope.$on("scroll.infiniteScrollComplete", function() {
            finishInfiniteScroll();
        }), $scope.$on("$destroy", function() {
            self.scrollCtrl && self.scrollCtrl.$element && self.scrollCtrl.$element.off("scroll", self.checkBounds), 
            self.scrollEl && self.scrollEl.removeEventListener && self.scrollEl.removeEventListener("scroll", self.checkBounds);
        }), self.checkBounds = ionic.Utils.throttle(checkInfiniteBounds, 300), self.getJSMaxScroll = function() {
            var maxValues = self.scrollView.getScrollMax();
            return {
                left: self.scrollView.options.scrollingX ? calculateMaxValue(maxValues.left) : -1,
                top: self.scrollView.options.scrollingY ? calculateMaxValue(maxValues.top) : -1
            };
        }, self.getNativeMaxScroll = function() {
            var maxValues = {
                left: self.scrollEl.scrollWidth,
                top: self.scrollEl.scrollHeight
            }, computedStyle = window.getComputedStyle(self.scrollEl) || {};
            return {
                left: !maxValues.left || "scroll" !== computedStyle.overflowX && "auto" !== computedStyle.overflowX && "scroll" !== self.scrollEl.style["overflow-x"] ? -1 : calculateMaxValue(maxValues.left),
                top: !maxValues.top || "scroll" !== computedStyle.overflowY && "auto" !== computedStyle.overflowY && "scroll" !== self.scrollEl.style["overflow-y"] ? -1 : calculateMaxValue(maxValues.top)
            };
        }, self.__finishInfiniteScroll = finishInfiniteScroll;
    } ]), IonicModule.service("$ionicListDelegate", ionic.DelegateService([ "showReorder", "showDelete", "canSwipeItems", "closeOptionButtons" ])).controller("$ionicList", [ "$scope", "$attrs", "$ionicListDelegate", "$ionicHistory", function($scope, $attrs, $ionicListDelegate, $ionicHistory) {
        var self = this, isSwipeable = !0, isReorderShown = !1, isDeleteShown = !1, deregisterInstance = $ionicListDelegate._registerInstance(self, $attrs.delegateHandle, function() {
            return $ionicHistory.isActiveScope($scope);
        });
        $scope.$on("$destroy", deregisterInstance), self.showReorder = function(show) {
            return arguments.length && (isReorderShown = !!show), isReorderShown;
        }, self.showDelete = function(show) {
            return arguments.length && (isDeleteShown = !!show), isDeleteShown;
        }, self.canSwipeItems = function(can) {
            return arguments.length && (isSwipeable = !!can), isSwipeable;
        }, self.closeOptionButtons = function() {
            self.listView && self.listView.clearDragEffects();
        };
    } ]), IonicModule.controller("$ionicNavBar", [ "$scope", "$element", "$attrs", "$compile", "$timeout", "$ionicNavBarDelegate", "$ionicConfig", "$ionicHistory", function($scope, $element, $attrs, $compile, $timeout, $ionicNavBarDelegate, $ionicConfig, $ionicHistory) {
        function deprecatedWarning(oldMethod, newMethod) {
            var warn = console.warn || console.log;
            warn && warn.call(console, "navBarController." + oldMethod + " is deprecated, please use " + newMethod + " instead");
        }
        function createNavElement(type) {
            return navElementHtml[type] ? jqLite(navElementHtml[type]) : void 0;
        }
        function getOnScreenHeaderBar() {
            for (var x = 0; x < headerBars.length; x++) if (headerBars[x].isActive) return headerBars[x];
        }
        function getOffScreenHeaderBar() {
            for (var x = 0; x < headerBars.length; x++) if (!headerBars[x].isActive) return headerBars[x];
        }
        function navBarAttr(ctrl, val) {
            ctrl && ionic.DomUtil.cachedAttr(ctrl.containerEle(), "nav-bar", val);
        }
        function navSwipeAttr(val) {
            ionic.DomUtil.cachedAttr($element, "nav-swipe", val);
        }
        var queuedTransitionStart, queuedTransitionEnd, latestTransitionId, CSS_HIDE = "hide", DATA_NAV_BAR_CTRL = "$ionNavBarController", PRIMARY_BUTTONS = "primaryButtons", SECONDARY_BUTTONS = "secondaryButtons", BACK_BUTTON = "backButton", ITEM_TYPES = "primaryButtons secondaryButtons leftButtons rightButtons title".split(" "), self = this, headerBars = [], navElementHtml = {}, isVisible = !0;
        $element.parent().data(DATA_NAV_BAR_CTRL, self);
        var delegateHandle = $attrs.delegateHandle || "navBar" + ionic.Utils.nextUid(), deregisterInstance = $ionicNavBarDelegate._registerInstance(self, delegateHandle);
        self.init = function() {
            $element.addClass("nav-bar-container"), ionic.DomUtil.cachedAttr($element, "nav-bar-transition", $ionicConfig.views.transition()), 
            self.createHeaderBar(!1), self.createHeaderBar(!0), $scope.$emit("ionNavBar.init", delegateHandle);
        }, self.createHeaderBar = function(isActive) {
            function positionItem(ele, itemType) {
                ele && ("title" === itemType ? titleEle.append(ele) : "rightButtons" == itemType || itemType == SECONDARY_BUTTONS && "left" != $ionicConfig.navBar.positionSecondaryButtons() || itemType == PRIMARY_BUTTONS && "right" == $ionicConfig.navBar.positionPrimaryButtons() ? (rightButtonsEle || (rightButtonsEle = jqLite('<div class="buttons buttons-right">'), 
                headerBarEle.append(rightButtonsEle)), itemType == SECONDARY_BUTTONS ? rightButtonsEle.append(ele) : rightButtonsEle.prepend(ele)) : (leftButtonsEle || (leftButtonsEle = jqLite('<div class="buttons buttons-left">'), 
                navEle[BACK_BUTTON] ? navEle[BACK_BUTTON].after(leftButtonsEle) : headerBarEle.prepend(leftButtonsEle)), 
                itemType == SECONDARY_BUTTONS ? leftButtonsEle.append(ele) : leftButtonsEle.prepend(ele)));
            }
            var containerEle = jqLite('<div class="nav-bar-block">');
            ionic.DomUtil.cachedAttr(containerEle, "nav-bar", isActive ? "active" : "cached");
            var alignTitle = $attrs.alignTitle || $ionicConfig.navBar.alignTitle(), headerBarEle = jqLite("<ion-header-bar>").addClass($attrs["class"]).attr("align-title", alignTitle);
            isDefined($attrs.noTapScroll) && headerBarEle.attr("no-tap-scroll", $attrs.noTapScroll);
            var leftButtonsEle, rightButtonsEle, titleEle = jqLite('<div class="title title-' + alignTitle + '">'), navEle = {}, lastViewItemEle = {};
            navEle[BACK_BUTTON] = createNavElement(BACK_BUTTON), navEle[BACK_BUTTON] && headerBarEle.append(navEle[BACK_BUTTON]), 
            headerBarEle.append(titleEle), forEach(ITEM_TYPES, function(itemType) {
                navEle[itemType] = createNavElement(itemType), positionItem(navEle[itemType], itemType);
            });
            for (var x = 0; x < headerBarEle[0].children.length; x++) headerBarEle[0].children[x].classList.add("header-item");
            containerEle.append(headerBarEle), $element.append($compile(containerEle)($scope.$new()));
            var headerBarCtrl = headerBarEle.data("$ionHeaderBarController");
            headerBarCtrl.backButtonIcon = $ionicConfig.backButton.icon(), headerBarCtrl.backButtonText = $ionicConfig.backButton.text();
            var headerBarInstance = {
                isActive: isActive,
                title: function(newTitleText) {
                    headerBarCtrl.title(newTitleText);
                },
                setItem: function(navBarItemEle, itemType) {
                    headerBarInstance.removeItem(itemType), navBarItemEle ? ("title" === itemType && headerBarInstance.title(""), 
                    positionItem(navBarItemEle, itemType), navEle[itemType] && navEle[itemType].addClass(CSS_HIDE), 
                    lastViewItemEle[itemType] = navBarItemEle) : navEle[itemType] && navEle[itemType].removeClass(CSS_HIDE);
                },
                removeItem: function(itemType) {
                    lastViewItemEle[itemType] && (lastViewItemEle[itemType].scope().$destroy(), lastViewItemEle[itemType].remove(), 
                    lastViewItemEle[itemType] = null);
                },
                containerEle: function() {
                    return containerEle;
                },
                headerBarEle: function() {
                    return headerBarEle;
                },
                afterLeave: function() {
                    forEach(ITEM_TYPES, function(itemType) {
                        headerBarInstance.removeItem(itemType);
                    }), headerBarCtrl.resetBackButton();
                },
                controller: function() {
                    return headerBarCtrl;
                },
                destroy: function() {
                    forEach(ITEM_TYPES, function(itemType) {
                        headerBarInstance.removeItem(itemType);
                    }), containerEle.scope().$destroy();
                    for (var n in navEle) navEle[n] && (navEle[n].removeData(), navEle[n] = null);
                    leftButtonsEle && leftButtonsEle.removeData(), rightButtonsEle && rightButtonsEle.removeData(), 
                    titleEle.removeData(), headerBarEle.removeData(), containerEle.remove(), containerEle = headerBarEle = titleEle = leftButtonsEle = rightButtonsEle = null;
                }
            };
            return headerBars.push(headerBarInstance), headerBarInstance;
        }, self.navElement = function(type, html) {
            return isDefined(html) && (navElementHtml[type] = html), navElementHtml[type];
        }, self.update = function(viewData) {
            var showNavBar = !viewData.hasHeaderBar && viewData.showNavBar;
            viewData.transition = $ionicConfig.views.transition(), showNavBar || (viewData.direction = "none"), 
            self.enable(showNavBar);
            var enteringHeaderBar = self.isInitialized ? getOffScreenHeaderBar() : getOnScreenHeaderBar(), leavingHeaderBar = self.isInitialized ? getOnScreenHeaderBar() : null, enteringHeaderCtrl = enteringHeaderBar.controller();
            enteringHeaderCtrl.enableBack(viewData.enableBack, !0), enteringHeaderCtrl.showBack(viewData.showBack, !0), 
            enteringHeaderCtrl.updateBackButton(), self.title(viewData.title, enteringHeaderBar), 
            self.showBar(showNavBar), viewData.navBarItems && forEach(ITEM_TYPES, function(itemType) {
                enteringHeaderBar.setItem(viewData.navBarItems[itemType], itemType);
            }), self.transition(enteringHeaderBar, leavingHeaderBar, viewData), self.isInitialized = !0, 
            navSwipeAttr("");
        }, self.transition = function(enteringHeaderBar, leavingHeaderBar, viewData) {
            function transitionEnd() {
                for (var x = 0; x < headerBars.length; x++) headerBars[x].isActive = !1;
                enteringHeaderBar.isActive = !0, navBarAttr(enteringHeaderBar, "active"), navBarAttr(leavingHeaderBar, "cached"), 
                self.activeTransition = navBarTransition = queuedTransitionEnd = null;
            }
            var enteringHeaderBarCtrl = enteringHeaderBar.controller(), transitionFn = $ionicConfig.transitions.navBar[viewData.navBarTransition] || $ionicConfig.transitions.navBar.none, transitionId = viewData.transitionId;
            enteringHeaderBarCtrl.beforeEnter(viewData);
            var navBarTransition = transitionFn(enteringHeaderBar, leavingHeaderBar, viewData.direction, viewData.shouldAnimate && self.isInitialized);
            ionic.DomUtil.cachedAttr($element, "nav-bar-transition", viewData.navBarTransition), 
            ionic.DomUtil.cachedAttr($element, "nav-bar-direction", viewData.direction), navBarTransition.shouldAnimate && viewData.renderEnd ? navBarAttr(enteringHeaderBar, "stage") : (navBarAttr(enteringHeaderBar, "entering"), 
            navBarAttr(leavingHeaderBar, "leaving")), enteringHeaderBarCtrl.resetBackButton(viewData), 
            navBarTransition.run(0), self.activeTransition = {
                run: function(step) {
                    navBarTransition.shouldAnimate = !1, navBarTransition.direction = "back", navBarTransition.run(step);
                },
                cancel: function(shouldAnimate, speed, cancelData) {
                    navSwipeAttr(speed), navBarAttr(leavingHeaderBar, "active"), navBarAttr(enteringHeaderBar, "cached"), 
                    navBarTransition.shouldAnimate = shouldAnimate, navBarTransition.run(0), self.activeTransition = navBarTransition = null;
                    var runApply;
                    cancelData.showBar !== self.showBar() && self.showBar(cancelData.showBar), cancelData.showBackButton !== self.showBackButton() && self.showBackButton(cancelData.showBackButton), 
                    runApply && $scope.$apply();
                },
                complete: function(shouldAnimate, speed) {
                    navSwipeAttr(speed), navBarTransition.shouldAnimate = shouldAnimate, navBarTransition.run(1), 
                    queuedTransitionEnd = transitionEnd;
                }
            }, $timeout(enteringHeaderBarCtrl.align, 16), (queuedTransitionStart = function() {
                latestTransitionId === transitionId && (navBarAttr(enteringHeaderBar, "entering"), 
                navBarAttr(leavingHeaderBar, "leaving"), navBarTransition.run(1), queuedTransitionEnd = function() {
                    latestTransitionId != transitionId && navBarTransition.shouldAnimate || transitionEnd();
                }, queuedTransitionStart = null);
            })();
        }, self.triggerTransitionStart = function(triggerTransitionId) {
            latestTransitionId = triggerTransitionId, queuedTransitionStart && queuedTransitionStart();
        }, self.triggerTransitionEnd = function() {
            queuedTransitionEnd && queuedTransitionEnd();
        }, self.showBar = function(shouldShow) {
            return arguments.length && (self.visibleBar(shouldShow), $scope.$parent.$hasHeader = !!shouldShow), 
            !!$scope.$parent.$hasHeader;
        }, self.visibleBar = function(shouldShow) {
            shouldShow && !isVisible ? ($element.removeClass(CSS_HIDE), self.align()) : !shouldShow && isVisible && $element.addClass(CSS_HIDE), 
            isVisible = shouldShow;
        }, self.enable = function(val) {
            self.visibleBar(val);
            for (var x = 0; x < $ionicNavBarDelegate._instances.length; x++) $ionicNavBarDelegate._instances[x] !== self && $ionicNavBarDelegate._instances[x].visibleBar(!1);
        }, self.showBackButton = function(shouldShow) {
            if (arguments.length) {
                for (var x = 0; x < headerBars.length; x++) headerBars[x].controller().showNavBack(!!shouldShow);
                $scope.$isBackButtonShown = !!shouldShow;
            }
            return $scope.$isBackButtonShown;
        }, self.showActiveBackButton = function(shouldShow) {
            var headerBar = getOnScreenHeaderBar();
            return headerBar ? arguments.length ? headerBar.controller().showBack(shouldShow) : headerBar.controller().showBack() : void 0;
        }, self.title = function(newTitleText, headerBar) {
            return isDefined(newTitleText) && (newTitleText = newTitleText || "", headerBar = headerBar || getOnScreenHeaderBar(), 
            headerBar && headerBar.title(newTitleText), $scope.$title = newTitleText, $ionicHistory.currentTitle(newTitleText)), 
            $scope.$title;
        }, self.align = function(val, headerBar) {
            headerBar = headerBar || getOnScreenHeaderBar(), headerBar && headerBar.controller().align(val);
        }, self.hasTabsTop = function(isTabsTop) {
            $element[isTabsTop ? "addClass" : "removeClass"]("nav-bar-tabs-top");
        }, self.hasBarSubheader = function(isBarSubheader) {
            $element[isBarSubheader ? "addClass" : "removeClass"]("nav-bar-has-subheader");
        }, self.changeTitle = function(val) {
            deprecatedWarning("changeTitle(val)", "title(val)"), self.title(val);
        }, self.setTitle = function(val) {
            deprecatedWarning("setTitle(val)", "title(val)"), self.title(val);
        }, self.getTitle = function() {
            return deprecatedWarning("getTitle()", "title()"), self.title();
        }, self.back = function() {
            deprecatedWarning("back()", "$ionicHistory.goBack()"), $ionicHistory.goBack();
        }, self.getPreviousTitle = function() {
            deprecatedWarning("getPreviousTitle()", "$ionicHistory.backTitle()"), $ionicHistory.goBack();
        }, $scope.$on("$destroy", function() {
            $scope.$parent.$hasHeader = !1, $element.parent().removeData(DATA_NAV_BAR_CTRL);
            for (var x = 0; x < headerBars.length; x++) headerBars[x].destroy();
            $element.remove(), $element = headerBars = null, deregisterInstance();
        });
    } ]), IonicModule.controller("$ionicNavView", [ "$scope", "$element", "$attrs", "$compile", "$controller", "$ionicNavBarDelegate", "$ionicNavViewDelegate", "$ionicHistory", "$ionicViewSwitcher", "$ionicConfig", "$ionicScrollDelegate", function($scope, $element, $attrs, $compile, $controller, $ionicNavBarDelegate, $ionicNavViewDelegate, $ionicHistory, $ionicViewSwitcher, $ionicConfig, $ionicScrollDelegate) {
        function onTabsLeave(ev, data) {
            for (var viewElement, viewScope, viewElements = $element.children(), x = 0, l = viewElements.length; l > x; x++) if (viewElement = viewElements.eq(x), 
            navViewAttr(viewElement) == VIEW_STATUS_ACTIVE) {
                viewScope = viewElement.scope(), viewScope && viewScope.$emit(ev.name.replace("Tabs", "View"), data);
                break;
            }
        }
        function navSwipeAttr(val) {
            ionic.DomUtil.cachedAttr($element, "nav-swipe", val);
        }
        function onTabsTop(ev, isTabsTop) {
            var associatedNavBarCtrl = getAssociatedNavBarCtrl();
            associatedNavBarCtrl && associatedNavBarCtrl.hasTabsTop(isTabsTop);
        }
        function onBarSubheader(ev, isBarSubheader) {
            var associatedNavBarCtrl = getAssociatedNavBarCtrl();
            associatedNavBarCtrl && associatedNavBarCtrl.hasBarSubheader(isBarSubheader);
        }
        function getAssociatedNavBarCtrl() {
            if (navBarDelegate) for (var x = 0; x < $ionicNavBarDelegate._instances.length; x++) if ($ionicNavBarDelegate._instances[x].$$delegateHandle == navBarDelegate) return $ionicNavBarDelegate._instances[x];
            return $element.inheritedData("$ionNavBarController");
        }
        var direction, navBarDelegate, activeEleId, disableRenderStartViewId, disableAnimation, DATA_ELE_IDENTIFIER = "$eleId", DATA_DESTROY_ELE = "$destroyEle", DATA_NO_CACHE = "$noCache", VIEW_STATUS_ACTIVE = "active", VIEW_STATUS_CACHED = "cached", self = this, isPrimary = !1, navViewAttr = $ionicViewSwitcher.navViewAttr;
        self.scope = $scope, self.element = $element, self.init = function() {
            var navViewName = $attrs.name || "", parent = $element.parent().inheritedData("$uiView"), parentViewName = parent && parent.state ? parent.state.name : "";
            navViewName.indexOf("@") < 0 && (navViewName = navViewName + "@" + parentViewName);
            var viewData = {
                name: navViewName,
                state: null
            };
            $element.data("$uiView", viewData);
            var deregisterInstance = $ionicNavViewDelegate._registerInstance(self, $attrs.delegateHandle);
            return $scope.$on("$destroy", function() {
                deregisterInstance(), self.isSwipeFreeze && $ionicScrollDelegate.freezeAllScrolls(!1);
            }), $scope.$on("$ionicHistory.deselect", self.cacheCleanup), $scope.$on("$ionicTabs.top", onTabsTop), 
            $scope.$on("$ionicSubheader", onBarSubheader), $scope.$on("$ionicTabs.beforeLeave", onTabsLeave), 
            $scope.$on("$ionicTabs.afterLeave", onTabsLeave), $scope.$on("$ionicTabs.leave", onTabsLeave), 
            ionic.Platform.ready(function() {
                ionic.Platform.isWebView() && $ionicConfig.views.swipeBackEnabled() && self.initSwipeBack();
            }), viewData;
        }, self.register = function(viewLocals) {
            var leavingView = extend({}, $ionicHistory.currentView()), registerData = $ionicHistory.register($scope, viewLocals);
            self.update(registerData);
            var enteringView = $ionicHistory.getViewById(registerData.viewId) || {}, renderStart = disableRenderStartViewId !== registerData.viewId;
            self.render(registerData, viewLocals, enteringView, leavingView, renderStart, !0);
        }, self.update = function(registerData) {
            isPrimary = !0, direction = registerData.direction;
            var parentNavViewCtrl = $element.parent().inheritedData("$ionNavViewController");
            parentNavViewCtrl && (parentNavViewCtrl.isPrimary(!1), ("enter" === direction || "exit" === direction) && (parentNavViewCtrl.direction(direction), 
            "enter" === direction && (direction = "none")));
        }, self.render = function(registerData, viewLocals, enteringView, leavingView, renderStart, renderEnd) {
            var switcher = $ionicViewSwitcher.create(self, viewLocals, enteringView, leavingView, renderStart, renderEnd);
            switcher.init(registerData, function() {
                switcher.transition(self.direction(), registerData.enableBack, !disableAnimation), 
                disableRenderStartViewId = disableAnimation = null;
            });
        }, self.beforeEnter = function(transitionData) {
            if (isPrimary) {
                navBarDelegate = transitionData.navBarDelegate;
                var associatedNavBarCtrl = getAssociatedNavBarCtrl();
                associatedNavBarCtrl && associatedNavBarCtrl.update(transitionData), navSwipeAttr("");
            }
        }, self.activeEleId = function(eleId) {
            return arguments.length && (activeEleId = eleId), activeEleId;
        }, self.transitionEnd = function() {
            var x, l, viewElement, viewElements = $element.children();
            for (x = 0, l = viewElements.length; l > x; x++) viewElement = viewElements.eq(x), 
            viewElement.data(DATA_ELE_IDENTIFIER) === activeEleId ? navViewAttr(viewElement, VIEW_STATUS_ACTIVE) : ("leaving" === navViewAttr(viewElement) || navViewAttr(viewElement) === VIEW_STATUS_ACTIVE || navViewAttr(viewElement) === VIEW_STATUS_CACHED) && (viewElement.data(DATA_DESTROY_ELE) || viewElement.data(DATA_NO_CACHE) ? $ionicViewSwitcher.destroyViewEle(viewElement) : (navViewAttr(viewElement, VIEW_STATUS_CACHED), 
            ionic.Utils.disconnectScope(viewElement.scope())));
            navSwipeAttr(""), self.isSwipeFreeze && $ionicScrollDelegate.freezeAllScrolls(!1);
        }, self.cacheCleanup = function() {
            for (var viewElements = $element.children(), x = 0, l = viewElements.length; l > x; x++) viewElements.eq(x).data(DATA_DESTROY_ELE) && $ionicViewSwitcher.destroyViewEle(viewElements.eq(x));
        }, self.clearCache = function(stateIds) {
            var viewElement, viewScope, x, l, y, eleIdentifier, viewElements = $element.children();
            for (x = 0, l = viewElements.length; l > x; x++) if (viewElement = viewElements.eq(x), 
            stateIds) for (eleIdentifier = viewElement.data(DATA_ELE_IDENTIFIER), y = 0; y < stateIds.length; y++) eleIdentifier === stateIds[y] && $ionicViewSwitcher.destroyViewEle(viewElement); else navViewAttr(viewElement) == VIEW_STATUS_CACHED ? $ionicViewSwitcher.destroyViewEle(viewElement) : navViewAttr(viewElement) == VIEW_STATUS_ACTIVE && (viewScope = viewElement.scope(), 
            viewScope && viewScope.$broadcast("$ionicView.clearCache"));
        }, self.getViewElements = function() {
            return $element.children();
        }, self.appendViewElement = function(viewEle, viewLocals) {
            var linkFn = $compile(viewEle);
            $element.append(viewEle);
            var viewScope = $scope.$new();
            if (viewLocals && viewLocals.$$controller) {
                viewLocals.$scope = viewScope;
                var controller = $controller(viewLocals.$$controller, viewLocals);
                viewLocals.$$controllerAs && (viewScope[viewLocals.$$controllerAs] = controller), 
                $element.children().data("$ngControllerController", controller);
            }
            return linkFn(viewScope), viewScope;
        }, self.title = function(val) {
            var associatedNavBarCtrl = getAssociatedNavBarCtrl();
            associatedNavBarCtrl && associatedNavBarCtrl.title(val);
        }, self.enableBackButton = function(shouldEnable) {
            var associatedNavBarCtrl = getAssociatedNavBarCtrl();
            associatedNavBarCtrl && associatedNavBarCtrl.enableBackButton(shouldEnable);
        }, self.showBackButton = function(shouldShow) {
            var associatedNavBarCtrl = getAssociatedNavBarCtrl();
            return associatedNavBarCtrl ? arguments.length ? associatedNavBarCtrl.showActiveBackButton(shouldShow) : associatedNavBarCtrl.showActiveBackButton() : !0;
        }, self.showBar = function(val) {
            var associatedNavBarCtrl = getAssociatedNavBarCtrl();
            return associatedNavBarCtrl ? arguments.length ? associatedNavBarCtrl.showBar(val) : associatedNavBarCtrl.showBar() : !0;
        }, self.isPrimary = function(val) {
            return arguments.length && (isPrimary = val), isPrimary;
        }, self.direction = function(val) {
            return arguments.length && (direction = val), direction;
        }, self.initSwipeBack = function() {
            function onDragStart(ev) {
                if (isPrimary && (startDragX = getDragX(ev), !(startDragX > swipeBackHitWidth))) {
                    backView = $ionicHistory.backView();
                    var currentView = $ionicHistory.currentView();
                    if (backView && backView.historyId === currentView.historyId && currentView.canSwipeBack !== !1) {
                        windowWidth || (windowWidth = window.innerWidth), self.isSwipeFreeze = $ionicScrollDelegate.freezeAllScrolls(!0);
                        var registerData = {
                            direction: "back"
                        };
                        dragPoints = [], cancelData = {
                            showBar: self.showBar(),
                            showBackButton: self.showBackButton()
                        };
                        var switcher = $ionicViewSwitcher.create(self, registerData, backView, currentView, !0, !1);
                        switcher.loadViewElements(registerData), switcher.render(registerData), viewTransition = switcher.transition("back", $ionicHistory.enabledBack(backView), !0), 
                        associatedNavBarCtrl = getAssociatedNavBarCtrl(), deregDrag = ionic.onGesture("drag", onDrag, $element[0]), 
                        deregRelease = ionic.onGesture("release", onRelease, $element[0]);
                    }
                }
            }
            function onDrag(ev) {
                if (isPrimary && viewTransition) {
                    var dragX = getDragX(ev);
                    if (dragPoints.push({
                        t: Date.now(),
                        x: dragX
                    }), dragX >= windowWidth - 15) onRelease(ev); else {
                        var step = Math.min(Math.max(getSwipeCompletion(dragX), 0), 1);
                        viewTransition.run(step), associatedNavBarCtrl && associatedNavBarCtrl.activeTransition && associatedNavBarCtrl.activeTransition.run(step);
                    }
                }
            }
            function onRelease(ev) {
                if (isPrimary && viewTransition && dragPoints && dragPoints.length > 1) {
                    for (var now = Date.now(), releaseX = getDragX(ev), startDrag = dragPoints[dragPoints.length - 1], x = dragPoints.length - 2; x >= 0 && !(now - startDrag.t > 200); x--) startDrag = dragPoints[x];
                    var isSwipingRight = releaseX >= dragPoints[dragPoints.length - 2].x, releaseSwipeCompletion = getSwipeCompletion(releaseX), velocity = Math.abs(startDrag.x - releaseX) / (now - startDrag.t);
                    if (disableRenderStartViewId = backView.viewId, disableAnimation = .03 > releaseSwipeCompletion || releaseSwipeCompletion > .97, 
                    isSwipingRight && (releaseSwipeCompletion > .5 || velocity > .1)) {
                        var speed = velocity > .5 || .05 > velocity || releaseX > windowWidth - 45 ? "fast" : "slow";
                        navSwipeAttr(disableAnimation ? "" : speed), backView.go(), associatedNavBarCtrl && associatedNavBarCtrl.activeTransition && associatedNavBarCtrl.activeTransition.complete(!disableAnimation, speed);
                    } else navSwipeAttr(disableAnimation ? "" : "fast"), disableRenderStartViewId = null, 
                    viewTransition.cancel(!disableAnimation), associatedNavBarCtrl && associatedNavBarCtrl.activeTransition && associatedNavBarCtrl.activeTransition.cancel(!disableAnimation, "fast", cancelData), 
                    disableAnimation = null;
                }
                ionic.offGesture(deregDrag, "drag", onDrag), ionic.offGesture(deregRelease, "release", onRelease), 
                windowWidth = viewTransition = dragPoints = null, self.isSwipeFreeze = $ionicScrollDelegate.freezeAllScrolls(!1);
            }
            function getDragX(ev) {
                return ionic.tap.pointerCoord(ev.gesture.srcEvent).x;
            }
            function getSwipeCompletion(dragX) {
                return (dragX - startDragX) / windowWidth;
            }
            var viewTransition, associatedNavBarCtrl, backView, deregDragStart, deregDrag, deregRelease, windowWidth, startDragX, dragPoints, swipeBackHitWidth = $ionicConfig.views.swipeBackHitWidth(), cancelData = {};
            deregDragStart = ionic.onGesture("dragstart", onDragStart, $element[0]), $scope.$on("$destroy", function() {
                ionic.offGesture(deregDragStart, "dragstart", onDragStart), ionic.offGesture(deregDrag, "drag", onDrag), 
                ionic.offGesture(deregRelease, "release", onRelease), self.element = viewTransition = associatedNavBarCtrl = null;
            });
        };
    } ]), IonicModule.controller("$ionicRefresher", [ "$scope", "$attrs", "$element", "$ionicBind", "$timeout", function($scope, $attrs, $element, $ionicBind, $timeout) {
        function handleMousedown(e) {
            e.touches = e.touches || [ {
                screenX: e.screenX,
                screenY: e.screenY
            } ], startY = Math.floor(e.touches[0].screenY);
        }
        function handleTouchstart(e) {
            e.touches = e.touches || [ {
                screenX: e.screenX,
                screenY: e.screenY
            } ], startY = e.touches[0].screenY;
        }
        function handleTouchend() {
            startY = null, (canOverscroll || isDragging) && (isDragging ? (isDragging = !1, 
            dragOffset = 0, lastOverscroll > ptrThreshold ? (start(), scrollTo(ptrThreshold, scrollTime)) : (scrollTo(0, scrollTime, deactivate), 
            isOverscrolling = !1)) : (dragOffset = 0, isOverscrolling = !1, setScrollLock(!1)));
        }
        function handleTouchmove(e) {
            if (e.touches = e.touches || [ {
                screenX: e.screenX,
                screenY: e.screenY
            } ], (startY || "mousemove" != e.type) && canOverscroll && !(e.touches.length > 1)) {
                if (null === startY && (startY = e.touches[0].screenY), deltaY = e.touches[0].screenY - startY, 
                ionic.Platform.isAndroid() && 4.4 === ionic.Platform.version() && !ionic.Platform.isCrosswalk() && 0 === scrollParent.scrollTop && deltaY > 0 && (isDragging = !0, 
                e.preventDefault()), 0 >= deltaY - dragOffset || 0 !== scrollParent.scrollTop) return isOverscrolling && (isOverscrolling = !1, 
                setScrollLock(!1)), isDragging && nativescroll(scrollParent, deltaY - -1 * dragOffset), 
                void (0 !== lastOverscroll && overscroll(0));
                deltaY > 0 && 0 === scrollParent.scrollTop && !isOverscrolling && (dragOffset = deltaY), 
                e.preventDefault(), isOverscrolling || (isOverscrolling = !0, setScrollLock(!0)), 
                isDragging = !0, overscroll((deltaY - dragOffset) / 3), !activated && lastOverscroll > ptrThreshold ? (activated = !0, 
                ionic.requestAnimationFrame(activate)) : activated && ptrThreshold > lastOverscroll && (activated = !1, 
                ionic.requestAnimationFrame(deactivate));
            }
        }
        function handleScroll(e) {
            canOverscroll = 0 === e.target.scrollTop || isDragging;
        }
        function overscroll(val) {
            scrollChild.style[ionic.CSS.TRANSFORM] = "translateY(" + val + "px)", lastOverscroll = val;
        }
        function nativescroll(target, newScrollTop) {
            target.scrollTop = newScrollTop;
            var e = document.createEvent("UIEvents");
            e.initUIEvent("scroll", !0, !0, window, 1), target.dispatchEvent(e);
        }
        function setScrollLock(enabled) {
            enabled ? ionic.requestAnimationFrame(function() {
                scrollChild.classList.add("overscroll"), show();
            }) : ionic.requestAnimationFrame(function() {
                scrollChild.classList.remove("overscroll"), hide(), deactivate();
            });
        }
        function scrollTo(Y, duration, callback) {
            function easeOutCubic(t) {
                return --t * t * t + 1;
            }
            function scroll() {
                var currentTime = Date.now(), time = Math.min(1, (currentTime - start) / duration), easedT = easeOutCubic(time);
                overscroll(Math.floor(easedT * (Y - from) + from)), 1 > time ? ionic.requestAnimationFrame(scroll) : (5 > Y && Y > -5 && (isOverscrolling = !1, 
                setScrollLock(!1)), callback && callback());
            }
            var start = Date.now(), from = lastOverscroll;
            return from === Y ? void callback() : void ionic.requestAnimationFrame(scroll);
        }
        function destroy() {
            ionic.off(touchStartEvent, handleTouchstart, scrollChild), ionic.off(touchMoveEvent, handleTouchmove, scrollChild), 
            ionic.off(touchEndEvent, handleTouchend, scrollChild), ionic.off("mousedown", handleMousedown, scrollChild), 
            ionic.off("mousemove", handleTouchmove, scrollChild), ionic.off("mouseup", handleTouchend, scrollChild), 
            ionic.off("scroll", handleScroll, scrollParent), scrollParent = null, scrollChild = null;
        }
        function activate() {
            $element[0].classList.add("active"), $scope.$onPulling();
        }
        function deactivate() {
            $timeout(function() {
                $element.removeClass("active refreshing refreshing-tail"), activated && (activated = !1);
            }, 150);
        }
        function start() {
            $element[0].classList.add("refreshing");
            var q = $scope.$onRefresh();
            q && q.then && q["finally"](function() {
                $scope.$broadcast("scroll.refreshComplete");
            });
        }
        function show() {
            $element[0].classList.remove("invisible");
        }
        function hide() {
            $element[0].classList.add("invisible");
        }
        function tail() {
            $element[0].classList.add("refreshing-tail");
        }
        var scrollParent, scrollChild, self = this, isDragging = !1, isOverscrolling = !1, dragOffset = 0, lastOverscroll = 0, ptrThreshold = 60, activated = !1, scrollTime = 500, startY = null, deltaY = null, canOverscroll = !0;
        isDefined($attrs.pullingIcon) || $attrs.$set("pullingIcon", "ion-android-arrow-down"), 
        $scope.showSpinner = !isDefined($attrs.refreshingIcon) && "none" != $attrs.spinner, 
        $scope.showIcon = isDefined($attrs.refreshingIcon), $ionicBind($scope, $attrs, {
            pullingIcon: "@",
            pullingText: "@",
            refreshingIcon: "@",
            refreshingText: "@",
            spinner: "@",
            disablePullingRotation: "@",
            $onRefresh: "&onRefresh",
            $onPulling: "&onPulling"
        }), $scope.$on("scroll.refreshComplete", function() {
            $timeout(function() {
                ionic.requestAnimationFrame(tail), scrollTo(0, scrollTime, deactivate), $timeout(function() {
                    isOverscrolling && (isOverscrolling = !1, setScrollLock(!1));
                }, scrollTime);
            }, scrollTime);
        });
        var touchStartEvent, touchMoveEvent, touchEndEvent;
        window.navigator.pointerEnabled ? (touchStartEvent = "pointerdown", touchMoveEvent = "pointermove", 
        touchEndEvent = "pointerup") : window.navigator.msPointerEnabled ? (touchStartEvent = "MSPointerDown", 
        touchMoveEvent = "MSPointerMove", touchEndEvent = "MSPointerUp") : (touchStartEvent = "touchstart", 
        touchMoveEvent = "touchmove", touchEndEvent = "touchend"), self.init = function() {
            if (scrollParent = $element.parent().parent()[0], scrollChild = $element.parent()[0], 
            !(scrollParent && scrollParent.classList.contains("ionic-scroll") && scrollChild && scrollChild.classList.contains("scroll"))) throw new Error("Refresher must be immediate child of ion-content or ion-scroll");
            ionic.on(touchStartEvent, handleTouchstart, scrollChild), ionic.on(touchMoveEvent, handleTouchmove, scrollChild), 
            ionic.on(touchEndEvent, handleTouchend, scrollChild), ionic.on("mousedown", handleMousedown, scrollChild), 
            ionic.on("mousemove", handleTouchmove, scrollChild), ionic.on("mouseup", handleTouchend, scrollChild), 
            ionic.on("scroll", handleScroll, scrollParent), $scope.$on("$destroy", destroy);
        }, self.getRefresherDomMethods = function() {
            return {
                activate: activate,
                deactivate: deactivate,
                start: start,
                show: show,
                hide: hide,
                tail: tail
            };
        }, self.__handleTouchmove = handleTouchmove, self.__getScrollChild = function() {
            return scrollChild;
        }, self.__getScrollParent = function() {
            return scrollParent;
        };
    } ]), IonicModule.controller("$ionicScroll", [ "$scope", "scrollViewOptions", "$timeout", "$window", "$location", "$document", "$ionicScrollDelegate", "$ionicHistory", function($scope, scrollViewOptions, $timeout, $window, $location, $document, $ionicScrollDelegate, $ionicHistory) {
        var self = this;
        self.__timeout = $timeout, self._scrollViewOptions = scrollViewOptions, self.isNative = function() {
            return !!scrollViewOptions.nativeScrolling;
        };
        var scrollView, element = self.element = scrollViewOptions.el, $element = self.$element = jqLite(element);
        scrollView = self.isNative() ? self.scrollView = new ionic.views.ScrollNative(scrollViewOptions) : self.scrollView = new ionic.views.Scroll(scrollViewOptions), 
        ($element.parent().length ? $element.parent() : $element).data("$$ionicScrollController", self);
        var deregisterInstance = $ionicScrollDelegate._registerInstance(self, scrollViewOptions.delegateHandle, function() {
            return $ionicHistory.isActiveScope($scope);
        });
        isDefined(scrollViewOptions.bouncing) || ionic.Platform.ready(function() {
            scrollView && scrollView.options && (scrollView.options.bouncing = !0, ionic.Platform.isAndroid() && (scrollView.options.bouncing = !1, 
            scrollView.options.deceleration = .95));
        });
        var resize = angular.bind(scrollView, scrollView.resize);
        angular.element($window).on("resize", resize);
        var scrollFunc = function(e) {
            var detail = (e.originalEvent || e).detail || {};
            $scope.$onScroll && $scope.$onScroll({
                event: e,
                scrollTop: detail.scrollTop || 0,
                scrollLeft: detail.scrollLeft || 0
            });
        };
        $element.on("scroll", scrollFunc), $scope.$on("$destroy", function() {
            deregisterInstance(), scrollView && scrollView.__cleanup && scrollView.__cleanup(), 
            angular.element($window).off("resize", resize), $element.off("scroll", scrollFunc), 
            scrollView = self.scrollView = scrollViewOptions = self._scrollViewOptions = scrollViewOptions.el = self._scrollViewOptions.el = $element = self.$element = element = null;
        }), $timeout(function() {
            scrollView && scrollView.run && scrollView.run();
        }), self.getScrollView = function() {
            return scrollView;
        }, self.getScrollPosition = function() {
            return scrollView.getValues();
        }, self.resize = function() {
            return $timeout(resize, 0, !1).then(function() {
                $element && $element.triggerHandler("scroll-resize");
            });
        }, self.scrollTop = function(shouldAnimate) {
            self.resize().then(function() {
                scrollView && scrollView.scrollTo(0, 0, !!shouldAnimate);
            });
        }, self.scrollBottom = function(shouldAnimate) {
            self.resize().then(function() {
                if (scrollView) {
                    var max = scrollView.getScrollMax();
                    scrollView.scrollTo(max.left, max.top, !!shouldAnimate);
                }
            });
        }, self.scrollTo = function(left, top, shouldAnimate) {
            self.resize().then(function() {
                scrollView && scrollView.scrollTo(left, top, !!shouldAnimate);
            });
        }, self.zoomTo = function(zoom, shouldAnimate, originLeft, originTop) {
            self.resize().then(function() {
                scrollView && scrollView.zoomTo(zoom, !!shouldAnimate, originLeft, originTop);
            });
        }, self.zoomBy = function(zoom, shouldAnimate, originLeft, originTop) {
            self.resize().then(function() {
                scrollView && scrollView.zoomBy(zoom, !!shouldAnimate, originLeft, originTop);
            });
        }, self.scrollBy = function(left, top, shouldAnimate) {
            self.resize().then(function() {
                scrollView && scrollView.scrollBy(left, top, !!shouldAnimate);
            });
        }, self.anchorScroll = function(shouldAnimate) {
            self.resize().then(function() {
                if (scrollView) {
                    var hash = $location.hash(), elm = hash && $document[0].getElementById(hash);
                    if (!hash || !elm) return void scrollView.scrollTo(0, 0, !!shouldAnimate);
                    var curElm = elm, scrollLeft = 0, scrollTop = 0;
                    do null !== curElm && (scrollLeft += curElm.offsetLeft), null !== curElm && (scrollTop += curElm.offsetTop), 
                    curElm = curElm.offsetParent; while (curElm.attributes != self.element.attributes && curElm.offsetParent);
                    scrollView.scrollTo(scrollLeft, scrollTop, !!shouldAnimate);
                }
            });
        }, self.freezeScroll = scrollView.freeze, self.freezeScrollShut = scrollView.freezeShut, 
        self.freezeAllScrolls = function(shouldFreeze) {
            for (var i = 0; i < $ionicScrollDelegate._instances.length; i++) $ionicScrollDelegate._instances[i].freezeScroll(shouldFreeze);
        }, self._setRefresher = function(refresherScope, refresherElement, refresherMethods) {
            self.refresher = refresherElement;
            var refresherHeight = self.refresher.clientHeight || 60;
            scrollView.activatePullToRefresh(refresherHeight, refresherMethods);
        };
    } ]), IonicModule.controller("$ionicSideMenus", [ "$scope", "$attrs", "$ionicSideMenuDelegate", "$ionicPlatform", "$ionicBody", "$ionicHistory", "$ionicScrollDelegate", "IONIC_BACK_PRIORITY", "$rootScope", function($scope, $attrs, $ionicSideMenuDelegate, $ionicPlatform, $ionicBody, $ionicHistory, $ionicScrollDelegate, IONIC_BACK_PRIORITY, $rootScope) {
        var rightShowing, leftShowing, isDragging, startX, lastX, offsetX, isAsideExposed, self = this, enableMenuWithBackViews = !0;
        self.$scope = $scope, self.initialize = function(options) {
            self.left = options.left, self.right = options.right, self.setContent(options.content), 
            self.dragThresholdX = options.dragThresholdX || 10, $ionicHistory.registerHistory(self.$scope);
        }, self.setContent = function(content) {
            content && (self.content = content, self.content.onDrag = function(e) {
                self._handleDrag(e);
            }, self.content.endDrag = function(e) {
                self._endDrag(e);
            });
        }, self.isOpenLeft = function() {
            return self.getOpenAmount() > 0;
        }, self.isOpenRight = function() {
            return self.getOpenAmount() < 0;
        }, self.toggleLeft = function(shouldOpen) {
            if (!isAsideExposed && self.left.isEnabled) {
                var openAmount = self.getOpenAmount();
                0 === arguments.length && (shouldOpen = 0 >= openAmount), self.content.enableAnimation(), 
                shouldOpen ? (self.openPercentage(100), $rootScope.$emit("$ionicSideMenuOpen", "left")) : (self.openPercentage(0), 
                $rootScope.$emit("$ionicSideMenuClose", "left"));
            }
        }, self.toggleRight = function(shouldOpen) {
            if (!isAsideExposed && self.right.isEnabled) {
                var openAmount = self.getOpenAmount();
                0 === arguments.length && (shouldOpen = openAmount >= 0), self.content.enableAnimation(), 
                shouldOpen ? (self.openPercentage(-100), $rootScope.$emit("$ionicSideMenuOpen", "right")) : (self.openPercentage(0), 
                $rootScope.$emit("$ionicSideMenuClose", "right"));
            }
        }, self.toggle = function(side) {
            "right" == side ? self.toggleRight() : self.toggleLeft();
        }, self.close = function() {
            self.openPercentage(0), $rootScope.$emit("$ionicSideMenuClose", "left"), $rootScope.$emit("$ionicSideMenuClose", "right");
        }, self.getOpenAmount = function() {
            return self.content && self.content.getTranslateX() || 0;
        }, self.getOpenRatio = function() {
            var amount = self.getOpenAmount();
            return amount >= 0 ? amount / self.left.width : amount / self.right.width;
        }, self.isOpen = function() {
            return 0 !== self.getOpenAmount();
        }, self.getOpenPercentage = function() {
            return 100 * self.getOpenRatio();
        }, self.openPercentage = function(percentage) {
            var p = percentage / 100;
            self.left && percentage >= 0 ? self.openAmount(self.left.width * p) : self.right && 0 > percentage && self.openAmount(self.right.width * p), 
            $ionicBody.enableClass(0 !== percentage, "menu-open"), self.content.setCanScroll(0 == percentage);
        }, self.openAmount = function(amount) {
            var maxLeft = self.left && self.left.width || 0, maxRight = self.right && self.right.width || 0;
            return (self.left && self.left.isEnabled || !(amount > 0)) && (self.right && self.right.isEnabled || !(0 > amount)) ? leftShowing && amount > maxLeft ? void self.content.setTranslateX(maxLeft) : rightShowing && -maxRight > amount ? void self.content.setTranslateX(-maxRight) : (self.content.setTranslateX(amount), 
            void (amount >= 0 ? (leftShowing = !0, rightShowing = !1, amount > 0 && (self.right && self.right.pushDown && self.right.pushDown(), 
            self.left && self.left.bringUp && self.left.bringUp())) : (rightShowing = !0, leftShowing = !1, 
            self.right && self.right.bringUp && self.right.bringUp(), self.left && self.left.pushDown && self.left.pushDown()))) : void self.content.setTranslateX(0);
        }, self.snapToRest = function(e) {
            self.content.enableAnimation(), isDragging = !1;
            var ratio = self.getOpenRatio();
            if (0 === ratio) return void self.openPercentage(0);
            var velocityThreshold = .3, velocityX = e.gesture.velocityX, direction = e.gesture.direction;
            ratio > 0 && .5 > ratio && "right" == direction && velocityThreshold > velocityX ? self.openPercentage(0) : ratio > .5 && "left" == direction && velocityThreshold > velocityX ? self.openPercentage(100) : 0 > ratio && ratio > -.5 && "left" == direction && velocityThreshold > velocityX ? self.openPercentage(0) : .5 > ratio && "right" == direction && velocityThreshold > velocityX ? self.openPercentage(-100) : "right" == direction && ratio >= 0 && (ratio >= .5 || velocityX > velocityThreshold) ? self.openPercentage(100) : "left" == direction && 0 >= ratio && (-.5 >= ratio || velocityX > velocityThreshold) ? self.openPercentage(-100) : self.openPercentage(0);
        }, self.enableMenuWithBackViews = function(val) {
            return arguments.length && (enableMenuWithBackViews = !!val), enableMenuWithBackViews;
        }, self.isAsideExposed = function() {
            return !!isAsideExposed;
        }, self.exposeAside = function(shouldExposeAside) {
            (self.left && self.left.isEnabled || self.right && self.right.isEnabled) && (self.close(), 
            isAsideExposed = shouldExposeAside, self.left && self.left.isEnabled && self.right && self.right.isEnabled ? self.content.setMarginLeftAndRight(isAsideExposed ? self.left.width : 0, isAsideExposed ? self.right.width : 0) : self.left && self.left.isEnabled ? self.content.setMarginLeft(isAsideExposed ? self.left.width : 0) : self.right && self.right.isEnabled && self.content.setMarginRight(isAsideExposed ? self.right.width : 0), 
            self.$scope.$emit("$ionicExposeAside", isAsideExposed));
        }, self.activeAsideResizing = function(isResizing) {
            $ionicBody.enableClass(isResizing, "aside-resizing");
        }, self._endDrag = function(e) {
            isAsideExposed || (isDragging && self.snapToRest(e), startX = null, lastX = null, 
            offsetX = null);
        }, self._handleDrag = function(e) {
            !isAsideExposed && $scope.dragContent && (startX ? lastX = e.gesture.touches[0].pageX : (startX = e.gesture.touches[0].pageX, 
            lastX = startX), !isDragging && Math.abs(lastX - startX) > self.dragThresholdX && (startX = lastX, 
            isDragging = !0, self.content.disableAnimation(), offsetX = self.getOpenAmount()), 
            isDragging && self.openAmount(offsetX + (lastX - startX)));
        }, self.canDragContent = function(canDrag) {
            return arguments.length && ($scope.dragContent = !!canDrag), $scope.dragContent;
        }, self.edgeThreshold = 25, self.edgeThresholdEnabled = !1, self.edgeDragThreshold = function(value) {
            return arguments.length && (isNumber(value) && value > 0 ? (self.edgeThreshold = value, 
            self.edgeThresholdEnabled = !0) : self.edgeThresholdEnabled = !!value), self.edgeThresholdEnabled;
        }, self.isDraggableTarget = function(e) {
            var shouldOnlyAllowEdgeDrag = self.edgeThresholdEnabled && !self.isOpen(), startX = e.gesture.startEvent && e.gesture.startEvent.center && e.gesture.startEvent.center.pageX, dragIsWithinBounds = !shouldOnlyAllowEdgeDrag || startX <= self.edgeThreshold || startX >= self.content.element.offsetWidth - self.edgeThreshold, backView = $ionicHistory.backView(), menuEnabled = enableMenuWithBackViews ? !0 : !backView;
            if (!menuEnabled) {
                var currentView = $ionicHistory.currentView() || {};
                return dragIsWithinBounds && backView.historyId !== currentView.historyId;
            }
            return ($scope.dragContent || self.isOpen()) && dragIsWithinBounds && !e.gesture.srcEvent.defaultPrevented && menuEnabled && !e.target.tagName.match(/input|textarea|select|object|embed/i) && !e.target.isContentEditable && !(e.target.dataset ? e.target.dataset.preventScroll : "true" == e.target.getAttribute("data-prevent-scroll"));
        }, $scope.sideMenuContentTranslateX = 0;
        var deregisterBackButtonAction = noop, closeSideMenu = angular.bind(self, self.close);
        $scope.$watch(function() {
            return 0 !== self.getOpenAmount();
        }, function(isOpen) {
            deregisterBackButtonAction(), isOpen && (deregisterBackButtonAction = $ionicPlatform.registerBackButtonAction(closeSideMenu, IONIC_BACK_PRIORITY.sideMenu));
        });
        var deregisterInstance = $ionicSideMenuDelegate._registerInstance(self, $attrs.delegateHandle, function() {
            return $ionicHistory.isActiveScope($scope);
        });
        $scope.$on("$destroy", function() {
            deregisterInstance(), deregisterBackButtonAction(), self.$scope = null, self.content && (self.content.setCanScroll(!0), 
            self.content.element = null, self.content = null);
        }), self.initialize({
            left: {
                width: 275
            },
            right: {
                width: 275
            }
        });
    } ]), function(ionic) {
        function createSvgElement(tagName, data, parent, spinnerName) {
            var k, x, y, ele = document.createElement(SHORTCUTS[tagName] || tagName);
            for (k in data) if (angular.isArray(data[k])) for (x = 0; x < data[k].length; x++) if (data[k][x].fn) for (y = 0; y < data[k][x].t; y++) createSvgElement(k, data[k][x].fn(y, spinnerName), ele, spinnerName); else createSvgElement(k, data[k][x], ele, spinnerName); else setSvgAttribute(ele, k, data[k]);
            parent.appendChild(ele);
        }
        function setSvgAttribute(ele, k, v) {
            ele.setAttribute(SHORTCUTS[k] || k, v);
        }
        function animationValues(strValues, i) {
            var values = strValues.split(";"), back = values.slice(i), front = values.slice(0, values.length - back.length);
            return values = back.concat(front).reverse(), values.join(";") + ";" + values[0];
        }
        function easeInOutCubic(t, c) {
            return t /= c / 2, 1 > t ? .5 * t * t * t : (t -= 2, .5 * (t * t * t + 2));
        }
        var TRANSLATE32 = "translate(32,32)", STROKE_OPACITY = "stroke-opacity", ROUND = "round", INDEFINITE = "indefinite", DURATION = "750ms", NONE = "none", SHORTCUTS = {
            a: "animate",
            an: "attributeName",
            at: "animateTransform",
            c: "circle",
            da: "stroke-dasharray",
            os: "stroke-dashoffset",
            f: "fill",
            lc: "stroke-linecap",
            rc: "repeatCount",
            sw: "stroke-width",
            t: "transform",
            v: "values"
        }, SPIN_ANIMATION = {
            v: "0,32,32;360,32,32",
            an: "transform",
            type: "rotate",
            rc: INDEFINITE,
            dur: DURATION
        }, IOS_SPINNER = {
            sw: 4,
            lc: ROUND,
            line: [ {
                fn: function(i, spinnerName) {
                    return {
                        y1: "ios" == spinnerName ? 17 : 12,
                        y2: "ios" == spinnerName ? 29 : 20,
                        t: TRANSLATE32 + " rotate(" + (30 * i + (6 > i ? 180 : -180)) + ")",
                        a: [ {
                            fn: function() {
                                return {
                                    an: STROKE_OPACITY,
                                    dur: DURATION,
                                    v: animationValues("0;.1;.15;.25;.35;.45;.55;.65;.7;.85;1", i),
                                    rc: INDEFINITE
                                };
                            },
                            t: 1
                        } ]
                    };
                },
                t: 12
            } ]
        }, spinners = {
            android: {
                c: [ {
                    sw: 6,
                    da: 128,
                    os: 82,
                    r: 26,
                    cx: 32,
                    cy: 32,
                    f: NONE
                } ]
            },
            ios: IOS_SPINNER,
            "ios-small": IOS_SPINNER,
            bubbles: {
                sw: 0,
                c: [ {
                    fn: function(i) {
                        return {
                            cx: 24 * Math.cos(2 * Math.PI * i / 8),
                            cy: 24 * Math.sin(2 * Math.PI * i / 8),
                            t: TRANSLATE32,
                            a: [ {
                                fn: function() {
                                    return {
                                        an: "r",
                                        dur: DURATION,
                                        v: animationValues("1;2;3;4;5;6;7;8", i),
                                        rc: INDEFINITE
                                    };
                                },
                                t: 1
                            } ]
                        };
                    },
                    t: 8
                } ]
            },
            circles: {
                c: [ {
                    fn: function(i) {
                        return {
                            r: 5,
                            cx: 24 * Math.cos(2 * Math.PI * i / 8),
                            cy: 24 * Math.sin(2 * Math.PI * i / 8),
                            t: TRANSLATE32,
                            sw: 0,
                            a: [ {
                                fn: function() {
                                    return {
                                        an: "fill-opacity",
                                        dur: DURATION,
                                        v: animationValues(".3;.3;.3;.4;.7;.85;.9;1", i),
                                        rc: INDEFINITE
                                    };
                                },
                                t: 1
                            } ]
                        };
                    },
                    t: 8
                } ]
            },
            crescent: {
                c: [ {
                    sw: 4,
                    da: 128,
                    os: 82,
                    r: 26,
                    cx: 32,
                    cy: 32,
                    f: NONE,
                    at: [ SPIN_ANIMATION ]
                } ]
            },
            dots: {
                c: [ {
                    fn: function(i) {
                        return {
                            cx: 16 + 16 * i,
                            cy: 32,
                            sw: 0,
                            a: [ {
                                fn: function() {
                                    return {
                                        an: "fill-opacity",
                                        dur: DURATION,
                                        v: animationValues(".5;.6;.8;1;.8;.6;.5", i),
                                        rc: INDEFINITE
                                    };
                                },
                                t: 1
                            }, {
                                fn: function() {
                                    return {
                                        an: "r",
                                        dur: DURATION,
                                        v: animationValues("4;5;6;5;4;3;3", i),
                                        rc: INDEFINITE
                                    };
                                },
                                t: 1
                            } ]
                        };
                    },
                    t: 3
                } ]
            },
            lines: {
                sw: 7,
                lc: ROUND,
                line: [ {
                    fn: function(i) {
                        return {
                            x1: 10 + 14 * i,
                            x2: 10 + 14 * i,
                            a: [ {
                                fn: function() {
                                    return {
                                        an: "y1",
                                        dur: DURATION,
                                        v: animationValues("16;18;28;18;16", i),
                                        rc: INDEFINITE
                                    };
                                },
                                t: 1
                            }, {
                                fn: function() {
                                    return {
                                        an: "y2",
                                        dur: DURATION,
                                        v: animationValues("48;44;36;46;48", i),
                                        rc: INDEFINITE
                                    };
                                },
                                t: 1
                            }, {
                                fn: function() {
                                    return {
                                        an: STROKE_OPACITY,
                                        dur: DURATION,
                                        v: animationValues("1;.8;.5;.4;1", i),
                                        rc: INDEFINITE
                                    };
                                },
                                t: 1
                            } ]
                        };
                    },
                    t: 4
                } ]
            },
            ripple: {
                f: NONE,
                "fill-rule": "evenodd",
                sw: 3,
                circle: [ {
                    fn: function(i) {
                        return {
                            cx: 32,
                            cy: 32,
                            a: [ {
                                fn: function() {
                                    return {
                                        an: "r",
                                        begin: -1 * i + "s",
                                        dur: "2s",
                                        v: "0;24",
                                        keyTimes: "0;1",
                                        keySplines: "0.1,0.2,0.3,1",
                                        calcMode: "spline",
                                        rc: INDEFINITE
                                    };
                                },
                                t: 1
                            }, {
                                fn: function() {
                                    return {
                                        an: STROKE_OPACITY,
                                        begin: -1 * i + "s",
                                        dur: "2s",
                                        v: ".2;1;.2;0",
                                        rc: INDEFINITE
                                    };
                                },
                                t: 1
                            } ]
                        };
                    },
                    t: 2
                } ]
            },
            spiral: {
                defs: [ {
                    linearGradient: [ {
                        id: "sGD",
                        gradientUnits: "userSpaceOnUse",
                        x1: 55,
                        y1: 46,
                        x2: 2,
                        y2: 46,
                        stop: [ {
                            offset: .1,
                            "class": "stop1"
                        }, {
                            offset: 1,
                            "class": "stop2"
                        } ]
                    } ]
                } ],
                g: [ {
                    sw: 4,
                    lc: ROUND,
                    f: NONE,
                    path: [ {
                        stroke: "url(#sGD)",
                        d: "M4,32 c0,15,12,28,28,28c8,0,16-4,21-9"
                    }, {
                        d: "M60,32 C60,16,47.464,4,32,4S4,16,4,32"
                    } ],
                    at: [ SPIN_ANIMATION ]
                } ]
            }
        }, animations = {
            android: function(ele) {
                function run() {
                    if (!self.stop) {
                        var v = easeInOutCubic(Date.now() - startTime, 650), scaleX = 1, translateX = 0, dasharray = 188 - 58 * v, dashoffset = 182 - 182 * v;
                        rIndex % 2 && (scaleX = -1, translateX = -64, dasharray = 128 - -58 * v, dashoffset = 182 * v);
                        var rotateLine = [ 0, -101, -90, -11, -180, 79, -270, -191 ][rIndex];
                        setSvgAttribute(circleEle, "da", Math.max(Math.min(dasharray, 188), 128)), setSvgAttribute(circleEle, "os", Math.max(Math.min(dashoffset, 182), 0)), 
                        setSvgAttribute(circleEle, "t", "scale(" + scaleX + ",1) translate(" + translateX + ",0) rotate(" + rotateLine + ",32,32)"), 
                        rotateCircle += 4.1, rotateCircle > 359 && (rotateCircle = 0), setSvgAttribute(svgEle, "t", "rotate(" + rotateCircle + ",32,32)"), 
                        v >= 1 && (rIndex++, rIndex > 7 && (rIndex = 0), startTime = Date.now()), ionic.requestAnimationFrame(run);
                    }
                }
                var self = this;
                this.stop = !1;
                var startTime, rIndex = 0, rotateCircle = 0, svgEle = ele.querySelector("g"), circleEle = ele.querySelector("circle");
                return function() {
                    return startTime = Date.now(), run(), self;
                };
            }
        };
        IonicModule.controller("$ionicSpinner", [ "$element", "$attrs", "$ionicConfig", function($element, $attrs, $ionicConfig) {
            var spinnerName, anim;
            this.init = function() {
                spinnerName = $attrs.icon || $ionicConfig.spinner.icon();
                var container = document.createElement("div");
                return createSvgElement("svg", {
                    viewBox: "0 0 64 64",
                    g: [ spinners[spinnerName] ]
                }, container, spinnerName), $element.html(container.innerHTML), this.start(), spinnerName;
            }, this.start = function() {
                animations[spinnerName] && (anim = animations[spinnerName]($element[0])());
            }, this.stop = function() {
                animations[spinnerName] && (anim.stop = !0);
            };
        } ]);
    }(ionic), IonicModule.controller("$ionicTab", [ "$scope", "$ionicHistory", "$attrs", "$location", "$state", function($scope, $ionicHistory, $attrs, $location, $state) {
        this.$scope = $scope, this.hrefMatchesState = function() {
            return $attrs.href && 0 === $location.path().indexOf($attrs.href.replace(/^#/, "").replace(/\/$/, ""));
        }, this.srefMatchesState = function() {
            return $attrs.uiSref && $state.includes($attrs.uiSref.split("(")[0]);
        }, this.navNameMatchesState = function() {
            return this.navViewName && $ionicHistory.isCurrentStateNavView(this.navViewName);
        }, this.tabMatchesState = function() {
            return this.hrefMatchesState() || this.srefMatchesState() || this.navNameMatchesState();
        };
    } ]), IonicModule.controller("$ionicTabs", [ "$scope", "$element", "$ionicHistory", function($scope, $element, $ionicHistory) {
        var selectedTabIndex, self = this, selectedTab = null, previousSelectedTab = null, isVisible = !0;
        self.tabs = [], self.selectedIndex = function() {
            return self.tabs.indexOf(selectedTab);
        }, self.selectedTab = function() {
            return selectedTab;
        }, self.previousSelectedTab = function() {
            return previousSelectedTab;
        }, self.add = function(tab) {
            $ionicHistory.registerHistory(tab), self.tabs.push(tab);
        }, self.remove = function(tab) {
            var tabIndex = self.tabs.indexOf(tab);
            if (-1 !== tabIndex) {
                if (tab.$tabSelected) if (self.deselect(tab), 1 === self.tabs.length) ; else {
                    var newTabIndex = tabIndex === self.tabs.length - 1 ? tabIndex - 1 : tabIndex + 1;
                    self.select(self.tabs[newTabIndex]);
                }
                self.tabs.splice(tabIndex, 1);
            }
        }, self.deselect = function(tab) {
            tab.$tabSelected && (previousSelectedTab = selectedTab, selectedTab = selectedTabIndex = null, 
            tab.$tabSelected = !1, (tab.onDeselect || noop)(), tab.$broadcast && tab.$broadcast("$ionicHistory.deselect"));
        }, self.select = function(tab, shouldEmitEvent) {
            var tabIndex;
            if (isNumber(tab)) {
                if (tabIndex = tab, tabIndex >= self.tabs.length) return;
                tab = self.tabs[tabIndex];
            } else tabIndex = self.tabs.indexOf(tab);
            1 === arguments.length && (shouldEmitEvent = !(!tab.navViewName && !tab.uiSref)), 
            selectedTab && selectedTab.$historyId == tab.$historyId ? shouldEmitEvent && $ionicHistory.goToHistoryRoot(tab.$historyId) : selectedTabIndex !== tabIndex && (forEach(self.tabs, function(tab) {
                self.deselect(tab);
            }), selectedTab = tab, selectedTabIndex = tabIndex, self.$scope && self.$scope.$parent && (self.$scope.$parent.$activeHistoryId = tab.$historyId), 
            tab.$tabSelected = !0, (tab.onSelect || noop)(), shouldEmitEvent && $scope.$emit("$ionicHistory.change", {
                type: "tab",
                tabIndex: tabIndex,
                historyId: tab.$historyId,
                navViewName: tab.navViewName,
                hasNavView: !!tab.navViewName,
                title: tab.title,
                url: tab.href,
                uiSref: tab.uiSref
            }));
        }, self.hasActiveScope = function() {
            for (var x = 0; x < self.tabs.length; x++) if ($ionicHistory.isActiveScope(self.tabs[x])) return !0;
            return !1;
        }, self.showBar = function(show) {
            return arguments.length && (show ? $element.removeClass("tabs-item-hide") : $element.addClass("tabs-item-hide"), 
            isVisible = !!show), isVisible;
        };
    } ]), IonicModule.controller("$ionicView", [ "$scope", "$element", "$attrs", "$compile", "$rootScope", function($scope, $element, $attrs, $compile, $rootScope) {
        function afterEnter() {
            var viewTitleAttr = isDefined($attrs.viewTitle) && "viewTitle" || isDefined($attrs.title) && "title";
            viewTitleAttr && (titleUpdate($attrs[viewTitleAttr]), deregisters.push($attrs.$observe(viewTitleAttr, titleUpdate))), 
            isDefined($attrs.hideBackButton) && deregisters.push($scope.$watch($attrs.hideBackButton, function(val) {
                navViewCtrl.showBackButton(!val);
            })), isDefined($attrs.hideNavBar) && deregisters.push($scope.$watch($attrs.hideNavBar, function(val) {
                navViewCtrl.showBar(!val);
            }));
        }
        function titleUpdate(newTitle) {
            isDefined(newTitle) && newTitle !== viewTitle && (viewTitle = newTitle, navViewCtrl.title(viewTitle));
        }
        function deregisterFns() {
            for (var x = 0; x < deregisters.length; x++) deregisters[x]();
            deregisters = [];
        }
        function generateNavBarItem(html) {
            return html ? $compile(html)($scope.$new()) : void 0;
        }
        function attrTrue(key) {
            return !!$scope.$eval($attrs[key]);
        }
        var navViewCtrl, navBarDelegateHandle, hasViewHeaderBar, viewTitle, self = this, navElementHtml = {}, deregisters = [], deregIonNavBarInit = $scope.$on("ionNavBar.init", function(ev, delegateHandle) {
            ev.stopPropagation(), navBarDelegateHandle = delegateHandle;
        });
        self.init = function() {
            deregIonNavBarInit();
            var modalCtrl = $element.inheritedData("$ionModalController");
            navViewCtrl = $element.inheritedData("$ionNavViewController"), navViewCtrl && !modalCtrl && ($scope.$on("$ionicView.beforeEnter", self.beforeEnter), 
            $scope.$on("$ionicView.afterEnter", afterEnter), $scope.$on("$ionicView.beforeLeave", deregisterFns));
        }, self.beforeEnter = function(ev, transData) {
            if (transData && !transData.viewNotified) {
                transData.viewNotified = !0, $rootScope.$$phase || $scope.$digest(), viewTitle = isDefined($attrs.viewTitle) ? $attrs.viewTitle : $attrs.title;
                var navBarItems = {};
                for (var n in navElementHtml) navBarItems[n] = generateNavBarItem(navElementHtml[n]);
                navViewCtrl.beforeEnter(extend(transData, {
                    title: viewTitle,
                    showBack: !attrTrue("hideBackButton"),
                    navBarItems: navBarItems,
                    navBarDelegate: navBarDelegateHandle || null,
                    showNavBar: !attrTrue("hideNavBar"),
                    hasHeaderBar: !!hasViewHeaderBar
                })), deregisterFns();
            }
        }, self.navElement = function(type, html) {
            navElementHtml[type] = html;
        };
    } ]), IonicModule.directive("ionActionSheet", [ "$document", function($document) {
        return {
            restrict: "E",
            scope: !0,
            replace: !0,
            link: function($scope, $element) {
                var keyUp = function(e) {
                    27 == e.which && ($scope.cancel(), $scope.$apply());
                }, backdropClick = function(e) {
                    e.target == $element[0] && ($scope.cancel(), $scope.$apply());
                };
                $scope.$on("$destroy", function() {
                    $element.remove(), $document.unbind("keyup", keyUp);
                }), $document.bind("keyup", keyUp), $element.bind("click", backdropClick);
            },
            template: '<div class="action-sheet-backdrop"><div class="action-sheet-wrapper"><div class="action-sheet" ng-class="{\'action-sheet-has-icons\': $actionSheetHasIcon}"><div class="action-sheet-group action-sheet-options"><div class="action-sheet-title" ng-if="titleText" ng-bind-html="titleText"></div><button class="button action-sheet-option" ng-click="buttonClicked($index)" ng-class="b.className" ng-repeat="b in buttons" ng-bind-html="b.text"></button><button class="button destructive action-sheet-destructive" ng-if="destructiveText" ng-click="destructiveButtonClicked()" ng-bind-html="destructiveText"></button></div><div class="action-sheet-group action-sheet-cancel" ng-if="cancelText"><button class="button" ng-click="cancel()" ng-bind-html="cancelText"></button></div></div></div></div>'
        };
    } ]), IonicModule.directive("ionCheckbox", [ "$ionicConfig", function($ionicConfig) {
        return {
            restrict: "E",
            replace: !0,
            require: "?ngModel",
            transclude: !0,
            template: '<label class="item item-checkbox"><div class="checkbox checkbox-input-hidden disable-pointer-events"><input type="checkbox"><i class="checkbox-icon"></i></div><div class="item-content disable-pointer-events" ng-transclude></div></label>',
            compile: function(element, attr) {
                var input = element.find("input");
                forEach({
                    name: attr.name,
                    "ng-value": attr.ngValue,
                    "ng-model": attr.ngModel,
                    "ng-checked": attr.ngChecked,
                    "ng-disabled": attr.ngDisabled,
                    "ng-true-value": attr.ngTrueValue,
                    "ng-false-value": attr.ngFalseValue,
                    "ng-change": attr.ngChange,
                    "ng-required": attr.ngRequired,
                    required: attr.required
                }, function(value, name) {
                    isDefined(value) && input.attr(name, value);
                });
                var checkboxWrapper = element[0].querySelector(".checkbox");
                checkboxWrapper.classList.add("checkbox-" + $ionicConfig.form.checkbox());
            }
        };
    } ]), IonicModule.directive("collectionRepeat", CollectionRepeatDirective).factory("$ionicCollectionManager", RepeatManagerFactory);
    var ONE_PX_TRANSPARENT_IMG_SRC = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7", WIDTH_HEIGHT_REGEX = /height:.*?px;\s*width:.*?px/, DEFAULT_RENDER_BUFFER = 3;
    CollectionRepeatDirective.$inject = [ "$ionicCollectionManager", "$parse", "$window", "$$rAF", "$rootScope", "$timeout" ], 
    RepeatManagerFactory.$inject = [ "$rootScope", "$window", "$$rAF" ], IonicModule.directive("ionContent", [ "$timeout", "$controller", "$ionicBind", "$ionicConfig", function($timeout, $controller, $ionicBind, $ionicConfig) {
        return {
            restrict: "E",
            require: "^?ionNavView",
            scope: !0,
            priority: 800,
            compile: function(element, attr) {
                function prelink($scope, $element, $attr) {
                    function onScrollComplete() {
                        $scope.$onScrollComplete({
                            scrollTop: scrollCtrl.scrollView.__scrollTop,
                            scrollLeft: scrollCtrl.scrollView.__scrollLeft
                        });
                    }
                    var parentScope = $scope.$parent;
                    if ($scope.$watch(function() {
                        return (parentScope.$hasHeader ? " has-header" : "") + (parentScope.$hasSubheader ? " has-subheader" : "") + (parentScope.$hasFooter ? " has-footer" : "") + (parentScope.$hasSubfooter ? " has-subfooter" : "") + (parentScope.$hasTabs ? " has-tabs" : "") + (parentScope.$hasTabsTop ? " has-tabs-top" : "");
                    }, function(className, oldClassName) {
                        $element.removeClass(oldClassName), $element.addClass(className);
                    }), $scope.$hasHeader = $scope.$hasSubheader = $scope.$hasFooter = $scope.$hasSubfooter = $scope.$hasTabs = $scope.$hasTabsTop = !1, 
                    $ionicBind($scope, $attr, {
                        $onScroll: "&onScroll",
                        $onScrollComplete: "&onScrollComplete",
                        hasBouncing: "@",
                        padding: "@",
                        direction: "@",
                        scrollbarX: "@",
                        scrollbarY: "@",
                        startX: "@",
                        startY: "@",
                        scrollEventInterval: "@"
                    }), $scope.direction = $scope.direction || "y", isDefined($attr.padding) && $scope.$watch($attr.padding, function(newVal) {
                        (innerElement || $element).toggleClass("padding", !!newVal);
                    }), "false" === $attr.scroll) ; else {
                        var scrollViewOptions = {};
                        nativeScrolling ? ($element.addClass("overflow-scroll"), scrollViewOptions = {
                            el: $element[0],
                            delegateHandle: attr.delegateHandle,
                            startX: $scope.$eval($scope.startX) || 0,
                            startY: $scope.$eval($scope.startY) || 0,
                            nativeScrolling: !0
                        }) : scrollViewOptions = {
                            el: $element[0],
                            delegateHandle: attr.delegateHandle,
                            locking: "true" === (attr.locking || "true"),
                            bouncing: $scope.$eval($scope.hasBouncing),
                            startX: $scope.$eval($scope.startX) || 0,
                            startY: $scope.$eval($scope.startY) || 0,
                            scrollbarX: $scope.$eval($scope.scrollbarX) !== !1,
                            scrollbarY: $scope.$eval($scope.scrollbarY) !== !1,
                            scrollingX: $scope.direction.indexOf("x") >= 0,
                            scrollingY: $scope.direction.indexOf("y") >= 0,
                            scrollEventInterval: parseInt($scope.scrollEventInterval, 10) || 10,
                            scrollingComplete: onScrollComplete
                        }, scrollCtrl = $controller("$ionicScroll", {
                            $scope: $scope,
                            scrollViewOptions: scrollViewOptions
                        }), $scope.scrollCtrl = scrollCtrl, $scope.$on("$destroy", function() {
                            scrollViewOptions && (scrollViewOptions.scrollingComplete = noop, delete scrollViewOptions.el), 
                            innerElement = null, $element = null, attr.$$element = null;
                        });
                    }
                }
                var innerElement, scrollCtrl;
                element.addClass("scroll-content ionic-scroll"), "false" != attr.scroll ? (innerElement = jqLite('<div class="scroll"></div>'), 
                innerElement.append(element.contents()), element.append(innerElement)) : element.addClass("scroll-content-false");
                var nativeScrolling = "false" !== attr.overflowScroll && ("true" === attr.overflowScroll || !$ionicConfig.scrolling.jsScrolling());
                return nativeScrolling && (nativeScrolling = !element[0].querySelector("[collection-repeat]")), 
                {
                    pre: prelink
                };
            }
        };
    } ]), IonicModule.directive("exposeAsideWhen", [ "$window", function($window) {
        return {
            restrict: "A",
            require: "^ionSideMenus",
            link: function($scope, $element, $attr, sideMenuCtrl) {
                function checkAsideExpose() {
                    var mq = "large" == $attr.exposeAsideWhen ? "(min-width:768px)" : $attr.exposeAsideWhen;
                    sideMenuCtrl.exposeAside($window.matchMedia(mq).matches), sideMenuCtrl.activeAsideResizing(!1);
                }
                function onResize() {
                    sideMenuCtrl.activeAsideResizing(!0), debouncedCheck();
                }
                var mq = "large" == $attr.exposeAsideWhen ? "(min-width:768px)" : $attr.exposeAsideWhen, mql = $window.matchMedia(mq);
                mql.addListener(function() {
                    onResize();
                });
                var debouncedCheck = ionic.debounce(function() {
                    $scope.$apply(checkAsideExpose);
                }, 300, !1);
                $scope.$evalAsync(checkAsideExpose);
            }
        };
    } ]);
    var GESTURE_DIRECTIVES = "onHold onTap onDoubleTap onTouch onRelease onDragStart onDrag onDragEnd onDragUp onDragRight onDragDown onDragLeft onSwipe onSwipeUp onSwipeRight onSwipeDown onSwipeLeft".split(" ");
    GESTURE_DIRECTIVES.forEach(function(name) {
        IonicModule.directive(name, gestureDirective(name));
    }), IonicModule.directive("ionHeaderBar", headerFooterBarDirective(!0)).directive("ionFooterBar", headerFooterBarDirective(!1)), 
    IonicModule.directive("ionInfiniteScroll", [ "$timeout", function($timeout) {
        return {
            restrict: "E",
            require: [ "?^$ionicScroll", "ionInfiniteScroll" ],
            template: function($element, $attrs) {
                return $attrs.icon ? '<i class="icon {{icon()}} icon-refreshing {{scrollingType}}"></i>' : '<ion-spinner icon="{{spinner()}}"></ion-spinner>';
            },
            scope: !0,
            controller: "$ionInfiniteScroll",
            link: function($scope, $element, $attrs, ctrls) {
                var infiniteScrollCtrl = ctrls[1], scrollCtrl = infiniteScrollCtrl.scrollCtrl = ctrls[0], jsScrolling = infiniteScrollCtrl.jsScrolling = !scrollCtrl.isNative();
                if (jsScrolling) infiniteScrollCtrl.scrollView = scrollCtrl.scrollView, $scope.scrollingType = "js-scrolling", 
                scrollCtrl.$element.on("scroll", infiniteScrollCtrl.checkBounds); else {
                    var scrollEl = ionic.DomUtil.getParentOrSelfWithClass($element[0].parentNode, "overflow-scroll");
                    if (infiniteScrollCtrl.scrollEl = scrollEl, !scrollEl) throw "Infinite scroll must be used inside a scrollable div";
                    infiniteScrollCtrl.scrollEl.addEventListener("scroll", infiniteScrollCtrl.checkBounds);
                }
                var doImmediateCheck = isDefined($attrs.immediateCheck) ? $scope.$eval($attrs.immediateCheck) : !0;
                doImmediateCheck && $timeout(function() {
                    infiniteScrollCtrl.checkBounds();
                });
            }
        };
    } ]);
    var labelIds = -1;
    IonicModule.directive("ionInput", [ function() {
        return {
            restrict: "E",
            controller: [ "$scope", "$element", function($scope, $element) {
                this.$scope = $scope, this.$element = $element, this.setInputAriaLabeledBy = function(id) {
                    var inputs = $element[0].querySelectorAll("input,textarea");
                    inputs.length && inputs[0].setAttribute("aria-labelledby", id);
                }, this.focus = function() {
                    var inputs = $element[0].querySelectorAll("input,textarea");
                    inputs.length && inputs[0].focus();
                };
            } ]
        };
    } ]), IonicModule.directive("ionLabel", [ "$timeout", function($timeout) {
        return {
            restrict: "E",
            require: "?^ionInput",
            compile: function() {
                return function($scope, $element, $attrs, ionInputCtrl) {
                    var element = $element[0];
                    $element.addClass("input-label"), $element.attr("aria-label", $element.text());
                    var id = element.id || "_label-" + ++labelIds;
                    element.id || $element.attr("id", id), ionInputCtrl && (ionInputCtrl.setInputAriaLabeledBy(id), 
                    $element.on("click", function() {
                        $timeout(function() {
                            ionInputCtrl.focus();
                        });
                    }));
                };
            }
        };
    } ]), IonicModule.directive("inputLabel", [ function() {
        return {
            restrict: "C",
            require: "?^ionInput",
            compile: function() {
                return function($scope, $element, $attrs, ionInputCtrl) {
                    var element = $element[0];
                    $element.attr("aria-label", $element.text());
                    var id = element.id || "_label-" + ++labelIds;
                    element.id || $element.attr("id", id), ionInputCtrl && ionInputCtrl.setInputAriaLabeledBy(id);
                };
            }
        };
    } ]), IonicModule.directive("ionItem", [ "$$rAF", function($$rAF) {
        return {
            restrict: "E",
            controller: [ "$scope", "$element", function($scope, $element) {
                this.$scope = $scope, this.$element = $element;
            } ],
            scope: !0,
            compile: function($element, $attrs) {
                var isAnchor = isDefined($attrs.href) || isDefined($attrs.ngHref) || isDefined($attrs.uiSref), isComplexItem = isAnchor || /ion-(delete|option|reorder)-button/i.test($element.html());
                if (isComplexItem) {
                    var innerElement = jqLite(isAnchor ? "<a></a>" : "<div></div>");
                    innerElement.addClass("item-content"), (isDefined($attrs.href) || isDefined($attrs.ngHref)) && (innerElement.attr("ng-href", "{{$href()}}"), 
                    isDefined($attrs.target) && innerElement.attr("target", "{{$target()}}")), innerElement.append($element.contents()), 
                    $element.addClass("item item-complex").append(innerElement);
                } else $element.addClass("item");
                return function($scope, $element, $attrs) {
                    $scope.$href = function() {
                        return $attrs.href || $attrs.ngHref;
                    }, $scope.$target = function() {
                        return $attrs.target;
                    };
                    var content = $element[0].querySelector(".item-content");
                    content && $scope.$on("$collectionRepeatLeave", function() {
                        content && content.$$ionicOptionsOpen && (content.style[ionic.CSS.TRANSFORM] = "", 
                        content.style[ionic.CSS.TRANSITION] = "none", $$rAF(function() {
                            content.style[ionic.CSS.TRANSITION] = "";
                        }), content.$$ionicOptionsOpen = !1);
                    });
                };
            }
        };
    } ]);
    var ITEM_TPL_DELETE_BUTTON = '<div class="item-left-edit item-delete enable-pointer-events"></div>';
    IonicModule.directive("ionDeleteButton", function() {
        function stopPropagation(ev) {
            ev.stopPropagation();
        }
        return {
            restrict: "E",
            require: [ "^^ionItem", "^?ionList" ],
            priority: Number.MAX_VALUE,
            compile: function($element, $attr) {
                return $attr.$set("class", ($attr["class"] || "") + " button icon button-icon", !0), 
                function($scope, $element, $attr, ctrls) {
                    function init() {
                        listCtrl = listCtrl || $element.controller("ionList"), listCtrl && listCtrl.showDelete() && container.addClass("visible active");
                    }
                    var itemCtrl = ctrls[0], listCtrl = ctrls[1], container = jqLite(ITEM_TPL_DELETE_BUTTON);
                    container.append($element), itemCtrl.$element.append(container).addClass("item-left-editable"), 
                    $element.on("click", stopPropagation), init(), $scope.$on("$ionic.reconnectScope", init);
                };
            }
        };
    }), IonicModule.directive("itemFloatingLabel", function() {
        return {
            restrict: "C",
            link: function(scope, element) {
                var el = element[0], input = el.querySelector("input, textarea"), inputLabel = el.querySelector(".input-label");
                if (input && inputLabel) {
                    var onInput = function() {
                        input.value ? inputLabel.classList.add("has-input") : inputLabel.classList.remove("has-input");
                    };
                    input.addEventListener("input", onInput);
                    var ngModelCtrl = jqLite(input).controller("ngModel");
                    ngModelCtrl && (ngModelCtrl.$render = function() {
                        input.value = ngModelCtrl.$viewValue || "", onInput();
                    }), scope.$on("$destroy", function() {
                        input.removeEventListener("input", onInput);
                    });
                }
            }
        };
    });
    var ITEM_TPL_OPTION_BUTTONS = '<div class="item-options invisible"></div>';
    IonicModule.directive("ionOptionButton", [ function() {
        function stopPropagation(e) {
            e.stopPropagation();
        }
        return {
            restrict: "E",
            require: "^ionItem",
            priority: Number.MAX_VALUE,
            compile: function($element, $attr) {
                return $attr.$set("class", ($attr["class"] || "") + " button", !0), function($scope, $element, $attr, itemCtrl) {
                    itemCtrl.optionsContainer || (itemCtrl.optionsContainer = jqLite(ITEM_TPL_OPTION_BUTTONS), 
                    itemCtrl.$element.append(itemCtrl.optionsContainer)), itemCtrl.optionsContainer.append($element), 
                    itemCtrl.$element.addClass("item-right-editable"), $element.on("click", stopPropagation);
                };
            }
        };
    } ]);
    var ITEM_TPL_REORDER_BUTTON = '<div data-prevent-scroll="true" class="item-right-edit item-reorder enable-pointer-events"></div>';
    IonicModule.directive("ionReorderButton", [ "$parse", function($parse) {
        return {
            restrict: "E",
            require: [ "^ionItem", "^?ionList" ],
            priority: Number.MAX_VALUE,
            compile: function($element, $attr) {
                return $attr.$set("class", ($attr["class"] || "") + " button icon button-icon", !0), 
                $element[0].setAttribute("data-prevent-scroll", !0), function($scope, $element, $attr, ctrls) {
                    var itemCtrl = ctrls[0], listCtrl = ctrls[1], onReorderFn = $parse($attr.onReorder);
                    $scope.$onReorder = function(oldIndex, newIndex) {
                        onReorderFn($scope, {
                            $fromIndex: oldIndex,
                            $toIndex: newIndex
                        });
                    }, $attr.ngClick || $attr.onClick || $attr.onclick || ($element[0].onclick = function(e) {
                        return e.stopPropagation(), !1;
                    });
                    var container = jqLite(ITEM_TPL_REORDER_BUTTON);
                    container.append($element), itemCtrl.$element.append(container).addClass("item-right-editable"), 
                    listCtrl && listCtrl.showReorder() && container.addClass("visible active");
                };
            }
        };
    } ]), IonicModule.directive("keyboardAttach", function() {
        return function(scope, element) {
            function onShow(e) {
                if (!ionic.Platform.isAndroid() || ionic.Platform.isFullScreen) {
                    var keyboardHeight = e.keyboardHeight || e.detail && e.detail.keyboardHeight;
                    element.css("bottom", keyboardHeight + "px"), scrollCtrl = element.controller("$ionicScroll"), 
                    scrollCtrl && (scrollCtrl.scrollView.__container.style.bottom = keyboardHeight + keyboardAttachGetClientHeight(element[0]) + "px");
                }
            }
            function onHide() {
                (!ionic.Platform.isAndroid() || ionic.Platform.isFullScreen) && (element.css("bottom", ""), 
                scrollCtrl && (scrollCtrl.scrollView.__container.style.bottom = ""));
            }
            ionic.on("native.keyboardshow", onShow, window), ionic.on("native.keyboardhide", onHide, window), 
            ionic.on("native.showkeyboard", onShow, window), ionic.on("native.hidekeyboard", onHide, window);
            var scrollCtrl;
            scope.$on("$destroy", function() {
                ionic.off("native.keyboardshow", onShow, window), ionic.off("native.keyboardhide", onHide, window), 
                ionic.off("native.showkeyboard", onShow, window), ionic.off("native.hidekeyboard", onHide, window);
            });
        };
    }), IonicModule.directive("ionList", [ "$timeout", function($timeout) {
        return {
            restrict: "E",
            require: [ "ionList", "^?$ionicScroll" ],
            controller: "$ionicList",
            compile: function($element, $attr) {
                var listEl = jqLite('<div class="list">').append($element.contents()).addClass($attr.type);
                return $element.append(listEl), function($scope, $element, $attrs, ctrls) {
                    function init() {
                        function setButtonShown(el, shown) {
                            shown() && el.addClass("visible") || el.removeClass("active"), ionic.requestAnimationFrame(function() {
                                shown() && el.addClass("active") || el.removeClass("visible");
                            });
                        }
                        var listView = listCtrl.listView = new ionic.views.ListView({
                            el: $element[0],
                            listEl: $element.children()[0],
                            scrollEl: scrollCtrl && scrollCtrl.element,
                            scrollView: scrollCtrl && scrollCtrl.scrollView,
                            onReorder: function(el, oldIndex, newIndex) {
                                var itemScope = jqLite(el).scope();
                                itemScope && itemScope.$onReorder && $timeout(function() {
                                    itemScope.$onReorder(oldIndex, newIndex);
                                });
                            },
                            canSwipe: function() {
                                return listCtrl.canSwipeItems();
                            }
                        });
                        $scope.$on("$destroy", function() {
                            listView && (listView.deregister && listView.deregister(), listView = null);
                        }), isDefined($attr.canSwipe) && $scope.$watch("!!(" + $attr.canSwipe + ")", function(value) {
                            listCtrl.canSwipeItems(value);
                        }), isDefined($attr.showDelete) && $scope.$watch("!!(" + $attr.showDelete + ")", function(value) {
                            listCtrl.showDelete(value);
                        }), isDefined($attr.showReorder) && $scope.$watch("!!(" + $attr.showReorder + ")", function(value) {
                            listCtrl.showReorder(value);
                        }), $scope.$watch(function() {
                            return listCtrl.showDelete();
                        }, function(isShown, wasShown) {
                            if (isShown || wasShown) {
                                isShown && listCtrl.closeOptionButtons(), listCtrl.canSwipeItems(!isShown), $element.children().toggleClass("list-left-editing", isShown), 
                                $element.toggleClass("disable-pointer-events", isShown);
                                var deleteButton = jqLite($element[0].getElementsByClassName("item-delete"));
                                setButtonShown(deleteButton, listCtrl.showDelete);
                            }
                        }), $scope.$watch(function() {
                            return listCtrl.showReorder();
                        }, function(isShown, wasShown) {
                            if (isShown || wasShown) {
                                isShown && listCtrl.closeOptionButtons(), listCtrl.canSwipeItems(!isShown), $element.children().toggleClass("list-right-editing", isShown), 
                                $element.toggleClass("disable-pointer-events", isShown);
                                var reorderButton = jqLite($element[0].getElementsByClassName("item-reorder"));
                                setButtonShown(reorderButton, listCtrl.showReorder);
                            }
                        });
                    }
                    var listCtrl = ctrls[0], scrollCtrl = ctrls[1];
                    $timeout(init);
                };
            }
        };
    } ]), IonicModule.directive("menuClose", [ "$ionicHistory", "$timeout", function($ionicHistory, $timeout) {
        return {
            restrict: "AC",
            link: function($scope, $element) {
                $element.bind("click", function() {
                    var sideMenuCtrl = $element.inheritedData("$ionSideMenusController");
                    sideMenuCtrl && ($ionicHistory.nextViewOptions({
                        historyRoot: !0,
                        disableAnimate: !0,
                        expire: 300
                    }), $timeout(function() {
                        $ionicHistory.nextViewOptions({
                            historyRoot: !1,
                            disableAnimate: !1
                        });
                    }, 300), sideMenuCtrl.close());
                });
            }
        };
    } ]), IonicModule.directive("menuToggle", function() {
        return {
            restrict: "AC",
            link: function($scope, $element, $attr) {
                $scope.$on("$ionicView.beforeEnter", function(ev, viewData) {
                    if (viewData.enableBack) {
                        var sideMenuCtrl = $element.inheritedData("$ionSideMenusController");
                        sideMenuCtrl.enableMenuWithBackViews() || $element.addClass("hide");
                    } else $element.removeClass("hide");
                }), $element.bind("click", function() {
                    var sideMenuCtrl = $element.inheritedData("$ionSideMenusController");
                    sideMenuCtrl && sideMenuCtrl.toggle($attr.menuToggle);
                });
            }
        };
    }), IonicModule.directive("ionModal", [ function() {
        return {
            restrict: "E",
            transclude: !0,
            replace: !0,
            controller: [ function() {} ],
            template: '<div class="modal-backdrop"><div class="modal-backdrop-bg"></div><div class="modal-wrapper" ng-transclude></div></div>'
        };
    } ]), IonicModule.directive("ionModalView", function() {
        return {
            restrict: "E",
            compile: function(element) {
                element.addClass("modal");
            }
        };
    }), IonicModule.directive("ionNavBackButton", [ "$ionicConfig", "$document", function($ionicConfig, $document) {
        return {
            restrict: "E",
            require: "^ionNavBar",
            compile: function(tElement, tAttrs) {
                function hasIconClass(ele) {
                    return /ion-|icon/.test(ele.className);
                }
                var buttonEle = $document[0].createElement("button");
                for (var n in tAttrs.$attr) buttonEle.setAttribute(tAttrs.$attr[n], tAttrs[n]);
                tAttrs.ngClick || buttonEle.setAttribute("ng-click", "$ionicGoBack()"), buttonEle.className = "button back-button hide buttons " + (tElement.attr("class") || ""), 
                buttonEle.innerHTML = tElement.html() || "";
                for (var childNode, hasInnerText, hasButtonText, hasPreviousTitle, hasIcon = hasIconClass(tElement[0]), x = 0; x < tElement[0].childNodes.length; x++) childNode = tElement[0].childNodes[x], 
                1 === childNode.nodeType ? hasIconClass(childNode) ? hasIcon = !0 : childNode.classList.contains("default-title") ? hasButtonText = !0 : childNode.classList.contains("previous-title") && (hasPreviousTitle = !0) : hasInnerText || 3 !== childNode.nodeType || (hasInnerText = !!childNode.nodeValue.trim());
                var defaultIcon = $ionicConfig.backButton.icon();
                if (!hasIcon && defaultIcon && "none" !== defaultIcon && (buttonEle.innerHTML = '<i class="icon ' + defaultIcon + '"></i> ' + buttonEle.innerHTML, 
                buttonEle.className += " button-clear"), !hasInnerText) {
                    var buttonTextEle = $document[0].createElement("span");
                    buttonTextEle.className = "back-text", !hasButtonText && $ionicConfig.backButton.text() && (buttonTextEle.innerHTML += '<span class="default-title">' + $ionicConfig.backButton.text() + "</span>"), 
                    !hasPreviousTitle && $ionicConfig.backButton.previousTitleText() && (buttonTextEle.innerHTML += '<span class="previous-title"></span>'), 
                    buttonEle.appendChild(buttonTextEle);
                }
                return tElement.attr("class", "hide"), tElement.empty(), {
                    pre: function($scope, $element, $attr, navBarCtrl) {
                        navBarCtrl.navElement("backButton", buttonEle.outerHTML), buttonEle = null;
                    }
                };
            }
        };
    } ]), IonicModule.directive("ionNavBar", function() {
        return {
            restrict: "E",
            controller: "$ionicNavBar",
            scope: !0,
            link: function($scope, $element, $attr, ctrl) {
                ctrl.init();
            }
        };
    }), IonicModule.directive("ionNavButtons", [ "$document", function($document) {
        return {
            require: "^ionNavBar",
            restrict: "E",
            compile: function(tElement, tAttrs) {
                var side = "left";
                /^primary|secondary|right$/i.test(tAttrs.side || "") && (side = tAttrs.side.toLowerCase());
                var spanEle = $document[0].createElement("span");
                spanEle.className = side + "-buttons", spanEle.innerHTML = tElement.html();
                var navElementType = side + "Buttons";
                return tElement.attr("class", "hide"), tElement.empty(), {
                    pre: function($scope, $element, $attrs, navBarCtrl) {
                        var parentViewCtrl = $element.parent().data("$ionViewController");
                        parentViewCtrl ? parentViewCtrl.navElement(navElementType, spanEle.outerHTML) : navBarCtrl.navElement(navElementType, spanEle.outerHTML), 
                        spanEle = null;
                    }
                };
            }
        };
    } ]), IonicModule.directive("navDirection", [ "$ionicViewSwitcher", function($ionicViewSwitcher) {
        return {
            restrict: "A",
            priority: 1e3,
            link: function($scope, $element, $attr) {
                $element.bind("click", function() {
                    $ionicViewSwitcher.nextDirection($attr.navDirection);
                });
            }
        };
    } ]), IonicModule.directive("ionNavTitle", [ "$document", function($document) {
        return {
            require: "^ionNavBar",
            restrict: "E",
            compile: function(tElement, tAttrs) {
                var navElementType = "title", spanEle = $document[0].createElement("span");
                for (var n in tAttrs.$attr) spanEle.setAttribute(tAttrs.$attr[n], tAttrs[n]);
                return spanEle.classList.add("nav-bar-title"), spanEle.innerHTML = tElement.html(), 
                tElement.attr("class", "hide"), tElement.empty(), {
                    pre: function($scope, $element, $attrs, navBarCtrl) {
                        var parentViewCtrl = $element.parent().data("$ionViewController");
                        parentViewCtrl ? parentViewCtrl.navElement(navElementType, spanEle.outerHTML) : navBarCtrl.navElement(navElementType, spanEle.outerHTML), 
                        spanEle = null;
                    }
                };
            }
        };
    } ]), IonicModule.directive("navTransition", [ "$ionicViewSwitcher", function($ionicViewSwitcher) {
        return {
            restrict: "A",
            priority: 1e3,
            link: function($scope, $element, $attr) {
                $element.bind("click", function() {
                    $ionicViewSwitcher.nextTransition($attr.navTransition);
                });
            }
        };
    } ]), IonicModule.directive("ionNavView", [ "$state", "$ionicConfig", function($state, $ionicConfig) {
        return {
            restrict: "E",
            terminal: !0,
            priority: 2e3,
            transclude: !0,
            controller: "$ionicNavView",
            compile: function(tElement, tAttrs, transclude) {
                return tElement.addClass("view-container"), ionic.DomUtil.cachedAttr(tElement, "nav-view-transition", $ionicConfig.views.transition()), 
                function($scope, $element, $attr, navViewCtrl) {
                    function updateView(firstTime) {
                        var viewLocals = $state.$current && $state.$current.locals[viewData.name];
                        viewLocals && (firstTime || viewLocals !== latestLocals) && (latestLocals = viewLocals, 
                        viewData.state = viewLocals.$$state, navViewCtrl.register(viewLocals));
                    }
                    var latestLocals;
                    transclude($scope, function(clone) {
                        $element.append(clone);
                    });
                    var viewData = navViewCtrl.init();
                    $scope.$on("$stateChangeSuccess", function() {
                        updateView(!1);
                    }), $scope.$on("$viewContentLoading", function() {
                        updateView(!1);
                    }), updateView(!0);
                };
            }
        };
    } ]), IonicModule.config([ "$provide", function($provide) {
        $provide.decorator("ngClickDirective", [ "$delegate", function($delegate) {
            return $delegate.shift(), $delegate;
        } ]);
    } ]).factory("$ionicNgClick", [ "$parse", function($parse) {
        return function(scope, element, clickExpr) {
            var clickHandler = angular.isFunction(clickExpr) ? clickExpr : $parse(clickExpr);
            element.on("click", function(event) {
                scope.$apply(function() {
                    clickHandler(scope, {
                        $event: event
                    });
                });
            }), element.onclick = noop;
        };
    } ]).directive("ngClick", [ "$ionicNgClick", function($ionicNgClick) {
        return function(scope, element, attr) {
            $ionicNgClick(scope, element, attr.ngClick);
        };
    } ]).directive("ionStopEvent", function() {
        return {
            restrict: "A",
            link: function(scope, element, attr) {
                element.bind(attr.ionStopEvent, eventStopPropagation);
            }
        };
    }), IonicModule.directive("ionPane", function() {
        return {
            restrict: "E",
            link: function(scope, element) {
                element.addClass("pane");
            }
        };
    }), IonicModule.directive("ionPopover", [ function() {
        return {
            restrict: "E",
            transclude: !0,
            replace: !0,
            controller: [ function() {} ],
            template: '<div class="popover-backdrop"><div class="popover-wrapper" ng-transclude></div></div>'
        };
    } ]), IonicModule.directive("ionPopoverView", function() {
        return {
            restrict: "E",
            compile: function(element) {
                element.append(jqLite('<div class="popover-arrow">')), element.addClass("popover");
            }
        };
    }), IonicModule.directive("ionRadio", function() {
        return {
            restrict: "E",
            replace: !0,
            require: "?ngModel",
            transclude: !0,
            template: '<label class="item item-radio"><input type="radio" name="radio-group"><div class="radio-content"><div class="item-content disable-pointer-events" ng-transclude></div><i class="radio-icon disable-pointer-events icon ion-checkmark"></i></div></label>',
            compile: function(element, attr) {
                if (attr.icon) {
                    var iconElm = element.find("i");
                    iconElm.removeClass("ion-checkmark").addClass(attr.icon);
                }
                var input = element.find("input");
                return forEach({
                    name: attr.name,
                    value: attr.value,
                    disabled: attr.disabled,
                    "ng-value": attr.ngValue,
                    "ng-model": attr.ngModel,
                    "ng-disabled": attr.ngDisabled,
                    "ng-change": attr.ngChange,
                    "ng-required": attr.ngRequired,
                    required: attr.required
                }, function(value, name) {
                    isDefined(value) && input.attr(name, value);
                }), function(scope, element, attr) {
                    scope.getValue = function() {
                        return scope.ngValue || attr.value;
                    };
                };
            }
        };
    }), IonicModule.directive("ionRefresher", [ function() {
        return {
            restrict: "E",
            replace: !0,
            require: [ "?^$ionicScroll", "ionRefresher" ],
            controller: "$ionicRefresher",
            template: '<div class="scroll-refresher invisible" collection-repeat-ignore><div class="ionic-refresher-content" ng-class="{\'ionic-refresher-with-text\': pullingText || refreshingText}"><div class="icon-pulling" ng-class="{\'pulling-rotation-disabled\':disablePullingRotation}"><i class="icon {{pullingIcon}}"></i></div><div class="text-pulling" ng-bind-html="pullingText"></div><div class="icon-refreshing"><ion-spinner ng-if="showSpinner" icon="{{spinner}}"></ion-spinner><i ng-if="showIcon" class="icon {{refreshingIcon}}"></i></div><div class="text-refreshing" ng-bind-html="refreshingText"></div></div></div>',
            link: function($scope, $element, $attrs, ctrls) {
                var scrollCtrl = ctrls[0], refresherCtrl = ctrls[1];
                !scrollCtrl || scrollCtrl.isNative() ? refresherCtrl.init() : ($element[0].classList.add("js-scrolling"), 
                scrollCtrl._setRefresher($scope, $element[0], refresherCtrl.getRefresherDomMethods()), 
                $scope.$on("scroll.refreshComplete", function() {
                    $scope.$evalAsync(function() {
                        scrollCtrl.scrollView.finishPullToRefresh();
                    });
                }));
            }
        };
    } ]), IonicModule.directive("ionScroll", [ "$timeout", "$controller", "$ionicBind", "$ionicConfig", function($timeout, $controller, $ionicBind, $ionicConfig) {
        return {
            restrict: "E",
            scope: !0,
            controller: function() {},
            compile: function(element, attr) {
                function prelink($scope, $element, $attr) {
                    $ionicBind($scope, $attr, {
                        direction: "@",
                        paging: "@",
                        $onScroll: "&onScroll",
                        scroll: "@",
                        scrollbarX: "@",
                        scrollbarY: "@",
                        zooming: "@",
                        minZoom: "@",
                        maxZoom: "@"
                    }), $scope.direction = $scope.direction || "y", isDefined($attr.padding) && $scope.$watch($attr.padding, function(newVal) {
                        innerElement.toggleClass("padding", !!newVal);
                    }), $scope.$eval($scope.paging) === !0 && innerElement.addClass("scroll-paging"), 
                    $scope.direction || ($scope.direction = "y");
                    var isPaging = $scope.$eval($scope.paging) === !0;
                    nativeScrolling && $element.addClass("overflow-scroll"), $element.addClass("scroll-" + $scope.direction);
                    var scrollViewOptions = {
                        el: $element[0],
                        delegateHandle: $attr.delegateHandle,
                        locking: "true" === ($attr.locking || "true"),
                        bouncing: $scope.$eval($attr.hasBouncing),
                        paging: isPaging,
                        scrollbarX: $scope.$eval($scope.scrollbarX) !== !1,
                        scrollbarY: $scope.$eval($scope.scrollbarY) !== !1,
                        scrollingX: $scope.direction.indexOf("x") >= 0,
                        scrollingY: $scope.direction.indexOf("y") >= 0,
                        zooming: $scope.$eval($scope.zooming) === !0,
                        maxZoom: $scope.$eval($scope.maxZoom) || 3,
                        minZoom: $scope.$eval($scope.minZoom) || .5,
                        preventDefault: !0,
                        nativeScrolling: nativeScrolling
                    };
                    isPaging && (scrollViewOptions.speedMultiplier = .8, scrollViewOptions.bouncing = !1), 
                    $controller("$ionicScroll", {
                        $scope: $scope,
                        scrollViewOptions: scrollViewOptions
                    });
                }
                element.addClass("scroll-view ionic-scroll");
                var innerElement = jqLite('<div class="scroll"></div>');
                innerElement.append(element.contents()), element.append(innerElement);
                var nativeScrolling = "false" !== attr.overflowScroll && ("true" === attr.overflowScroll || !$ionicConfig.scrolling.jsScrolling());
                return {
                    pre: prelink
                };
            }
        };
    } ]), IonicModule.directive("ionSideMenu", function() {
        return {
            restrict: "E",
            require: "^ionSideMenus",
            scope: !0,
            compile: function(element, attr) {
                return angular.isUndefined(attr.isEnabled) && attr.$set("isEnabled", "true"), angular.isUndefined(attr.width) && attr.$set("width", "275"), 
                element.addClass("menu menu-" + attr.side), function($scope, $element, $attr, sideMenuCtrl) {
                    $scope.side = $attr.side || "left";
                    var sideMenu = sideMenuCtrl[$scope.side] = new ionic.views.SideMenu({
                        width: attr.width,
                        el: $element[0],
                        isEnabled: !0
                    });
                    $scope.$watch($attr.width, function(val) {
                        var numberVal = +val;
                        numberVal && numberVal == val && sideMenu.setWidth(+val);
                    }), $scope.$watch($attr.isEnabled, function(val) {
                        sideMenu.setIsEnabled(!!val);
                    });
                };
            }
        };
    }), IonicModule.directive("ionSideMenuContent", [ "$timeout", "$ionicGesture", "$window", function($timeout, $ionicGesture, $window) {
        return {
            restrict: "EA",
            require: "^ionSideMenus",
            scope: !0,
            compile: function(element, attr) {
                function prelink($scope, $element, $attr, sideMenuCtrl) {
                    function onContentTap(gestureEvt) {
                        0 !== sideMenuCtrl.getOpenAmount() ? (sideMenuCtrl.close(), gestureEvt.gesture.srcEvent.preventDefault(), 
                        startCoord = null, primaryScrollAxis = null) : startCoord || (startCoord = ionic.tap.pointerCoord(gestureEvt.gesture.srcEvent));
                    }
                    function onDragX(e) {
                        sideMenuCtrl.isDraggableTarget(e) && "x" == getPrimaryScrollAxis(e) && (sideMenuCtrl._handleDrag(e), 
                        e.gesture.srcEvent.preventDefault());
                    }
                    function onDragY(e) {
                        "x" == getPrimaryScrollAxis(e) && e.gesture.srcEvent.preventDefault();
                    }
                    function onDragRelease(e) {
                        sideMenuCtrl._endDrag(e), startCoord = null, primaryScrollAxis = null;
                    }
                    function getPrimaryScrollAxis(gestureEvt) {
                        if (primaryScrollAxis) return primaryScrollAxis;
                        if (gestureEvt && gestureEvt.gesture) {
                            if (startCoord) {
                                var endCoord = ionic.tap.pointerCoord(gestureEvt.gesture.srcEvent), xDistance = Math.abs(endCoord.x - startCoord.x), yDistance = Math.abs(endCoord.y - startCoord.y), scrollAxis = yDistance > xDistance ? "y" : "x";
                                return Math.max(xDistance, yDistance) > 30 && (primaryScrollAxis = scrollAxis), 
                                scrollAxis;
                            }
                            startCoord = ionic.tap.pointerCoord(gestureEvt.gesture.srcEvent);
                        }
                        return "y";
                    }
                    var startCoord = null, primaryScrollAxis = null;
                    isDefined(attr.dragContent) ? $scope.$watch(attr.dragContent, function(value) {
                        sideMenuCtrl.canDragContent(value);
                    }) : sideMenuCtrl.canDragContent(!0), isDefined(attr.edgeDragThreshold) && $scope.$watch(attr.edgeDragThreshold, function(value) {
                        sideMenuCtrl.edgeDragThreshold(value);
                    });
                    var content = {
                        element: element[0],
                        onDrag: function() {},
                        endDrag: function() {},
                        setCanScroll: function(canScroll) {
                            var c = $element[0].querySelector(".scroll");
                            if (c) {
                                var content = angular.element(c.parentElement);
                                if (content) {
                                    var scrollScope = content.scope();
                                    scrollScope.scrollCtrl && scrollScope.scrollCtrl.freezeScrollShut(!canScroll);
                                }
                            }
                        },
                        getTranslateX: function() {
                            return $scope.sideMenuContentTranslateX || 0;
                        },
                        setTranslateX: ionic.animationFrameThrottle(function(amount) {
                            var xTransform = content.offsetX + amount;
                            $element[0].style[ionic.CSS.TRANSFORM] = "translate3d(" + xTransform + "px,0,0)", 
                            $timeout(function() {
                                $scope.sideMenuContentTranslateX = amount;
                            });
                        }),
                        setMarginLeft: ionic.animationFrameThrottle(function(amount) {
                            amount ? (amount = parseInt(amount, 10), $element[0].style[ionic.CSS.TRANSFORM] = "translate3d(" + amount + "px,0,0)", 
                            $element[0].style.width = $window.innerWidth - amount + "px", content.offsetX = amount) : ($element[0].style[ionic.CSS.TRANSFORM] = "translate3d(0,0,0)", 
                            $element[0].style.width = "", content.offsetX = 0);
                        }),
                        setMarginRight: ionic.animationFrameThrottle(function(amount) {
                            amount ? (amount = parseInt(amount, 10), $element[0].style.width = $window.innerWidth - amount + "px", 
                            content.offsetX = amount) : ($element[0].style.width = "", content.offsetX = 0), 
                            $element[0].style[ionic.CSS.TRANSFORM] = "translate3d(0,0,0)";
                        }),
                        setMarginLeftAndRight: ionic.animationFrameThrottle(function(amountLeft, amountRight) {
                            amountLeft = amountLeft && parseInt(amountLeft, 10) || 0, amountRight = amountRight && parseInt(amountRight, 10) || 0;
                            var amount = amountLeft + amountRight;
                            amount > 0 ? ($element[0].style[ionic.CSS.TRANSFORM] = "translate3d(" + amountLeft + "px,0,0)", 
                            $element[0].style.width = $window.innerWidth - amount + "px", content.offsetX = amountLeft) : ($element[0].style[ionic.CSS.TRANSFORM] = "translate3d(0,0,0)", 
                            $element[0].style.width = "", content.offsetX = 0);
                        }),
                        enableAnimation: function() {
                            $scope.animationEnabled = !0, $element[0].classList.add("menu-animated");
                        },
                        disableAnimation: function() {
                            $scope.animationEnabled = !1, $element[0].classList.remove("menu-animated");
                        },
                        offsetX: 0
                    };
                    sideMenuCtrl.setContent(content);
                    var gestureOpts = {
                        stop_browser_behavior: !1
                    };
                    gestureOpts.prevent_default_directions = [ "left", "right" ];
                    var contentTapGesture = $ionicGesture.on("tap", onContentTap, $element, gestureOpts), dragRightGesture = $ionicGesture.on("dragright", onDragX, $element, gestureOpts), dragLeftGesture = $ionicGesture.on("dragleft", onDragX, $element, gestureOpts), dragUpGesture = $ionicGesture.on("dragup", onDragY, $element, gestureOpts), dragDownGesture = $ionicGesture.on("dragdown", onDragY, $element, gestureOpts), releaseGesture = $ionicGesture.on("release", onDragRelease, $element, gestureOpts);
                    $scope.$on("$destroy", function() {
                        content && (content.element = null, content = null), $ionicGesture.off(dragLeftGesture, "dragleft", onDragX), 
                        $ionicGesture.off(dragRightGesture, "dragright", onDragX), $ionicGesture.off(dragUpGesture, "dragup", onDragY), 
                        $ionicGesture.off(dragDownGesture, "dragdown", onDragY), $ionicGesture.off(releaseGesture, "release", onDragRelease), 
                        $ionicGesture.off(contentTapGesture, "tap", onContentTap);
                    });
                }
                return element.addClass("menu-content pane"), {
                    pre: prelink
                };
            }
        };
    } ]), IonicModule.directive("ionSideMenus", [ "$ionicBody", function($ionicBody) {
        return {
            restrict: "ECA",
            controller: "$ionicSideMenus",
            compile: function(element, attr) {
                function prelink($scope, $element, $attrs, ctrl) {
                    ctrl.enableMenuWithBackViews($scope.$eval($attrs.enableMenuWithBackViews)), $scope.$on("$ionicExposeAside", function(evt, isAsideExposed) {
                        $scope.$exposeAside || ($scope.$exposeAside = {}), $scope.$exposeAside.active = isAsideExposed, 
                        $ionicBody.enableClass(isAsideExposed, "aside-open");
                    }), $scope.$on("$ionicView.beforeEnter", function(ev, d) {
                        d.historyId && ($scope.$activeHistoryId = d.historyId);
                    }), $scope.$on("$destroy", function() {
                        $ionicBody.removeClass("menu-open", "aside-open");
                    });
                }
                return attr.$set("class", (attr["class"] || "") + " view"), {
                    pre: prelink
                };
            }
        };
    } ]), IonicModule.directive("ionSlideBox", [ "$animate", "$timeout", "$compile", "$ionicSlideBoxDelegate", "$ionicHistory", "$ionicScrollDelegate", function($animate, $timeout, $compile, $ionicSlideBoxDelegate, $ionicHistory, $ionicScrollDelegate) {
        return {
            restrict: "E",
            replace: !0,
            transclude: !0,
            scope: {
                autoPlay: "=",
                doesContinue: "@",
                slideInterval: "@",
                showPager: "@",
                pagerClick: "&",
                disableScroll: "@",
                onSlideChanged: "&",
                activeSlide: "=?",
                bounce: "@"
            },
            controller: [ "$scope", "$element", "$attrs", function($scope, $element, $attrs) {
                function freezeAllScrolls(shouldFreeze) {
                    shouldFreeze && !_this.isScrollFreeze ? $ionicScrollDelegate.freezeAllScrolls(shouldFreeze) : !shouldFreeze && _this.isScrollFreeze && $ionicScrollDelegate.freezeAllScrolls(!1), 
                    _this.isScrollFreeze = shouldFreeze;
                }
                var _this = this, continuous = $scope.$eval($scope.doesContinue) === !0, bouncing = $scope.$eval($scope.bounce) !== !1, shouldAutoPlay = isDefined($attrs.autoPlay) ? !!$scope.autoPlay : !1, slideInterval = shouldAutoPlay ? $scope.$eval($scope.slideInterval) || 4e3 : 0, slider = new ionic.views.Slider({
                    el: $element[0],
                    auto: slideInterval,
                    continuous: continuous,
                    startSlide: $scope.activeSlide,
                    bouncing: bouncing,
                    slidesChanged: function() {
                        $scope.currentSlide = slider.currentIndex(), $timeout(function() {});
                    },
                    callback: function(slideIndex) {
                        $scope.currentSlide = slideIndex, $scope.onSlideChanged({
                            index: $scope.currentSlide,
                            $index: $scope.currentSlide
                        }), $scope.$parent.$broadcast("slideBox.slideChanged", slideIndex), $scope.activeSlide = slideIndex, 
                        $timeout(function() {});
                    },
                    onDrag: function() {
                        freezeAllScrolls(!0);
                    },
                    onDragEnd: function() {
                        freezeAllScrolls(!1);
                    }
                });
                slider.enableSlide($scope.$eval($attrs.disableScroll) !== !0), $scope.$watch("activeSlide", function(nv) {
                    isDefined(nv) && slider.slide(nv);
                }), $scope.$on("slideBox.nextSlide", function() {
                    slider.next();
                }), $scope.$on("slideBox.prevSlide", function() {
                    slider.prev();
                }), $scope.$on("slideBox.setSlide", function(e, index) {
                    slider.slide(index);
                }), this.__slider = slider;
                var deregisterInstance = $ionicSlideBoxDelegate._registerInstance(slider, $attrs.delegateHandle, function() {
                    return $ionicHistory.isActiveScope($scope);
                });
                $scope.$on("$destroy", function() {
                    deregisterInstance(), slider.kill();
                }), this.slidesCount = function() {
                    return slider.slidesCount();
                }, this.onPagerClick = function(index) {
                    $scope.pagerClick({
                        index: index
                    });
                }, $timeout(function() {
                    slider.load();
                });
            } ],
            template: '<div class="slider"><div class="slider-slides" ng-transclude></div></div>',
            link: function($scope, $element, $attr) {
                function getPager() {
                    if (!pager) {
                        var childScope = $scope.$new();
                        pager = jqLite("<ion-pager></ion-pager>"), $element.append(pager), pager = $compile(pager)(childScope);
                    }
                    return pager;
                }
                $animate.enabled(!1, $element), isDefined($attr.showPager) || ($scope.showPager = !0, 
                getPager().toggleClass("hide", !1)), $attr.$observe("showPager", function(show) {
                    void 0 !== show && (show = $scope.$eval(show), getPager().toggleClass("hide", !show));
                });
                var pager;
            }
        };
    } ]).directive("ionSlide", function() {
        return {
            restrict: "E",
            require: "?^ionSlideBox",
            compile: function(element) {
                element.addClass("slider-slide");
            }
        };
    }).directive("ionPager", function() {
        return {
            restrict: "E",
            replace: !0,
            require: "^ionSlideBox",
            template: '<div class="slider-pager"><span class="slider-pager-page" ng-repeat="slide in numSlides() track by $index" ng-class="{active: $index == currentSlide}" ng-click="pagerClick($index)"><i class="icon ion-record"></i></span></div>',
            link: function($scope, $element, $attr, slideBox) {
                var selectPage = function(index) {
                    for (var children = $element[0].children, length = children.length, i = 0; length > i; i++) i == index ? children[i].classList.add("active") : children[i].classList.remove("active");
                };
                $scope.pagerClick = function(index) {
                    slideBox.onPagerClick(index);
                }, $scope.numSlides = function() {
                    return new Array(slideBox.slidesCount());
                }, $scope.$watch("currentSlide", function(v) {
                    selectPage(v);
                });
            }
        };
    }), IonicModule.directive("ionSlides", [ "$animate", "$timeout", "$compile", function($animate, $timeout, $compile) {
        return {
            restrict: "E",
            transclude: !0,
            scope: {
                options: "=",
                slider: "="
            },
            template: '<div class="swiper-container"><div class="swiper-wrapper" ng-transclude></div><div ng-hide="!showPager" class="swiper-pagination"></div></div>',
            controller: [ "$scope", "$element", function($scope, $element) {
                var _this = this;
                this.update = function() {
                    $timeout(function() {
                        _this.__slider && (_this.__slider.update(), _this._options.loop && _this.__slider.createLoop(), 
                        _this.__slider.slides.length > 10 && ($scope.showPager = !1));
                    });
                }, this.rapidUpdate = ionic.debounce(function() {
                    _this.update();
                }, 50), this.getSlider = function() {
                    return _this.__slider;
                };
                var options = $scope.options || {}, newOptions = angular.extend({
                    pagination: ".swiper-pagination",
                    paginationClickable: !0,
                    lazyLoading: !0,
                    preloadImages: !1
                }, options);
                this._options = newOptions, $timeout(function() {
                    var slider = new ionic.views.Swiper($element.children()[0], newOptions, $scope, $compile);
                    _this.__slider = slider, $scope.slider = _this.__slider, $scope.$on("$destroy", function() {
                        slider.destroy();
                    });
                });
            } ],
            link: function($scope) {
                $scope.showPager = !0;
            }
        };
    } ]).directive("ionSlidePage", [ function() {
        return {
            restrict: "E",
            require: "?^ionSlides",
            transclude: !0,
            replace: !0,
            template: '<div class="swiper-slide" ng-transclude></div>',
            link: function($scope, $element, $attr, ionSlidesCtrl) {
                ionSlidesCtrl.rapidUpdate();
            }
        };
    } ]), IonicModule.directive("ionSpinner", function() {
        return {
            restrict: "E",
            controller: "$ionicSpinner",
            link: function($scope, $element, $attrs, ctrl) {
                var spinnerName = ctrl.init();
                $element.addClass("spinner spinner-" + spinnerName), $element.on("$destroy", function() {
                    ctrl.stop();
                });
            }
        };
    }), IonicModule.directive("ionTab", [ "$compile", "$ionicConfig", "$ionicBind", "$ionicViewSwitcher", function($compile, $ionicConfig, $ionicBind, $ionicViewSwitcher) {
        function attrStr(k, v) {
            return isDefined(v) ? " " + k + '="' + v + '"' : "";
        }
        return {
            restrict: "E",
            require: [ "^ionTabs", "ionTab" ],
            controller: "$ionicTab",
            scope: !0,
            compile: function(element, attr) {
                for (var tabNavTemplate = "<ion-tab-nav" + attrStr("ng-click", attr.ngClick) + attrStr("title", attr.title) + attrStr("icon", attr.icon) + attrStr("icon-on", attr.iconOn) + attrStr("icon-off", attr.iconOff) + attrStr("badge", attr.badge) + attrStr("badge-style", attr.badgeStyle) + attrStr("hidden", attr.hidden) + attrStr("disabled", attr.disabled) + attrStr("class", attr["class"]) + "></ion-tab-nav>", tabContentEle = document.createElement("div"), x = 0; x < element[0].children.length; x++) tabContentEle.appendChild(element[0].children[x].cloneNode(!0));
                var childElementCount = tabContentEle.childElementCount;
                element.empty();
                var navViewName, isNavView;
                return childElementCount && ("ION-NAV-VIEW" === tabContentEle.children[0].tagName && (navViewName = tabContentEle.children[0].getAttribute("name"), 
                tabContentEle.children[0].classList.add("view-container"), isNavView = !0), 1 === childElementCount && (tabContentEle = tabContentEle.children[0]), 
                isNavView || tabContentEle.classList.add("pane"), tabContentEle.classList.add("tab-content")), 
                function($scope, $element, $attr, ctrls) {
                    function selectIfMatchesState() {
                        tabCtrl.tabMatchesState() && tabsCtrl.select($scope, !1);
                    }
                    function tabSelected(isSelected) {
                        isSelected && childElementCount ? (isTabContentAttached || (childScope = $scope.$new(), 
                        childElement = jqLite(tabContentEle), $ionicViewSwitcher.viewEleIsActive(childElement, !0), 
                        tabsCtrl.$element.append(childElement), $compile(childElement)(childScope), isTabContentAttached = !0), 
                        $ionicViewSwitcher.viewEleIsActive(childElement, !0)) : isTabContentAttached && childElement && ($ionicConfig.views.maxCache() > 0 ? $ionicViewSwitcher.viewEleIsActive(childElement, !1) : destroyTab());
                    }
                    function destroyTab() {
                        childScope && childScope.$destroy(), isTabContentAttached && childElement && childElement.remove(), 
                        tabContentEle.innerHTML = "", isTabContentAttached = childScope = childElement = null;
                    }
                    var childScope, childElement, tabsCtrl = ctrls[0], tabCtrl = ctrls[1], isTabContentAttached = !1;
                    $scope.$tabSelected = !1, $ionicBind($scope, $attr, {
                        onSelect: "&",
                        onDeselect: "&",
                        title: "@",
                        uiSref: "@",
                        href: "@"
                    }), tabsCtrl.add($scope), $scope.$on("$destroy", function() {
                        $scope.$tabsDestroy || tabsCtrl.remove($scope), tabNavElement.isolateScope().$destroy(), 
                        tabNavElement.remove(), tabNavElement = tabContentEle = childElement = null;
                    }), $element[0].removeAttribute("title"), navViewName && (tabCtrl.navViewName = $scope.navViewName = navViewName), 
                    $scope.$on("$stateChangeSuccess", selectIfMatchesState), selectIfMatchesState();
                    var tabNavElement = jqLite(tabNavTemplate);
                    tabNavElement.data("$ionTabsController", tabsCtrl), tabNavElement.data("$ionTabController", tabCtrl), 
                    tabsCtrl.$tabsElement.append($compile(tabNavElement)($scope)), $scope.$watch("$tabSelected", tabSelected), 
                    $scope.$on("$ionicView.afterEnter", function() {
                        $ionicViewSwitcher.viewEleIsActive(childElement, $scope.$tabSelected);
                    }), $scope.$on("$ionicView.clearCache", function() {
                        $scope.$tabSelected || destroyTab();
                    });
                };
            }
        };
    } ]), IonicModule.directive("ionTabNav", [ function() {
        return {
            restrict: "E",
            replace: !0,
            require: [ "^ionTabs", "^ionTab" ],
            template: "<a ng-class=\"{'tab-item-active': isTabActive(), 'has-badge':badge, 'tab-hidden':isHidden()}\" " + ' ng-disabled="disabled()" class="tab-item"><span class="badge {{badgeStyle}}" ng-if="badge">{{badge}}</span><i class="icon {{getIconOn()}}" ng-if="getIconOn() && isTabActive()"></i><i class="icon {{getIconOff()}}" ng-if="getIconOff() && !isTabActive()"></i><span class="tab-title" ng-bind-html="title"></span></a>',
            scope: {
                title: "@",
                icon: "@",
                iconOn: "@",
                iconOff: "@",
                badge: "=",
                hidden: "@",
                disabled: "&",
                badgeStyle: "@",
                "class": "@"
            },
            link: function($scope, $element, $attrs, ctrls) {
                var tabsCtrl = ctrls[0], tabCtrl = ctrls[1];
                $element[0].removeAttribute("title"), $scope.selectTab = function(e) {
                    e.preventDefault(), tabsCtrl.select(tabCtrl.$scope, !0);
                }, $attrs.ngClick || $element.on("click", function(event) {
                    $scope.$apply(function() {
                        $scope.selectTab(event);
                    });
                }), $scope.isHidden = function() {
                    return "true" === $attrs.hidden || $attrs.hidden === !0 ? !0 : !1;
                }, $scope.getIconOn = function() {
                    return $scope.iconOn || $scope.icon;
                }, $scope.getIconOff = function() {
                    return $scope.iconOff || $scope.icon;
                }, $scope.isTabActive = function() {
                    return tabsCtrl.selectedTab() === tabCtrl.$scope;
                };
            }
        };
    } ]), IonicModule.directive("ionTabs", [ "$ionicTabsDelegate", "$ionicConfig", function($ionicTabsDelegate, $ionicConfig) {
        return {
            restrict: "E",
            scope: !0,
            controller: "$ionicTabs",
            compile: function(tElement) {
                function prelink($scope, $element, $attr, tabsCtrl) {
                    function emitLifecycleEvent(ev, data) {
                        ev.stopPropagation();
                        var previousSelectedTab = tabsCtrl.previousSelectedTab();
                        previousSelectedTab && previousSelectedTab.$broadcast(ev.name.replace("NavView", "Tabs"), data);
                    }
                    var deregisterInstance = $ionicTabsDelegate._registerInstance(tabsCtrl, $attr.delegateHandle, tabsCtrl.hasActiveScope);
                    tabsCtrl.$scope = $scope, tabsCtrl.$element = $element, tabsCtrl.$tabsElement = jqLite($element[0].querySelector(".tabs")), 
                    $scope.$watch(function() {
                        return $element[0].className;
                    }, function(value) {
                        var isTabsTop = -1 !== value.indexOf("tabs-top"), isHidden = -1 !== value.indexOf("tabs-item-hide");
                        $scope.$hasTabs = !isTabsTop && !isHidden, $scope.$hasTabsTop = isTabsTop && !isHidden, 
                        $scope.$emit("$ionicTabs.top", $scope.$hasTabsTop);
                    }), $scope.$on("$ionicNavView.beforeLeave", emitLifecycleEvent), $scope.$on("$ionicNavView.afterLeave", emitLifecycleEvent), 
                    $scope.$on("$ionicNavView.leave", emitLifecycleEvent), $scope.$on("$destroy", function() {
                        $scope.$tabsDestroy = !0, deregisterInstance(), tabsCtrl.$tabsElement = tabsCtrl.$element = tabsCtrl.$scope = innerElement = null, 
                        delete $scope.$hasTabs, delete $scope.$hasTabsTop;
                    });
                }
                function postLink($scope, $element, $attr, tabsCtrl) {
                    tabsCtrl.selectedTab() || tabsCtrl.select(0);
                }
                var innerElement = jqLite('<div class="tab-nav tabs">');
                return innerElement.append(tElement.contents()), tElement.append(innerElement).addClass("tabs-" + $ionicConfig.tabs.position() + " tabs-" + $ionicConfig.tabs.style()), 
                {
                    pre: prelink,
                    post: postLink
                };
            }
        };
    } ]), IonicModule.directive("ionTitle", [ function() {
        return {
            restrict: "E",
            compile: function(element) {
                element.addClass("title");
            }
        };
    } ]), IonicModule.directive("ionToggle", [ "$timeout", "$ionicConfig", function($timeout, $ionicConfig) {
        return {
            restrict: "E",
            replace: !0,
            require: "?ngModel",
            transclude: !0,
            template: '<div class="item item-toggle"><div ng-transclude></div><label class="toggle"><input type="checkbox"><div class="track"><div class="handle"></div></div></label></div>',
            compile: function(element, attr) {
                var input = element.find("input");
                return forEach({
                    name: attr.name,
                    "ng-value": attr.ngValue,
                    "ng-model": attr.ngModel,
                    "ng-checked": attr.ngChecked,
                    "ng-disabled": attr.ngDisabled,
                    "ng-true-value": attr.ngTrueValue,
                    "ng-false-value": attr.ngFalseValue,
                    "ng-change": attr.ngChange,
                    "ng-required": attr.ngRequired,
                    required: attr.required
                }, function(value, name) {
                    isDefined(value) && input.attr(name, value);
                }), attr.toggleClass && element[0].getElementsByTagName("label")[0].classList.add(attr.toggleClass), 
                element.addClass("toggle-" + $ionicConfig.form.toggle()), function($scope, $element) {
                    var el = $element[0].getElementsByTagName("label")[0], checkbox = el.children[0], track = el.children[1], handle = track.children[0], ngModelController = jqLite(checkbox).controller("ngModel");
                    $scope.toggle = new ionic.views.Toggle({
                        el: el,
                        track: track,
                        checkbox: checkbox,
                        handle: handle,
                        onChange: function() {
                            ngModelController && (ngModelController.$setViewValue(checkbox.checked), $scope.$apply());
                        }
                    }), $scope.$on("$destroy", function() {
                        $scope.toggle.destroy();
                    });
                };
            }
        };
    } ]), IonicModule.directive("ionView", function() {
        return {
            restrict: "EA",
            priority: 1e3,
            controller: "$ionicView",
            compile: function(tElement) {
                return tElement.addClass("pane"), tElement[0].removeAttribute("title"), function($scope, $element, $attrs, viewCtrl) {
                    viewCtrl.init();
                };
            }
        };
    });
}(), function() {
    "use strict";
    var bindonceModule = angular.module("pasvaz.bindonce", []);
    bindonceModule.directive("bindonce", function() {
        var toBoolean = function(value) {
            if (value && 0 !== value.length) {
                var v = angular.lowercase("" + value);
                value = !("f" === v || "0" === v || "false" === v || "no" === v || "n" === v || "[]" === v);
            } else value = !1;
            return value;
        }, msie = parseInt((/msie (\d+)/.exec(angular.lowercase(navigator.userAgent)) || [])[1], 10);
        isNaN(msie) && (msie = parseInt((/trident\/.*; rv:(\d+)/.exec(angular.lowercase(navigator.userAgent)) || [])[1], 10));
        var bindonceDirective = {
            restrict: "AM",
            controller: [ "$scope", "$element", "$attrs", "$interpolate", function($scope, $element, $attrs, $interpolate) {
                var showHideBinder = function(elm, attr, value) {
                    var show = "show" === attr ? "" : "none", hide = "hide" === attr ? "" : "none";
                    elm.css("display", toBoolean(value) ? show : hide);
                }, classBinder = function(elm, value) {
                    if (angular.isObject(value) && !angular.isArray(value)) {
                        var results = [];
                        angular.forEach(value, function(value, index) {
                            value && results.push(index);
                        }), value = results;
                    }
                    value && elm.addClass(angular.isArray(value) ? value.join(" ") : value);
                }, transclude = function(transcluder, scope) {
                    transcluder.transclude(scope, function(clone) {
                        var parent = transcluder.element.parent(), afterNode = transcluder.element && transcluder.element[transcluder.element.length - 1], parentNode = parent && parent[0] || afterNode && afterNode.parentNode, afterNextSibling = afterNode && afterNode.nextSibling || null;
                        angular.forEach(clone, function(node) {
                            parentNode.insertBefore(node, afterNextSibling);
                        });
                    });
                }, ctrl = {
                    watcherRemover: void 0,
                    binders: [],
                    group: $attrs.boName,
                    element: $element,
                    ran: !1,
                    addBinder: function(binder) {
                        this.binders.push(binder), this.ran && this.runBinders();
                    },
                    setupWatcher: function(bindonceValue) {
                        var that = this;
                        this.watcherRemover = $scope.$watch(bindonceValue, function(newValue) {
                            void 0 !== newValue && (that.removeWatcher(), that.checkBindonce(newValue));
                        }, !0);
                    },
                    checkBindonce: function(value) {
                        var that = this, promise = value.$promise ? value.$promise.then : value.then;
                        "function" == typeof promise ? promise(function() {
                            that.runBinders();
                        }) : that.runBinders();
                    },
                    removeWatcher: function() {
                        void 0 !== this.watcherRemover && (this.watcherRemover(), this.watcherRemover = void 0);
                    },
                    runBinders: function() {
                        for (;this.binders.length > 0; ) {
                            var binder = this.binders.shift();
                            if (!this.group || this.group == binder.group) {
                                var value = binder.scope.$eval(binder.interpolate ? $interpolate(binder.value) : binder.value);
                                switch (binder.attr) {
                                  case "boIf":
                                    toBoolean(value) && transclude(binder, binder.scope.$new());
                                    break;

                                  case "boSwitch":
                                    var selectedTranscludes, switchCtrl = binder.controller[0];
                                    (selectedTranscludes = switchCtrl.cases["!" + value] || switchCtrl.cases["?"]) && (binder.scope.$eval(binder.attrs.change), 
                                    angular.forEach(selectedTranscludes, function(selectedTransclude) {
                                        transclude(selectedTransclude, binder.scope.$new());
                                    }));
                                    break;

                                  case "boSwitchWhen":
                                    var ctrl = binder.controller[0];
                                    ctrl.cases["!" + binder.attrs.boSwitchWhen] = ctrl.cases["!" + binder.attrs.boSwitchWhen] || [], 
                                    ctrl.cases["!" + binder.attrs.boSwitchWhen].push({
                                        transclude: binder.transclude,
                                        element: binder.element
                                    });
                                    break;

                                  case "boSwitchDefault":
                                    var ctrl = binder.controller[0];
                                    ctrl.cases["?"] = ctrl.cases["?"] || [], ctrl.cases["?"].push({
                                        transclude: binder.transclude,
                                        element: binder.element
                                    });
                                    break;

                                  case "hide":
                                  case "show":
                                    showHideBinder(binder.element, binder.attr, value);
                                    break;

                                  case "class":
                                    classBinder(binder.element, value);
                                    break;

                                  case "text":
                                    binder.element.text(value);
                                    break;

                                  case "html":
                                    binder.element.html(value);
                                    break;

                                  case "style":
                                    binder.element.css(value);
                                    break;

                                  case "disabled":
                                    binder.element.prop("disabled", value);
                                    break;

                                  case "src":
                                    binder.element.attr(binder.attr, value), msie && binder.element.prop("src", value);
                                    break;

                                  case "attr":
                                    angular.forEach(binder.attrs, function(attrValue, attrKey) {
                                        var newAttr, newValue;
                                        attrKey.match(/^boAttr./) && binder.attrs[attrKey] && (newAttr = attrKey.replace(/^boAttr/, "").replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), 
                                        newValue = binder.scope.$eval(binder.attrs[attrKey]), binder.element.attr(newAttr, newValue));
                                    });
                                    break;

                                  case "href":
                                  case "alt":
                                  case "title":
                                  case "id":
                                  case "value":
                                    binder.element.attr(binder.attr, value);
                                }
                            }
                        }
                        this.ran = !0;
                    }
                };
                angular.extend(this, ctrl);
            } ],
            link: function(scope, elm, attrs, bindonceController) {
                var value = attrs.bindonce && scope.$eval(attrs.bindonce);
                void 0 !== value ? bindonceController.checkBindonce(value) : (bindonceController.setupWatcher(attrs.bindonce), 
                elm.bind("$destroy", bindonceController.removeWatcher));
            }
        };
        return bindonceDirective;
    }), angular.forEach([ {
        directiveName: "boShow",
        attribute: "show"
    }, {
        directiveName: "boHide",
        attribute: "hide"
    }, {
        directiveName: "boClass",
        attribute: "class"
    }, {
        directiveName: "boText",
        attribute: "text"
    }, {
        directiveName: "boBind",
        attribute: "text"
    }, {
        directiveName: "boHtml",
        attribute: "html"
    }, {
        directiveName: "boSrcI",
        attribute: "src",
        interpolate: !0
    }, {
        directiveName: "boSrc",
        attribute: "src"
    }, {
        directiveName: "boHrefI",
        attribute: "href",
        interpolate: !0
    }, {
        directiveName: "boHref",
        attribute: "href"
    }, {
        directiveName: "boAlt",
        attribute: "alt"
    }, {
        directiveName: "boTitle",
        attribute: "title"
    }, {
        directiveName: "boId",
        attribute: "id"
    }, {
        directiveName: "boStyle",
        attribute: "style"
    }, {
        directiveName: "boDisabled",
        attribute: "disabled"
    }, {
        directiveName: "boValue",
        attribute: "value"
    }, {
        directiveName: "boAttr",
        attribute: "attr"
    }, {
        directiveName: "boIf",
        transclude: "element",
        terminal: !0,
        priority: 1e3
    }, {
        directiveName: "boSwitch",
        require: "boSwitch",
        controller: function() {
            this.cases = {};
        }
    }, {
        directiveName: "boSwitchWhen",
        transclude: "element",
        priority: 800,
        require: "^boSwitch"
    }, {
        directiveName: "boSwitchDefault",
        transclude: "element",
        priority: 800,
        require: "^boSwitch"
    } ], function(boDirective) {
        var childPriority = 200;
        return bindonceModule.directive(boDirective.directiveName, function() {
            var bindonceDirective = {
                priority: boDirective.priority || childPriority,
                transclude: boDirective.transclude || !1,
                terminal: boDirective.terminal || !1,
                require: [ "^bindonce" ].concat(boDirective.require || []),
                controller: boDirective.controller,
                compile: function(tElement, tAttrs, transclude) {
                    return function(scope, elm, attrs, controllers) {
                        var bindonceController = controllers[0], name = attrs.boParent;
                        if (name && bindonceController.group !== name) {
                            var element = bindonceController.element.parent();
                            bindonceController = void 0;
                            for (var parentValue; 9 !== element[0].nodeType && element.length; ) {
                                if ((parentValue = element.data("$bindonceController")) && parentValue.group === name) {
                                    bindonceController = parentValue;
                                    break;
                                }
                                element = element.parent();
                            }
                            if (!bindonceController) throw new Error("No bindonce controller: " + name);
                        }
                        bindonceController.addBinder({
                            element: elm,
                            attr: boDirective.attribute || boDirective.directiveName,
                            attrs: attrs,
                            value: attrs[boDirective.directiveName],
                            interpolate: boDirective.interpolate,
                            group: name,
                            transclude: transclude,
                            controller: controllers.slice(1),
                            scope: scope
                        });
                    };
                }
            };
            return bindonceDirective;
        });
    });
}(), function(root, factory) {
    "object" == typeof exports && "object" == typeof module ? module.exports = factory(require("angular")) : "function" == typeof define && define.amd ? define([ "angular" ], factory) : "object" == typeof exports ? exports.angularCacheModuleName = factory(require("angular")) : root.angularCacheModuleName = factory(root.angular);
}(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
    return function(modules) {
        function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) return installedModules[moduleId].exports;
            var module = installedModules[moduleId] = {
                exports: {},
                id: moduleId,
                loaded: !1
            };
            return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
            module.loaded = !0, module.exports;
        }
        var installedModules = {};
        return __webpack_require__.m = modules, __webpack_require__.c = installedModules, 
        __webpack_require__.p = "", __webpack_require__(0);
    }([ function(module, exports, __webpack_require__) {
        function bubbleUp(heap, weightFunc, n) {
            for (var element = heap[n], weight = weightFunc(element); n > 0; ) {
                var parentN = Math.floor((n + 1) / 2) - 1, _parent = heap[parentN];
                if (weight >= weightFunc(_parent)) break;
                heap[parentN] = element, heap[n] = _parent, n = parentN;
            }
        }
        var _interopRequire = function(obj) {
            return obj && obj.__esModule ? obj["default"] : obj;
        }, _classCallCheck = function(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }, angular = _interopRequire(__webpack_require__(1)), _keys = function(collection) {
            var keys = [], key = void 0;
            for (key in collection) collection.hasOwnProperty(key) && keys.push(key);
            return keys;
        }, _isPromiseLike = function(v) {
            return v && "function" == typeof v.then;
        }, _stringifyNumber = function(number) {
            return angular.isNumber(number) ? number.toString() : number;
        }, _keySet = function(collection) {
            var keySet = {}, key = void 0;
            for (key in collection) collection.hasOwnProperty(key) && (keySet[key] = key);
            return keySet;
        }, bubbleDown = function(heap, weightFunc, n) {
            for (var length = heap.length, node = heap[n], nodeWeight = weightFunc(node); ;) {
                var child2N = 2 * (n + 1), child1N = child2N - 1, swap = null;
                if (length > child1N) {
                    var child1 = heap[child1N], child1Weight = weightFunc(child1);
                    nodeWeight > child1Weight && (swap = child1N);
                }
                if (length > child2N) {
                    var child2 = heap[child2N], child2Weight = weightFunc(child2);
                    child2Weight < (null === swap ? nodeWeight : weightFunc(heap[child1N])) && (swap = child2N);
                }
                if (null === swap) break;
                heap[n] = heap[swap], heap[swap] = node, n = swap;
            }
        }, BinaryHeap = function BinaryHeap(weightFunc, compareFunc) {
            var _this = this;
            if (_classCallCheck(this, BinaryHeap), weightFunc || (weightFunc = function(x) {
                return x;
            }), compareFunc || (compareFunc = function(x, y) {
                return x === y;
            }), "function" != typeof weightFunc) throw new Error('BinaryHeap([weightFunc][, compareFunc]): "weightFunc" must be a function!');
            if ("function" != typeof compareFunc) throw new Error('BinaryHeap([weightFunc][, compareFunc]): "compareFunc" must be a function!');
            this.weightFunc = weightFunc, this.compareFunc = compareFunc, this.heap = [], this.push = function(node) {
                _this.heap.push(node), bubbleUp(_this.heap, _this.weightFunc, _this.heap.length - 1);
            }, this.peek = function() {
                return _this.heap.length ? _this.heap[0] : void 0;
            }, this.pop = function() {
                var front = _this.heap[0], end = _this.heap.pop();
                return _this.heap.length > 0 && (_this.heap[0] = end, bubbleDown(_this.heap, _this.weightFunc, 0)), 
                front;
            }, this.remove = function(node) {
                for (var length = _this.heap.length, i = 0; length > i; i++) if (_this.compareFunc(_this.heap[i], node)) {
                    var removed = _this.heap[i], end = _this.heap.pop();
                    return i !== length - 1 && (_this.heap[i] = end, bubbleUp(_this.heap, _this.weightFunc, i), 
                    bubbleDown(_this.heap, _this.weightFunc, i)), removed;
                }
                return null;
            }, this.removeAll = function() {
                _this.heap = [];
            }, this.size = function() {
                return _this.heap.length;
            };
        }, BinaryHeapProvider = function BinaryHeapProvider() {
            _classCallCheck(this, BinaryHeapProvider), this.$get = function() {
                return BinaryHeap;
            };
        }, CacheFactoryProvider = function CacheFactoryProvider() {
            var _this = this;
            _classCallCheck(this, CacheFactoryProvider);
            var defaults = this.defaults = {
                capacity: Number.MAX_VALUE,
                maxAge: Number.MAX_VALUE,
                deleteOnExpire: "none",
                onExpire: null,
                cacheFlushInterval: null,
                recycleFreq: 1e3,
                storageMode: "memory",
                storageImpl: null,
                disabled: !1,
                storagePrefix: "angular-cache.caches.",
                storeOnResolve: !1,
                storeOnReject: !1
            };
            this.$get = [ "$q", function($q) {
                function CacheFactory(cacheId, options) {
                    return createCache(cacheId, options);
                }
                var caches = {}, createCache = function(cacheId, options) {
                    if (cacheId in caches) throw new Error("" + cacheId + " already exists!");
                    if (!angular.isString(cacheId)) throw new Error("cacheId must be a string!");
                    var $$data = {}, $$promises = {}, $$storage = null, $$expiresHeap = new BinaryHeap(function(x) {
                        return x.expires;
                    }, angular.equals), $$lruHeap = new BinaryHeap(function(x) {
                        return x.accessed;
                    }, angular.equals), cache = caches[cacheId] = {
                        $$id: cacheId,
                        destroy: function() {
                            clearInterval(this.$$cacheFlushIntervalId), clearInterval(this.$$recycleFreqId), 
                            this.removeAll(), $$storage && ($$storage().removeItem("" + this.$$prefix + ".keys"), 
                            $$storage().removeItem(this.$$prefix)), $$storage = null, $$data = null, $$lruHeap = null, 
                            $$expiresHeap = null, this.$$prefix = null, delete caches[this.$$id];
                        },
                        disable: function() {
                            this.$$disabled = !0;
                        },
                        enable: function() {
                            delete this.$$disabled;
                        },
                        get: function(key, options) {
                            var _this2 = this;
                            if (angular.isArray(key)) {
                                var _ret = function() {
                                    var keys = key, values = [];
                                    return angular.forEach(keys, function(key) {
                                        var value = _this2.get(key, options);
                                        null !== value && void 0 !== value && values.push(value);
                                    }), {
                                        v: values
                                    };
                                }();
                                if ("object" == typeof _ret) return _ret.v;
                            } else if (key = _stringifyNumber(key), this.$$disabled) return;
                            if (options = options || {}, !angular.isString(key)) throw new Error("key must be a string!");
                            if (options && !angular.isObject(options)) throw new Error("options must be an object!");
                            if (options.onExpire && !angular.isFunction(options.onExpire)) throw new Error("options.onExpire must be a function!");
                            var item = void 0;
                            if ($$storage) {
                                if ($$promises[key]) return $$promises[key];
                                var itemJson = $$storage().getItem("" + this.$$prefix + ".data." + key);
                                if (!itemJson) return;
                                item = angular.fromJson(itemJson);
                            } else {
                                if (!(key in $$data)) return;
                                item = $$data[key];
                            }
                            var value = item.value, now = new Date().getTime();
                            return $$storage ? ($$lruHeap.remove({
                                key: key,
                                accessed: item.accessed
                            }), item.accessed = now, $$lruHeap.push({
                                key: key,
                                accessed: now
                            })) : ($$lruHeap.remove(item), item.accessed = now, $$lruHeap.push(item)), "passive" === this.$$deleteOnExpire && "expires" in item && item.expires < now ? (this.remove(key), 
                            this.$$onExpire ? this.$$onExpire.call(this, key, item.value, options.onExpire) : options.onExpire && options.onExpire.call(this, key, item.value), 
                            value = void 0) : $$storage && $$storage().setItem("" + this.$$prefix + ".data." + key, JSON.stringify(item)), 
                            value;
                        },
                        info: function(key) {
                            if (key) {
                                var item = void 0;
                                if ($$storage) {
                                    var itemJson = $$storage().getItem("" + this.$$prefix + ".data." + key);
                                    return itemJson ? (item = angular.fromJson(itemJson), {
                                        created: item.created,
                                        accessed: item.accessed,
                                        expires: item.expires,
                                        isExpired: new Date().getTime() - item.created > this.$$maxAge
                                    }) : void 0;
                                }
                                return key in $$data ? (item = $$data[key], {
                                    created: item.created,
                                    accessed: item.accessed,
                                    expires: item.expires,
                                    isExpired: new Date().getTime() - item.created > this.$$maxAge
                                }) : void 0;
                            }
                            return {
                                id: this.$$id,
                                capacity: this.$$capacity,
                                maxAge: this.$$maxAge,
                                deleteOnExpire: this.$$deleteOnExpire,
                                onExpire: this.$$onExpire,
                                cacheFlushInterval: this.$$cacheFlushInterval,
                                recycleFreq: this.$$recycleFreq,
                                storageMode: this.$$storageMode,
                                storageImpl: $$storage ? $$storage() : void 0,
                                disabled: !!this.$$disabled,
                                size: $$lruHeap && $$lruHeap.size() || 0
                            };
                        },
                        keys: function() {
                            if ($$storage) {
                                var keysJson = $$storage().getItem("" + this.$$prefix + ".keys");
                                return keysJson ? angular.fromJson(keysJson) : [];
                            }
                            return _keys($$data);
                        },
                        keySet: function() {
                            if ($$storage) {
                                var keysJson = $$storage().getItem("" + this.$$prefix + ".keys"), kSet = {};
                                if (keysJson) for (var keys = angular.fromJson(keysJson), i = 0; i < keys.length; i++) kSet[keys[i]] = keys[i];
                                return kSet;
                            }
                            return _keySet($$data);
                        },
                        put: function(key, value, options) {
                            var _this2 = this;
                            options = options || {};
                            var storeOnResolve = "storeOnResolve" in options ? !!options.storeOnResolve : this.$$storeOnResolve, storeOnReject = "storeOnReject" in options ? !!options.storeOnReject : this.$$storeOnReject, getHandler = function(store, isError) {
                                return function(v) {
                                    return store && (delete $$promises[key], angular.isObject(v) && "status" in v && "data" in v ? (v = [ v.status, v.data, v.headers(), v.statusText ], 
                                    _this2.put(key, v)) : _this2.put(key, v)), isError ? $q.reject(v) : v;
                                };
                            };
                            if (!this.$$disabled && null !== value && void 0 !== value) {
                                if (key = _stringifyNumber(key), !angular.isString(key)) throw new Error("key must be a string!");
                                var now = new Date().getTime(), item = {
                                    key: key,
                                    value: _isPromiseLike(value) ? value.then(getHandler(storeOnResolve, !1), getHandler(storeOnReject, !0)) : value,
                                    created: now,
                                    accessed: now
                                };
                                if (item.expires = item.created + this.$$maxAge, $$storage) {
                                    if (_isPromiseLike(item.value)) return $$promises[key] = item.value, $$promises[key];
                                    var keysJson = $$storage().getItem("" + this.$$prefix + ".keys"), keys = keysJson ? angular.fromJson(keysJson) : [], itemJson = $$storage().getItem("" + this.$$prefix + ".data." + key);
                                    itemJson && this.remove(key), $$expiresHeap.push({
                                        key: key,
                                        expires: item.expires
                                    }), $$lruHeap.push({
                                        key: key,
                                        accessed: item.accessed
                                    }), $$storage().setItem("" + this.$$prefix + ".data." + key, JSON.stringify(item));
                                    for (var exists = !1, i = 0; i < keys.length; i++) if (keys[i] === key) {
                                        exists = !0;
                                        break;
                                    }
                                    exists || keys.push(key), $$storage().setItem("" + this.$$prefix + ".keys", JSON.stringify(keys));
                                } else $$data[key] && this.remove(key), $$expiresHeap.push(item), $$lruHeap.push(item), 
                                $$data[key] = item, delete $$promises[key];
                                return $$lruHeap.size() > this.$$capacity && this.remove($$lruHeap.peek().key), 
                                value;
                            }
                        },
                        remove: function(key) {
                            if (key += "", delete $$promises[key], !$$storage) {
                                var value = $$data[key] ? $$data[key].value : void 0;
                                return $$lruHeap.remove($$data[key]), $$expiresHeap.remove($$data[key]), $$data[key] = null, 
                                delete $$data[key], value;
                            }
                            var itemJson = $$storage().getItem("" + this.$$prefix + ".data." + key);
                            if (itemJson) {
                                var item = angular.fromJson(itemJson);
                                $$lruHeap.remove({
                                    key: key,
                                    accessed: item.accessed
                                }), $$expiresHeap.remove({
                                    key: key,
                                    expires: item.expires
                                }), $$storage().removeItem("" + this.$$prefix + ".data." + key);
                                var keysJson = $$storage().getItem("" + this.$$prefix + ".keys"), keys = keysJson ? angular.fromJson(keysJson) : [], index = keys.indexOf(key);
                                return index >= 0 && keys.splice(index, 1), $$storage().setItem("" + this.$$prefix + ".keys", JSON.stringify(keys)), 
                                item.value;
                            }
                        },
                        removeAll: function() {
                            if ($$storage) {
                                $$lruHeap.removeAll(), $$expiresHeap.removeAll();
                                var keysJson = $$storage().getItem("" + this.$$prefix + ".keys");
                                if (keysJson) for (var keys = angular.fromJson(keysJson), i = 0; i < keys.length; i++) this.remove(keys[i]);
                                $$storage().setItem("" + this.$$prefix + ".keys", JSON.stringify([]));
                            } else {
                                $$lruHeap.removeAll(), $$expiresHeap.removeAll();
                                for (var key in $$data) $$data[key] = null;
                                $$data = {};
                            }
                            $$promises = {};
                        },
                        removeExpired: function() {
                            for (var now = new Date().getTime(), expired = {}, key = void 0, expiredItem = void 0; (expiredItem = $$expiresHeap.peek()) && expiredItem.expires <= now; ) expired[expiredItem.key] = expiredItem.value ? expiredItem.value : null, 
                            $$expiresHeap.pop();
                            if ($$storage) for (key in expired) {
                                var itemJson = $$storage().getItem("" + this.$$prefix + ".data." + key);
                                itemJson && (expired[key] = angular.fromJson(itemJson).value, this.remove(key));
                            } else for (key in expired) this.remove(key);
                            if (this.$$onExpire) for (key in expired) this.$$onExpire.call(this, key, expired[key]);
                            return expired;
                        },
                        setCacheFlushInterval: function(cacheFlushInterval) {
                            if (null === cacheFlushInterval) delete this.$$cacheFlushInterval; else {
                                if (!angular.isNumber(cacheFlushInterval)) throw new Error("cacheFlushInterval must be a number!");
                                if (0 > cacheFlushInterval) throw new Error("cacheFlushInterval must be greater than zero!");
                                cacheFlushInterval !== this.$$cacheFlushInterval && (this.$$cacheFlushInterval = cacheFlushInterval, 
                                clearInterval(this.$$cacheFlushIntervalId), function(self) {
                                    self.$$cacheFlushIntervalId = setInterval(function() {
                                        self.removeAll();
                                    }, self.$$cacheFlushInterval);
                                }(this));
                            }
                        },
                        setCapacity: function(capacity) {
                            if (null === capacity) delete this.$$capacity; else {
                                if (!angular.isNumber(capacity)) throw new Error("capacity must be a number!");
                                if (0 > capacity) throw new Error("capacity must be greater than zero!");
                                this.$$capacity = capacity;
                            }
                            for (var removed = {}; $$lruHeap.size() > this.$$capacity; ) removed[$$lruHeap.peek().key] = this.remove($$lruHeap.peek().key);
                            return removed;
                        },
                        setDeleteOnExpire: function(deleteOnExpire, setRecycleFreq) {
                            if (null === deleteOnExpire) delete this.$$deleteOnExpire; else {
                                if (!angular.isString(deleteOnExpire)) throw new Error("deleteOnExpire must be a string!");
                                if ("none" !== deleteOnExpire && "passive" !== deleteOnExpire && "aggressive" !== deleteOnExpire) throw new Error('deleteOnExpire must be "none", "passive" or "aggressive"!');
                                this.$$deleteOnExpire = deleteOnExpire;
                            }
                            setRecycleFreq !== !1 && this.setRecycleFreq(this.$$recycleFreq);
                        },
                        setMaxAge: function(maxAge) {
                            if (null === maxAge) this.$$maxAge = Number.MAX_VALUE; else {
                                if (!angular.isNumber(maxAge)) throw new Error("maxAge must be a number!");
                                if (0 > maxAge) throw new Error("maxAge must be greater than zero!");
                                this.$$maxAge = maxAge;
                            }
                            var i = void 0, keys = void 0, key = void 0;
                            if ($$expiresHeap.removeAll(), $$storage) {
                                var keysJson = $$storage().getItem("" + this.$$prefix + ".keys");
                                for (keys = keysJson ? angular.fromJson(keysJson) : [], i = 0; i < keys.length; i++) {
                                    key = keys[i];
                                    var itemJson = $$storage().getItem("" + this.$$prefix + ".data." + key);
                                    if (itemJson) {
                                        var item = angular.fromJson(itemJson);
                                        this.$$maxAge === Number.MAX_VALUE ? item.expires = Number.MAX_VALUE : item.expires = item.created + this.$$maxAge, 
                                        $$expiresHeap.push({
                                            key: key,
                                            expires: item.expires
                                        });
                                    }
                                }
                            } else for (keys = _keys($$data), i = 0; i < keys.length; i++) key = keys[i], this.$$maxAge === Number.MAX_VALUE ? $$data[key].expires = Number.MAX_VALUE : $$data[key].expires = $$data[key].created + this.$$maxAge, 
                            $$expiresHeap.push($$data[key]);
                            return "aggressive" === this.$$deleteOnExpire ? this.removeExpired() : {};
                        },
                        setOnExpire: function(onExpire) {
                            if (null === onExpire) delete this.$$onExpire; else {
                                if (!angular.isFunction(onExpire)) throw new Error("onExpire must be a function!");
                                this.$$onExpire = onExpire;
                            }
                        },
                        setOptions: function(cacheOptions, strict) {
                            if (cacheOptions = cacheOptions || {}, strict = !!strict, !angular.isObject(cacheOptions)) throw new Error("cacheOptions must be an object!");
                            "storagePrefix" in cacheOptions ? this.$$storagePrefix = cacheOptions.storagePrefix : strict && (this.$$storagePrefix = defaults.storagePrefix), 
                            this.$$prefix = this.$$storagePrefix + this.$$id, "disabled" in cacheOptions ? this.$$disabled = !!cacheOptions.disabled : strict && (this.$$disabled = defaults.disabled), 
                            "storageMode" in cacheOptions || "storageImpl" in cacheOptions ? this.setStorageMode(cacheOptions.storageMode, cacheOptions.storageImpl) : strict && this.setStorageMode(defaults.storageMode, defaults.storageImpl), 
                            "storeOnResolve" in cacheOptions ? this.$$storeOnResolve = !!cacheOptions.storeOnResolve : strict && (this.$$storeOnResolve = defaults.storeOnResolve), 
                            "storeOnReject" in cacheOptions ? this.$$storeOnReject = !!cacheOptions.storeOnReject : strict && (this.$$storeOnReject = defaults.storeOnReject), 
                            "capacity" in cacheOptions ? this.setCapacity(cacheOptions.capacity) : strict && this.setCapacity(defaults.capacity), 
                            "deleteOnExpire" in cacheOptions ? this.setDeleteOnExpire(cacheOptions.deleteOnExpire, !1) : strict && this.setDeleteOnExpire(defaults.deleteOnExpire, !1), 
                            "maxAge" in cacheOptions ? this.setMaxAge(cacheOptions.maxAge) : strict && this.setMaxAge(defaults.maxAge), 
                            "recycleFreq" in cacheOptions ? this.setRecycleFreq(cacheOptions.recycleFreq) : strict && this.setRecycleFreq(defaults.recycleFreq), 
                            "cacheFlushInterval" in cacheOptions ? this.setCacheFlushInterval(cacheOptions.cacheFlushInterval) : strict && this.setCacheFlushInterval(defaults.cacheFlushInterval), 
                            "onExpire" in cacheOptions ? this.setOnExpire(cacheOptions.onExpire) : strict && this.setOnExpire(defaults.onExpire);
                        },
                        setRecycleFreq: function(recycleFreq) {
                            if (null === recycleFreq) delete this.$$recycleFreq; else {
                                if (!angular.isNumber(recycleFreq)) throw new Error("recycleFreq must be a number!");
                                if (0 > recycleFreq) throw new Error("recycleFreq must be greater than zero!");
                                this.$$recycleFreq = recycleFreq;
                            }
                            clearInterval(this.$$recycleFreqId), "aggressive" === this.$$deleteOnExpire ? !function(self) {
                                self.$$recycleFreqId = setInterval(function() {
                                    self.removeExpired();
                                }, self.$$recycleFreq);
                            }(this) : delete this.$$recycleFreqId;
                        },
                        setStorageMode: function(storageMode, storageImpl) {
                            if (!angular.isString(storageMode)) throw new Error("storageMode must be a string!");
                            if ("memory" !== storageMode && "localStorage" !== storageMode && "sessionStorage" !== storageMode) throw new Error('storageMode must be "memory", "localStorage" or "sessionStorage"!');
                            var shouldReInsert = !1, items = {};
                            if ("string" == typeof this.$$storageMode && this.$$storageMode !== storageMode) {
                                var keys = this.keys();
                                if (keys.length) {
                                    for (var i = 0; i < keys.length; i++) items[keys[i]] = this.get(keys[i]);
                                    for (i = 0; i < keys.length; i++) this.remove(keys[i]);
                                    shouldReInsert = !0;
                                }
                            }
                            if (this.$$storageMode = storageMode, storageImpl) {
                                if (!angular.isObject(storageImpl)) throw new Error("storageImpl must be an object!");
                                if (!("setItem" in storageImpl && "function" == typeof storageImpl.setItem)) throw new Error('storageImpl must implement "setItem(key, value)"!');
                                if (!("getItem" in storageImpl && "function" == typeof storageImpl.getItem)) throw new Error('storageImpl must implement "getItem(key)"!');
                                if (!("removeItem" in storageImpl) || "function" != typeof storageImpl.removeItem) throw new Error('storageImpl must implement "removeItem(key)"!');
                                $$storage = function() {
                                    return storageImpl;
                                };
                            } else if ("localStorage" === this.$$storageMode) try {
                                localStorage.setItem("angular-cache", "angular-cache"), localStorage.removeItem("angular-cache"), 
                                $$storage = function() {
                                    return localStorage;
                                };
                            } catch (e) {
                                $$storage = null, this.$$storageMode = "memory";
                            } else if ("sessionStorage" === this.$$storageMode) try {
                                sessionStorage.setItem("angular-cache", "angular-cache"), sessionStorage.removeItem("angular-cache"), 
                                $$storage = function() {
                                    return sessionStorage;
                                };
                            } catch (e) {
                                $$storage = null, this.$$storageMode = "memory";
                            }
                            if (shouldReInsert) for (var key in items) this.put(key, items[key]);
                        },
                        touch: function(key) {
                            var _this2 = this;
                            if (key) {
                                var val = this.get(key, {
                                    onExpire: function(k, v) {
                                        return _this2.put(k, v);
                                    }
                                });
                                val && this.put(key, val);
                            } else for (var keys = this.keys(), i = 0; i < keys.length; i++) this.touch(keys[i]);
                        }
                    };
                    return cache.setOptions(options, !0), cache;
                };
                return CacheFactory.createCache = createCache, CacheFactory.info = function() {
                    var keys = _keys(caches), info = {
                        size: keys.length,
                        caches: {}
                    };
                    angular.extend(info, _this.defaults);
                    for (var i = 0; i < keys.length; i++) {
                        var key = keys[i];
                        info.caches[key] = caches[key].info();
                    }
                    return info;
                }, CacheFactory.get = function(cacheId) {
                    return caches[cacheId];
                }, CacheFactory.keySet = function() {
                    return _keySet(caches);
                }, CacheFactory.keys = function() {
                    return _keys(caches);
                }, CacheFactory.destroy = function(cacheId) {
                    caches[cacheId] && (caches[cacheId].destroy(), delete caches[cacheId]);
                }, CacheFactory.destroyAll = function() {
                    for (var cacheId in caches) caches[cacheId].destroy();
                    caches = {};
                }, CacheFactory.clearAll = function() {
                    for (var cacheId in caches) caches[cacheId].removeAll();
                }, CacheFactory.removeExpiredFromAll = function() {
                    var expired = {};
                    for (var cacheId in caches) expired[cacheId] = caches[cacheId].removeExpired();
                    return expired;
                }, CacheFactory.enableAll = function() {
                    for (var cacheId in caches) caches[cacheId].$$disabled = !1;
                }, CacheFactory.disableAll = function() {
                    for (var cacheId in caches) caches[cacheId].$$disabled = !0;
                }, CacheFactory.touchAll = function() {
                    for (var cacheId in caches) caches[cacheId].touch();
                }, CacheFactory;
            } ];
        };
        angular.module("angular-cache", []).provider("BinaryHeap", BinaryHeapProvider).provider("CacheFactory", CacheFactoryProvider), 
        module.exports = "angular-cache";
    }, function(module, exports, __webpack_require__) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_1__;
    } ]);
}), !function e(t, n, r) {
    function i(a, o) {
        if (!n[a]) {
            if (!t[a]) {
                var u = "function" == typeof require && require;
                if (!o && u) return u(a, !0);
                if (s) return s(a, !0);
                var c = new Error("Cannot find module '" + a + "'");
                throw c.code = "MODULE_NOT_FOUND", c;
            }
            var l = n[a] = {
                exports: {}
            };
            t[a][0].call(l.exports, function(e) {
                var n = t[a][1][e];
                return i(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }
        return n[a].exports;
    }
    for (var s = "function" == typeof require && require, a = 0; a < r.length; a++) i(r[a]);
    return i;
}({
    1: [ function(e, t) {
        "use strict";
        var n = e("underscore");
        t.exports = function(e) {
            var t = "*";
            e.ACL = function(t) {
                var r = this;
                if (r.permissionsById = {}, n.isObject(t)) if (t instanceof e.User) r.setReadAccess(t, !0), 
                r.setWriteAccess(t, !0); else {
                    if (n.isFunction(t)) throw "AV.ACL() called with a function.  Did you forget ()?";
                    e._objectEach(t, function(t, i) {
                        if (!n.isString(i)) throw "Tried to create an ACL with an invalid userId.";
                        r.permissionsById[i] = {}, e._objectEach(t, function(e, t) {
                            if ("read" !== t && "write" !== t) throw "Tried to create an ACL with an invalid permission type.";
                            if (!n.isBoolean(e)) throw "Tried to create an ACL with an invalid permission value.";
                            r.permissionsById[i][t] = e;
                        });
                    });
                }
            }, e.ACL.prototype.toJSON = function() {
                return n.clone(this.permissionsById);
            }, e.ACL.prototype._setAccess = function(t, r, i) {
                if (r instanceof e.User ? r = r.id : r instanceof e.Role && (r = "role:" + r.getName()), 
                !n.isString(r)) throw "userId must be a string.";
                if (!n.isBoolean(i)) throw "allowed must be either true or false.";
                var s = this.permissionsById[r];
                if (!s) {
                    if (!i) return;
                    s = {}, this.permissionsById[r] = s;
                }
                i ? this.permissionsById[r][t] = !0 : (delete s[t], n.isEmpty(s) && delete s[r]);
            }, e.ACL.prototype._getAccess = function(t, n) {
                n instanceof e.User ? n = n.id : n instanceof e.Role && (n = "role:" + n.getName());
                var r = this.permissionsById[n];
                return r && r[t] ? !0 : !1;
            }, e.ACL.prototype.setReadAccess = function(e, t) {
                this._setAccess("read", e, t);
            }, e.ACL.prototype.getReadAccess = function(e) {
                return this._getAccess("read", e);
            }, e.ACL.prototype.setWriteAccess = function(e, t) {
                this._setAccess("write", e, t);
            }, e.ACL.prototype.getWriteAccess = function(e) {
                return this._getAccess("write", e);
            }, e.ACL.prototype.setPublicReadAccess = function(e) {
                this.setReadAccess(t, e);
            }, e.ACL.prototype.getPublicReadAccess = function() {
                return this.getReadAccess(t);
            }, e.ACL.prototype.setPublicWriteAccess = function(e) {
                this.setWriteAccess(t, e);
            }, e.ACL.prototype.getPublicWriteAccess = function() {
                return this.getWriteAccess(t);
            }, e.ACL.prototype.getRoleReadAccess = function(t) {
                if (t instanceof e.Role && (t = t.getName()), n.isString(t)) return this.getReadAccess("role:" + t);
                throw "role must be a AV.Role or a String";
            }, e.ACL.prototype.getRoleWriteAccess = function(t) {
                if (t instanceof e.Role && (t = t.getName()), n.isString(t)) return this.getWriteAccess("role:" + t);
                throw "role must be a AV.Role or a String";
            }, e.ACL.prototype.setRoleReadAccess = function(t, r) {
                if (t instanceof e.Role && (t = t.getName()), n.isString(t)) return void this.setReadAccess("role:" + t, r);
                throw "role must be a AV.Role or a String";
            }, e.ACL.prototype.setRoleWriteAccess = function(t, r) {
                if (t instanceof e.Role && (t = t.getName()), n.isString(t)) return void this.setWriteAccess("role:" + t, r);
                throw "role must be a AV.Role or a String";
            };
        };
    }, {
        underscore: 29
    } ],
    2: [ function(e) {
        (function(t) {
            var n = {};
            n._ = e("underscore"), n.VERSION = e("./version"), n.Promise = e("./promise"), n.XMLHttpRequest = e("xmlhttprequest").XMLHttpRequest, 
            n.localStorage = e("localStorage"), e("./utils")(n), e("./error")(n), e("./event")(n), 
            e("./geopoint")(n), e("./acl")(n), e("./op")(n), e("./relation")(n), e("./file")(n), 
            e("./object")(n), e("./role")(n), e("./user")(n), e("./query")(n), e("./cloudfunction")(n), 
            e("./push")(n), e("./status")(n), e("./search")(n), e("./insight")(n), e("./bigquery")(n), 
            t.AV = n;
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {
        "./acl": 1,
        "./bigquery": 3,
        "./cloudfunction": 8,
        "./error": 9,
        "./event": 10,
        "./file": 11,
        "./geopoint": 12,
        "./insight": 13,
        "./object": 14,
        "./op": 15,
        "./promise": 16,
        "./push": 17,
        "./query": 18,
        "./relation": 19,
        "./role": 20,
        "./search": 21,
        "./status": 22,
        "./user": 23,
        "./utils": 24,
        "./version": 25,
        localStorage: 4,
        underscore: 29,
        xmlhttprequest: 7
    } ],
    3: [ function(e, t) {
        "use strict";
        t.exports = function(e) {
            Object.defineProperty(e, "BigQuery", {
                get: function() {
                    return console.warn("AV.BigQuery is deprecated, please use AV.Insight instead."), 
                    e.Insight;
                }
            });
        };
    }, {} ],
    4: [ function(e, t) {
        (function(n) {
            "use strict";
            var r = n.localStorage;
            try {
                var i = "__storejs__";
                if (r.setItem(i, i), r.getItem(i) != i) throw new Error();
                r.removeItem(i);
            } catch (s) {
                r = e("localstorage-memory");
            }
            t.exports = r;
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {
        "localstorage-memory": 28
    } ],
    5: [ function(e, t) {
        "use strict";
        var n = function(e, t) {
            var n;
            n = e.indexOf("base64") < 0 ? atob(e) : e.split(",")[0].indexOf("base64") >= 0 ? atob(e.split(",")[1]) : unescape(e.split(",")[1]);
            for (var r = t || e.split(",")[0].split(":")[1].split(";")[0], i = new Uint8Array(n.length), s = 0; s < n.length; s++) i[s] = n.charCodeAt(s);
            return new Blob([ i ], {
                type: r
            });
        };
        t.exports = n;
    }, {} ],
    6: [ function(e, t) {
        "use strict";
        t.exports = function(e, t, n) {
            var r, i = e;
            i._previousSave = i._source.then(function(e, t) {
                return r = e, i._qiniuToken(t);
            }).then(function(e) {
                i._url = e.url, i._bucket = e.bucket, i.id = e.objectId;
                var s = e.token, a = new FormData();
                a.append("file", r, i._name), a.append("key", i._qiniu_key), a.append("token", s);
                var o = new t.Promise(), u = !1, c = new t.XMLHttpRequest();
                return c.upload.addEventListener("progress", function(e) {
                    e.lengthComputable && n.onProgress && n.onProgress(e);
                }, !1), c.onreadystatechange = function() {
                    if (4 === c.readyState) {
                        if (u) return;
                        if (u = !0, delete i._qiniu_key, c.status >= 200 && c.status < 300) {
                            var e;
                            try {
                                e = JSON.parse(c.responseText);
                            } catch (t) {
                                o.reject(t), i.destroy();
                            }
                            e ? o.resolve(i) : o.reject(e);
                        } else o.reject(c), i.destroy();
                    }
                }, c.open("POST", "http://upload.qiniu.com", !0), c.send(a), o;
            });
        };
    }, {} ],
    7: [ function(e, t, n) {
        (function(e) {
            "use strict";
            n.XMLHttpRequest = e.XMLHttpRequest;
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {} ],
    8: [ function(e, t) {
        "use strict";
        var n = e("underscore");
        t.exports = function(e) {
            e.Cloud = e.Cloud || {}, n.extend(e.Cloud, {
                run: function(t, n, r) {
                    var i = e._request("functions", t, null, "POST", e._encode(n, null, !0));
                    return i.then(function(t) {
                        return e._decode(null, t).result;
                    })._thenRunCallbacks(r);
                },
                getServerDate: function(t) {
                    var n = e._request("date", null, null, "GET");
                    return n.then(function(t) {
                        return e._decode(null, t);
                    })._thenRunCallbacks(t);
                },
                requestSmsCode: function(t, r) {
                    if (n.isString(t) && (t = {
                        mobilePhoneNumber: t
                    }), !t.mobilePhoneNumber) throw "Missing mobilePhoneNumber.";
                    var i = e._request("requestSmsCode", null, null, "POST", t);
                    return i._thenRunCallbacks(r);
                },
                verifySmsCode: function(t, n, r) {
                    if (!t) throw "Missing sms code.";
                    var i = {};
                    e._.isString(n) ? i.mobilePhoneNumber = n : r = n;
                    var s = e._request("verifySmsCode", t, null, "POST", i);
                    return s._thenRunCallbacks(r);
                }
            });
        };
    }, {
        underscore: 29
    } ],
    9: [ function(e, t) {
        "use strict";
        var n = e("underscore");
        t.exports = function(e) {
            e.Error = function(e, t) {
                this.code = e, this.message = t;
            }, n.extend(e.Error, {
                OTHER_CAUSE: -1,
                INTERNAL_SERVER_ERROR: 1,
                CONNECTION_FAILED: 100,
                OBJECT_NOT_FOUND: 101,
                INVALID_QUERY: 102,
                INVALID_CLASS_NAME: 103,
                MISSING_OBJECT_ID: 104,
                INVALID_KEY_NAME: 105,
                INVALID_POINTER: 106,
                INVALID_JSON: 107,
                COMMAND_UNAVAILABLE: 108,
                NOT_INITIALIZED: 109,
                INCORRECT_TYPE: 111,
                INVALID_CHANNEL_NAME: 112,
                PUSH_MISCONFIGURED: 115,
                OBJECT_TOO_LARGE: 116,
                OPERATION_FORBIDDEN: 119,
                CACHE_MISS: 120,
                INVALID_NESTED_KEY: 121,
                INVALID_FILE_NAME: 122,
                INVALID_ACL: 123,
                TIMEOUT: 124,
                INVALID_EMAIL_ADDRESS: 125,
                MISSING_CONTENT_TYPE: 126,
                MISSING_CONTENT_LENGTH: 127,
                INVALID_CONTENT_LENGTH: 128,
                FILE_TOO_LARGE: 129,
                FILE_SAVE_ERROR: 130,
                FILE_DELETE_ERROR: 153,
                DUPLICATE_VALUE: 137,
                INVALID_ROLE_NAME: 139,
                EXCEEDED_QUOTA: 140,
                SCRIPT_FAILED: 141,
                VALIDATION_ERROR: 142,
                INVALID_IMAGE_DATA: 150,
                UNSAVED_FILE_ERROR: 151,
                INVALID_PUSH_TIME_ERROR: 152,
                USERNAME_MISSING: 200,
                PASSWORD_MISSING: 201,
                USERNAME_TAKEN: 202,
                EMAIL_TAKEN: 203,
                EMAIL_MISSING: 204,
                EMAIL_NOT_FOUND: 205,
                SESSION_MISSING: 206,
                MUST_CREATE_USER_THROUGH_SIGNUP: 207,
                ACCOUNT_ALREADY_LINKED: 208,
                LINKED_ID_MISSING: 250,
                INVALID_LINKED_SESSION: 251,
                UNSUPPORTED_SERVICE: 252,
                X_DOMAIN_REQUEST: 602
            });
        };
    }, {
        underscore: 29
    } ],
    10: [ function(e, t) {
        t.exports = function(e) {
            var t = /\s+/, n = Array.prototype.slice;
            e.Events = {
                on: function(e, n, r) {
                    var i, s, a, o, u;
                    if (!n) return this;
                    for (e = e.split(t), i = this._callbacks || (this._callbacks = {}), s = e.shift(); s; ) u = i[s], 
                    a = u ? u.tail : {}, a.next = o = {}, a.context = r, a.callback = n, i[s] = {
                        tail: o,
                        next: u ? u.next : a
                    }, s = e.shift();
                    return this;
                },
                off: function(e, n, r) {
                    var i, s, a, o, u, c;
                    if (s = this._callbacks) {
                        if (!(e || n || r)) return delete this._callbacks, this;
                        for (e = e ? e.split(t) : _.keys(s), i = e.shift(); i; ) if (a = s[i], delete s[i], 
                        a && (n || r)) {
                            for (o = a.tail, a = a.next; a !== o; ) u = a.callback, c = a.context, (n && u !== n || r && c !== r) && this.on(i, u, c), 
                            a = a.next;
                            i = e.shift();
                        }
                        return this;
                    }
                },
                trigger: function(e) {
                    var r, i, s, a, o, u, c;
                    if (!(s = this._callbacks)) return this;
                    for (u = s.all, e = e.split(t), c = n.call(arguments, 1), r = e.shift(); r; ) {
                        if (i = s[r]) for (a = i.tail; (i = i.next) !== a; ) i.callback.apply(i.context || this, c);
                        if (i = u) for (a = i.tail, o = [ r ].concat(c); (i = i.next) !== a; ) i.callback.apply(i.context || this, o);
                        r = e.shift();
                    }
                    return this;
                }
            }, e.Events.bind = e.Events.on, e.Events.unbind = e.Events.off;
        };
    }, {} ],
    11: [ function(e, t) {
        (function(n) {
            "use strict";
            var r = e("path"), i = e("underscore");
            t.exports = function(t) {
                var s = function(e) {
                    if (26 > e) return String.fromCharCode(65 + e);
                    if (52 > e) return String.fromCharCode(97 + (e - 26));
                    if (62 > e) return String.fromCharCode(48 + (e - 52));
                    if (62 === e) return "+";
                    if (63 === e) return "/";
                    throw "Tried to encode large digit " + e + " in base64.";
                }, a = function(e) {
                    var t = [];
                    return t.length = Math.ceil(e.length / 3), i.times(t.length, function(n) {
                        var r = e[3 * n], i = e[3 * n + 1] || 0, a = e[3 * n + 2] || 0, o = 3 * n + 1 < e.length, u = 3 * n + 2 < e.length;
                        t[n] = [ s(r >> 2 & 63), s(r << 4 & 48 | i >> 4 & 15), o ? s(i << 2 & 60 | a >> 6 & 3) : "=", u ? s(63 & a) : "=" ].join("");
                    }), t.join("");
                }, o = {
                    ai: "application/postscript",
                    aif: "audio/x-aiff",
                    aifc: "audio/x-aiff",
                    aiff: "audio/x-aiff",
                    asc: "text/plain",
                    atom: "application/atom+xml",
                    au: "audio/basic",
                    avi: "video/x-msvideo",
                    bcpio: "application/x-bcpio",
                    bin: "application/octet-stream",
                    bmp: "image/bmp",
                    cdf: "application/x-netcdf",
                    cgm: "image/cgm",
                    "class": "application/octet-stream",
                    cpio: "application/x-cpio",
                    cpt: "application/mac-compactpro",
                    csh: "application/x-csh",
                    css: "text/css",
                    dcr: "application/x-director",
                    dif: "video/x-dv",
                    dir: "application/x-director",
                    djv: "image/vnd.djvu",
                    djvu: "image/vnd.djvu",
                    dll: "application/octet-stream",
                    dmg: "application/octet-stream",
                    dms: "application/octet-stream",
                    doc: "application/msword",
                    docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
                    dotx: "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
                    docm: "application/vnd.ms-word.document.macroEnabled.12",
                    dotm: "application/vnd.ms-word.template.macroEnabled.12",
                    dtd: "application/xml-dtd",
                    dv: "video/x-dv",
                    dvi: "application/x-dvi",
                    dxr: "application/x-director",
                    eps: "application/postscript",
                    etx: "text/x-setext",
                    exe: "application/octet-stream",
                    ez: "application/andrew-inset",
                    gif: "image/gif",
                    gram: "application/srgs",
                    grxml: "application/srgs+xml",
                    gtar: "application/x-gtar",
                    hdf: "application/x-hdf",
                    hqx: "application/mac-binhex40",
                    htm: "text/html",
                    html: "text/html",
                    ice: "x-conference/x-cooltalk",
                    ico: "image/x-icon",
                    ics: "text/calendar",
                    ief: "image/ief",
                    ifb: "text/calendar",
                    iges: "model/iges",
                    igs: "model/iges",
                    jnlp: "application/x-java-jnlp-file",
                    jp2: "image/jp2",
                    jpe: "image/jpeg",
                    jpeg: "image/jpeg",
                    jpg: "image/jpeg",
                    js: "application/x-javascript",
                    kar: "audio/midi",
                    latex: "application/x-latex",
                    lha: "application/octet-stream",
                    lzh: "application/octet-stream",
                    m3u: "audio/x-mpegurl",
                    m4a: "audio/mp4a-latm",
                    m4b: "audio/mp4a-latm",
                    m4p: "audio/mp4a-latm",
                    m4u: "video/vnd.mpegurl",
                    m4v: "video/x-m4v",
                    mac: "image/x-macpaint",
                    man: "application/x-troff-man",
                    mathml: "application/mathml+xml",
                    me: "application/x-troff-me",
                    mesh: "model/mesh",
                    mid: "audio/midi",
                    midi: "audio/midi",
                    mif: "application/vnd.mif",
                    mov: "video/quicktime",
                    movie: "video/x-sgi-movie",
                    mp2: "audio/mpeg",
                    mp3: "audio/mpeg",
                    mp4: "video/mp4",
                    mpe: "video/mpeg",
                    mpeg: "video/mpeg",
                    mpg: "video/mpeg",
                    mpga: "audio/mpeg",
                    ms: "application/x-troff-ms",
                    msh: "model/mesh",
                    mxu: "video/vnd.mpegurl",
                    nc: "application/x-netcdf",
                    oda: "application/oda",
                    ogg: "application/ogg",
                    pbm: "image/x-portable-bitmap",
                    pct: "image/pict",
                    pdb: "chemical/x-pdb",
                    pdf: "application/pdf",
                    pgm: "image/x-portable-graymap",
                    pgn: "application/x-chess-pgn",
                    pic: "image/pict",
                    pict: "image/pict",
                    png: "image/png",
                    pnm: "image/x-portable-anymap",
                    pnt: "image/x-macpaint",
                    pntg: "image/x-macpaint",
                    ppm: "image/x-portable-pixmap",
                    ppt: "application/vnd.ms-powerpoint",
                    pptx: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
                    potx: "application/vnd.openxmlformats-officedocument.presentationml.template",
                    ppsx: "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
                    ppam: "application/vnd.ms-powerpoint.addin.macroEnabled.12",
                    pptm: "application/vnd.ms-powerpoint.presentation.macroEnabled.12",
                    potm: "application/vnd.ms-powerpoint.template.macroEnabled.12",
                    ppsm: "application/vnd.ms-powerpoint.slideshow.macroEnabled.12",
                    ps: "application/postscript",
                    qt: "video/quicktime",
                    qti: "image/x-quicktime",
                    qtif: "image/x-quicktime",
                    ra: "audio/x-pn-realaudio",
                    ram: "audio/x-pn-realaudio",
                    ras: "image/x-cmu-raster",
                    rdf: "application/rdf+xml",
                    rgb: "image/x-rgb",
                    rm: "application/vnd.rn-realmedia",
                    roff: "application/x-troff",
                    rtf: "text/rtf",
                    rtx: "text/richtext",
                    sgm: "text/sgml",
                    sgml: "text/sgml",
                    sh: "application/x-sh",
                    shar: "application/x-shar",
                    silo: "model/mesh",
                    sit: "application/x-stuffit",
                    skd: "application/x-koan",
                    skm: "application/x-koan",
                    skp: "application/x-koan",
                    skt: "application/x-koan",
                    smi: "application/smil",
                    smil: "application/smil",
                    snd: "audio/basic",
                    so: "application/octet-stream",
                    spl: "application/x-futuresplash",
                    src: "application/x-wais-source",
                    sv4cpio: "application/x-sv4cpio",
                    sv4crc: "application/x-sv4crc",
                    svg: "image/svg+xml",
                    swf: "application/x-shockwave-flash",
                    t: "application/x-troff",
                    tar: "application/x-tar",
                    tcl: "application/x-tcl",
                    tex: "application/x-tex",
                    texi: "application/x-texinfo",
                    texinfo: "application/x-texinfo",
                    tif: "image/tiff",
                    tiff: "image/tiff",
                    tr: "application/x-troff",
                    tsv: "text/tab-separated-values",
                    txt: "text/plain",
                    ustar: "application/x-ustar",
                    vcd: "application/x-cdlink",
                    vrml: "model/vrml",
                    vxml: "application/voicexml+xml",
                    wav: "audio/x-wav",
                    wbmp: "image/vnd.wap.wbmp",
                    wbmxl: "application/vnd.wap.wbxml",
                    wml: "text/vnd.wap.wml",
                    wmlc: "application/vnd.wap.wmlc",
                    wmls: "text/vnd.wap.wmlscript",
                    wmlsc: "application/vnd.wap.wmlscriptc",
                    wrl: "model/vrml",
                    xbm: "image/x-xbitmap",
                    xht: "application/xhtml+xml",
                    xhtml: "application/xhtml+xml",
                    xls: "application/vnd.ms-excel",
                    xml: "application/xml",
                    xpm: "image/x-xpixmap",
                    xsl: "application/xml",
                    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                    xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
                    xlsm: "application/vnd.ms-excel.sheet.macroEnabled.12",
                    xltm: "application/vnd.ms-excel.template.macroEnabled.12",
                    xlam: "application/vnd.ms-excel.addin.macroEnabled.12",
                    xlsb: "application/vnd.ms-excel.sheet.binary.macroEnabled.12",
                    xslt: "application/xslt+xml",
                    xul: "application/vnd.mozilla.xul+xml",
                    xwd: "image/x-xwindowdump",
                    xyz: "chemical/x-xyz",
                    zip: "application/zip"
                };
                t.File = function(r, s, u) {
                    this._name = r;
                    var c = t.User.current();
                    this._metaData = {
                        owner: null != c ? c.id : "unknown"
                    };
                    var l = /\.([^.]*)$/.exec(r);
                    l && (l = l[1].toLowerCase());
                    var h = u || o[l] || "text/plain";
                    if (this._guessedType = h, i.isArray(s)) this._source = t.Promise.as(a(s), h), this._metaData.size = s.length; else if (s && s.base64) {
                        var f = e("./browserify-wrapper/parse-base64"), d = f(s.base64, h);
                        this._source = t.Promise.as(d, h);
                    } else if (s && s.blob) this._source = t.Promise.as(s.blob, h); else if ("undefined" != typeof File && s instanceof File) this._source = t.Promise.as(s, h); else if (t._isNode && n.Buffer.isBuffer(s)) this._source = t.Promise.as(s.toString("base64"), h), 
                    this._metaData.size = s.length; else if (i.isString(s)) throw "Creating a AV.File from a String is not yet supported.";
                }, t.File.withURL = function(e, n, r, i) {
                    if (!e || !n) throw "Please provide file name and url";
                    var s = new t.File(e, null, i);
                    if (r) for (var a in r) s._metaData[a] || (s._metaData[a] = r[a]);
                    return s._url = n, s._metaData.__source = "external", s;
                }, t.File.createWithoutData = function(e) {
                    var n = new t.File();
                    return n.id = e, n;
                }, t.File.prototype = {
                    toJSON: function() {
                        return t._encode(this);
                    },
                    getACL: function() {
                        return this._acl;
                    },
                    setACL: function(e) {
                        return e instanceof t.ACL ? void (this._acl = e) : new t.Error(t.Error.OTHER_CAUSE, "ACL must be a AV.ACL.");
                    },
                    name: function() {
                        return this._name;
                    },
                    url: function() {
                        return this._url;
                    },
                    metaData: function(e, t) {
                        return null != e && null != t ? (this._metaData[e] = t, this) : null != e ? this._metaData[e] : this._metaData;
                    },
                    thumbnailURL: function(e, t, n, r, i) {
                        if (!this.url()) throw "Invalid url.";
                        if (!e || !t || 0 >= e || 0 >= t) throw "Invalid width or height value.";
                        if (n = n || 100, r = null == r ? !0 : r, 0 >= n || n > 100) throw "Invalid quality value.";
                        i = i || "png";
                        var s = r ? 2 : 1;
                        return this.url() + "?imageView/" + s + "/w/" + e + "/h/" + t + "/q/" + n + "/format/" + i;
                    },
                    size: function() {
                        return this.metaData().size;
                    },
                    ownerId: function() {
                        return this.metaData().owner;
                    },
                    destroy: function(e) {
                        if (!this.id) return t.Promise.error("The file id is not eixsts.")._thenRunCallbacks(e);
                        var n = t._request("files", null, this.id, "DELETE");
                        return n._thenRunCallbacks(e);
                    },
                    _qiniuToken: function(e) {
                        var n = this, i = r.extname(n._name), s = function() {
                            return Math.floor(65536 * (1 + Math.random())).toString(16).substring(1);
                        }, a = s() + s() + s() + s() + s() + i, o = {
                            key: a,
                            ACL: n._acl,
                            name: n._name,
                            mime_type: e,
                            metaData: n._metaData
                        };
                        return e && null == n._metaData.mime_type && (n._metaData.mime_type = e), n._qiniu_key = a, 
                        t._request("qiniu", null, null, "POST", o);
                    },
                    save: function() {
                        var n = null, r = {};
                        1 === arguments.length ? n = arguments[0] : 2 === arguments.length && (r = arguments[0], 
                        n = arguments[1]);
                        var i = this;
                        if (!i._previousSave) if (i._source) {
                            var s = e("./browserify-wrapper/upload");
                            s(i, t, r);
                        } else if (i._url && "external" == i._metaData.__source) {
                            var a = {
                                name: i._name,
                                ACL: i._acl,
                                metaData: i._metaData,
                                mime_type: i._guessedType,
                                url: i._url
                            };
                            i._previousSave = t._request("files", i._name, null, "POST", a).then(function(e) {
                                return i._name = e.name, i._url = e.url, i.id = e.objectId, e.size && (i._metaData.size = e.size), 
                                i;
                            });
                        }
                        return i._previousSave._thenRunCallbacks(n);
                    }
                };
            };
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {
        "./browserify-wrapper/parse-base64": 5,
        "./browserify-wrapper/upload": 6,
        path: 26,
        underscore: 29
    } ],
    12: [ function(e, t) {
        var n = e("underscore");
        t.exports = function(e) {
            e.GeoPoint = function(t, r) {
                n.isArray(t) ? (e.GeoPoint._validate(t[0], t[1]), this.latitude = t[0], this.longitude = t[1]) : n.isObject(t) ? (e.GeoPoint._validate(t.latitude, t.longitude), 
                this.latitude = t.latitude, this.longitude = t.longitude) : n.isNumber(t) && n.isNumber(r) ? (e.GeoPoint._validate(t, r), 
                this.latitude = t, this.longitude = r) : (this.latitude = 0, this.longitude = 0);
                var i = this;
                this.__defineGetter__ && this.__defineSetter__ && (this._latitude = this.latitude, 
                this._longitude = this.longitude, this.__defineGetter__("latitude", function() {
                    return i._latitude;
                }), this.__defineGetter__("longitude", function() {
                    return i._longitude;
                }), this.__defineSetter__("latitude", function(t) {
                    e.GeoPoint._validate(t, i.longitude), i._latitude = t;
                }), this.__defineSetter__("longitude", function(t) {
                    e.GeoPoint._validate(i.latitude, t), i._longitude = t;
                }));
            }, e.GeoPoint._validate = function(e, t) {
                if (-90 > e) throw "AV.GeoPoint latitude " + e + " < -90.0.";
                if (e > 90) throw "AV.GeoPoint latitude " + e + " > 90.0.";
                if (-180 > t) throw "AV.GeoPoint longitude " + t + " < -180.0.";
                if (t > 180) throw "AV.GeoPoint longitude " + t + " > 180.0.";
            }, e.GeoPoint.current = function(t) {
                var n = new e.Promise();
                return navigator.geolocation.getCurrentPosition(function(t) {
                    n.resolve(new e.GeoPoint({
                        latitude: t.coords.latitude,
                        longitude: t.coords.longitude
                    }));
                }, function(e) {
                    n.reject(e);
                }), n._thenRunCallbacks(t);
            }, e.GeoPoint.prototype = {
                toJSON: function() {
                    return e.GeoPoint._validate(this.latitude, this.longitude), {
                        __type: "GeoPoint",
                        latitude: this.latitude,
                        longitude: this.longitude
                    };
                },
                radiansTo: function(e) {
                    var t = Math.PI / 180, n = this.latitude * t, r = this.longitude * t, i = e.latitude * t, s = e.longitude * t, a = n - i, o = r - s, u = Math.sin(a / 2), c = Math.sin(o / 2), l = u * u + Math.cos(n) * Math.cos(i) * c * c;
                    return l = Math.min(1, l), 2 * Math.asin(Math.sqrt(l));
                },
                kilometersTo: function(e) {
                    return 6371 * this.radiansTo(e);
                },
                milesTo: function(e) {
                    return 3958.8 * this.radiansTo(e);
                }
            };
        };
    }, {
        underscore: 29
    } ],
    13: [ function(e, t) {
        "use strict";
        var n = e("underscore");
        t.exports = function(e) {
            e.Insight = e.Insight || {}, n.extend(e.Insight, {
                startJob: function(t, n) {
                    if (!t || !t.sql) throw new Error("Please provide the sql to run the job.");
                    var r = {
                        jobConfig: t,
                        appId: e.applicationId
                    }, i = e._request("bigquery", "jobs", null, "POST", e._encode(r, null, !0));
                    return i.then(function(t) {
                        return e._decode(null, t).id;
                    })._thenRunCallbacks(n);
                },
                on: function() {}
            }), e.Insight.JobQuery = function(e, t) {
                if (!e) throw new Error("Please provide the job id.");
                this.id = e, this.className = t, this._skip = 0, this._limit = 100;
            }, e.Insight.JobQuery.prototype = {
                skip: function(e) {
                    return this._skip = e, this;
                },
                limit: function(e) {
                    return this._limit = e, this;
                },
                find: function(t) {
                    var n = {
                        skip: this._skip,
                        limit: this._limit
                    }, r = e._request("bigquery", "jobs", this.id, "GET", n);
                    return r.then(function(t) {
                        return t.error ? e.Promise.error(new e.Error(t.code, t.error)) : e.Promise.as(t);
                    })._thenRunCallbacks(t);
                }
            };
        };
    }, {
        underscore: 29
    } ],
    14: [ function(e, t) {
        "use strict";
        var n = e("underscore");
        t.exports = function(e) {
            e.Object = function(t, r) {
                if (n.isString(t)) return e.Object._create.apply(this, arguments);
                t = t || {}, r && r.parse && (t = this.parse(t));
                var i = e._getValue(this, "defaults");
                if (i && (t = n.extend({}, i, t)), r && r.collection && (this.collection = r.collection), 
                this._serverData = {}, this._opSetQueue = [ {} ], this.attributes = {}, this._hashedJSON = {}, 
                this._escapedAttributes = {}, this.cid = n.uniqueId("c"), this.changed = {}, this._silent = {}, 
                this._pending = {}, !this.set(t, {
                    silent: !0
                })) throw new Error("Can't create an invalid AV.Object");
                this.changed = {}, this._silent = {}, this._pending = {}, this._hasData = !0, this._previousAttributes = n.clone(this.attributes), 
                this.initialize.apply(this, arguments);
            }, e.Object.saveAll = function(t, n) {
                return e.Object._deepSaveAsync(t)._thenRunCallbacks(n);
            }, n.extend(e.Object.prototype, e.Events, {
                _existed: !1,
                _fetchWhenSave: !1,
                initialize: function() {},
                fetchWhenSave: function(e) {
                    if (!n.isBoolean(e)) throw "Expect boolean value for fetchWhenSave";
                    this._fetchWhenSave = e;
                },
                getObjectId: function() {
                    return this.id;
                },
                getCreatedAt: function() {
                    return this.createdAt || this.get("createdAt");
                },
                getUpdatedAt: function() {
                    return this.updatedAt || this.get("updatedAt");
                },
                toJSON: function() {
                    var t = this._toFullJSON();
                    return e._arrayEach([ "__type", "className" ], function(e) {
                        delete t[e];
                    }), t;
                },
                _toFullJSON: function(t) {
                    var r = n.clone(this.attributes);
                    return e._objectEach(r, function(n, i) {
                        r[i] = e._encode(n, t);
                    }), e._objectEach(this._operations, function(e, t) {
                        r[t] = e;
                    }), n.has(this, "id") && (r.objectId = this.id), n.has(this, "createdAt") && (r.createdAt = n.isDate(this.createdAt) ? this.createdAt.toJSON() : this.createdAt), 
                    n.has(this, "updatedAt") && (r.updatedAt = n.isDate(this.updatedAt) ? this.updatedAt.toJSON() : this.updatedAt), 
                    r.__type = "Object", r.className = this.className, r;
                },
                _refreshCache: function() {
                    var t = this;
                    t._refreshingCache || (t._refreshingCache = !0, e._objectEach(this.attributes, function(r, i) {
                        r instanceof e.Object ? r._refreshCache() : n.isObject(r) && t._resetCacheForKey(i) && t.set(i, new e.Op.Set(r), {
                            silent: !0
                        });
                    }), delete t._refreshingCache);
                },
                dirty: function(e) {
                    this._refreshCache();
                    var t = n.last(this._opSetQueue);
                    return e ? t[e] ? !0 : !1 : this.id ? n.keys(t).length > 0 ? !0 : !1 : !0;
                },
                _toPointer: function() {
                    return {
                        __type: "Pointer",
                        className: this.className,
                        objectId: this.id
                    };
                },
                get: function(e) {
                    return this.attributes[e];
                },
                relation: function(t) {
                    var n = this.get(t);
                    if (n) {
                        if (!(n instanceof e.Relation)) throw "Called relation() on non-relation field " + t;
                        return n._ensureParentAndKey(this, t), n;
                    }
                    return new e.Relation(this, t);
                },
                escape: function(t) {
                    var r = this._escapedAttributes[t];
                    if (r) return r;
                    var i, s = this.attributes[t];
                    return i = e._isNullOrUndefined(s) ? "" : n.escape(s.toString()), this._escapedAttributes[t] = i, 
                    i;
                },
                has: function(t) {
                    return !e._isNullOrUndefined(this.attributes[t]);
                },
                _mergeMagicFields: function(t) {
                    var r = this, i = [ "id", "objectId", "createdAt", "updatedAt" ];
                    e._arrayEach(i, function(i) {
                        t[i] && ("objectId" === i ? r.id = t[i] : r[i] = "createdAt" !== i && "updatedAt" !== i || n.isDate(t[i]) ? t[i] : e._parseDate(t[i]), 
                        delete t[i]);
                    });
                },
                _startSave: function() {
                    this._opSetQueue.push({});
                },
                _cancelSave: function() {
                    var t = n.first(this._opSetQueue);
                    this._opSetQueue = n.rest(this._opSetQueue);
                    var r = n.first(this._opSetQueue);
                    e._objectEach(t, function(e, n) {
                        var i = t[n], s = r[n];
                        i && s ? r[n] = s._mergeWithPrevious(i) : i && (r[n] = i);
                    }), this._saving = this._saving - 1;
                },
                _finishSave: function(t) {
                    var r = {};
                    e._traverse(this.attributes, function(t) {
                        t instanceof e.Object && t.id && t._hasData && (r[t.id] = t);
                    });
                    var i = n.first(this._opSetQueue);
                    this._opSetQueue = n.rest(this._opSetQueue), this._applyOpSet(i, this._serverData), 
                    this._mergeMagicFields(t);
                    var s = this;
                    e._objectEach(t, function(t, n) {
                        s._serverData[n] = e._decode(n, t);
                        var i = e._traverse(s._serverData[n], function(t) {
                            return t instanceof e.Object && r[t.id] ? r[t.id] : void 0;
                        });
                        i && (s._serverData[n] = i);
                    }), this._rebuildAllEstimatedData(), this._saving = this._saving - 1;
                },
                _finishFetch: function(t, n) {
                    this._opSetQueue = [ {} ], this._mergeMagicFields(t);
                    var r = this;
                    e._objectEach(t, function(t, n) {
                        r._serverData[n] = e._decode(n, t);
                    }), this._rebuildAllEstimatedData(), this._refreshCache(), this._opSetQueue = [ {} ], 
                    this._hasData = n;
                },
                _applyOpSet: function(t, n) {
                    var r = this;
                    e._objectEach(t, function(t, i) {
                        n[i] = t._estimate(n[i], r, i), n[i] === e.Op._UNSET && delete n[i];
                    });
                },
                _resetCacheForKey: function(t) {
                    var r = this.attributes[t];
                    if (!(!n.isObject(r) || r instanceof e.Object || r instanceof e.File)) {
                        r = r.toJSON ? r.toJSON() : r;
                        var i = JSON.stringify(r);
                        if (this._hashedJSON[t] !== i) {
                            var s = !!this._hashedJSON[t];
                            return this._hashedJSON[t] = i, s;
                        }
                    }
                    return !1;
                },
                _rebuildEstimatedDataForKey: function(t) {
                    var n = this;
                    delete this.attributes[t], this._serverData[t] && (this.attributes[t] = this._serverData[t]), 
                    e._arrayEach(this._opSetQueue, function(r) {
                        var i = r[t];
                        i && (n.attributes[t] = i._estimate(n.attributes[t], n, t), n.attributes[t] === e.Op._UNSET ? delete n.attributes[t] : n._resetCacheForKey(t));
                    });
                },
                _rebuildAllEstimatedData: function() {
                    var t = this, r = n.clone(this.attributes);
                    this.attributes = n.clone(this._serverData), e._arrayEach(this._opSetQueue, function(n) {
                        t._applyOpSet(n, t.attributes), e._objectEach(n, function(e, n) {
                            t._resetCacheForKey(n);
                        });
                    }), e._objectEach(r, function(e, n) {
                        t.attributes[n] !== e && t.trigger("change:" + n, t, t.attributes[n], {});
                    }), e._objectEach(this.attributes, function(e, i) {
                        n.has(r, i) || t.trigger("change:" + i, t, e, {});
                    });
                },
                set: function(t, r, i) {
                    var s;
                    if (n.isObject(t) || e._isNullOrUndefined(t) ? (s = t, e._objectEach(s, function(t, n) {
                        s[n] = e._decode(n, t);
                    }), i = r) : (s = {}, s[t] = e._decode(t, r)), i = i || {}, !s) return this;
                    s instanceof e.Object && (s = s.attributes), i.unset && e._objectEach(s, function(t, n) {
                        s[n] = new e.Op.Unset();
                    });
                    var a = n.clone(s), o = this;
                    if (e._objectEach(a, function(t, n) {
                        t instanceof e.Op && (a[n] = t._estimate(o.attributes[n], o, n), a[n] === e.Op._UNSET && delete a[n]);
                    }), !this._validate(s, i)) return !1;
                    this._mergeMagicFields(s), i.changes = {};
                    var u = this._escapedAttributes;
                    return this._previousAttributes || {}, e._arrayEach(n.keys(s), function(t) {
                        var r = s[t];
                        r instanceof e.Relation && (r.parent = o), r instanceof e.Op || (r = new e.Op.Set(r));
                        var a = !0;
                        r instanceof e.Op.Set && n.isEqual(o.attributes[t], r.value) && (a = !1), a && (delete u[t], 
                        i.silent ? o._silent[t] = !0 : i.changes[t] = !0);
                        var c = n.last(o._opSetQueue);
                        c[t] = r._mergeWithPrevious(c[t]), o._rebuildEstimatedDataForKey(t), a ? (o.changed[t] = o.attributes[t], 
                        i.silent || (o._pending[t] = !0)) : (delete o.changed[t], delete o._pending[t]);
                    }), i.silent || this.change(i), this;
                },
                unset: function(e, t) {
                    return t = t || {}, t.unset = !0, this.set(e, null, t);
                },
                increment: function(t, r) {
                    return (n.isUndefined(r) || n.isNull(r)) && (r = 1), this.set(t, new e.Op.Increment(r));
                },
                add: function(t, n) {
                    return this.set(t, new e.Op.Add([ n ]));
                },
                addUnique: function(t, n) {
                    return this.set(t, new e.Op.AddUnique([ n ]));
                },
                remove: function(t, n) {
                    return this.set(t, new e.Op.Remove([ n ]));
                },
                op: function(e) {
                    return n.last(this._opSetQueue)[e];
                },
                clear: function(e) {
                    e = e || {}, e.unset = !0;
                    var t = n.extend(this.attributes, this._operations);
                    return this.set(t, e);
                },
                _getSaveJSON: function() {
                    var t = n.clone(n.first(this._opSetQueue));
                    return e._objectEach(t, function(e, n) {
                        t[n] = e.toJSON();
                    }), t;
                },
                _canBeSerialized: function() {
                    return e.Object._canBeSerializedAsValue(this.attributes);
                },
                fetch: function() {
                    var t = null, n = {};
                    1 === arguments.length ? t = arguments[0] : 2 === arguments.length && (n = arguments[0], 
                    t = arguments[1]);
                    var r = this, i = e._request("classes", this.className, this.id, "GET", n);
                    return i.then(function(e, t, n) {
                        return r._finishFetch(r.parse(e, t, n), !0), r;
                    })._thenRunCallbacks(t, this);
                },
                save: function(t, r, i) {
                    var s, a, o;
                    if (n.isObject(t) || e._isNullOrUndefined(t) ? (s = t, o = r) : (s = {}, s[t] = r, 
                    o = i), !o && s) {
                        var u = n.reject(s, function(e, t) {
                            return n.include([ "success", "error", "wait" ], t);
                        });
                        if (0 === u.length) {
                            var c = !0;
                            if (n.has(s, "success") && !n.isFunction(s.success) && (c = !1), n.has(s, "error") && !n.isFunction(s.error) && (c = !1), 
                            c) return this.save(null, s);
                        }
                    }
                    o = n.clone(o) || {}, o.wait && (a = n.clone(this.attributes));
                    var l = n.clone(o) || {};
                    l.wait && (l.silent = !0);
                    var h;
                    if (l.error = function(e, t) {
                        h = t;
                    }, s && !this.set(s, l)) return e.Promise.error(h)._thenRunCallbacks(o, this);
                    var f = this;
                    f._refreshCache();
                    var d = [], p = [];
                    return e.Object._findUnsavedChildren(f.attributes, d, p), d.length + p.length > 0 ? e.Object._deepSaveAsync(this.attributes, f).then(function() {
                        return f.save(null, o);
                    }, function(t) {
                        return e.Promise.error(t)._thenRunCallbacks(o, f);
                    }) : (this._startSave(), this._saving = (this._saving || 0) + 1, this._allPreviousSaves = this._allPreviousSaves || e.Promise.as(), 
                    this._allPreviousSaves = this._allPreviousSaves._continueWith(function() {
                        var t = f.id ? "PUT" : "POST", r = f._getSaveJSON();
                        f._fetchWhenSave && (r._fetchWhenSave = !0);
                        var i = "classes", u = f.className;
                        "_User" !== f.className || f.id || (i = "users", u = null);
                        var c = o._makeRequest || e._request, h = c(i, u, f.id, t, r);
                        return h = h.then(function(e, t, r) {
                            var i = f.parse(e, t, r);
                            return o.wait && (i = n.extend(s || {}, i)), f._finishSave(i), o.wait && f.set(a, l), 
                            f;
                        }, function(t) {
                            return f._cancelSave(), e.Promise.error(t);
                        })._thenRunCallbacks(o, f);
                    }), this._allPreviousSaves);
                },
                destroy: function(t) {
                    t = t || {};
                    var n = this, r = function() {
                        n.trigger("destroy", n, n.collection, t);
                    };
                    if (!this.id) return r();
                    t.wait || r();
                    var i = e._request("classes", this.className, this.id, "DELETE");
                    return i.then(function() {
                        return t.wait && r(), n;
                    })._thenRunCallbacks(t, this);
                },
                parse: function(t, r) {
                    var i = n.clone(t);
                    return n([ "createdAt", "updatedAt" ]).each(function(t) {
                        i[t] && (i[t] = e._parseDate(i[t]));
                    }), i.updatedAt || (i.updatedAt = i.createdAt), r && (this._existed = 201 !== r), 
                    i;
                },
                clone: function() {
                    return new this.constructor(this.attributes);
                },
                isNew: function() {
                    return !this.id;
                },
                change: function(t) {
                    t = t || {};
                    var r = this._changing;
                    this._changing = !0;
                    var i = this;
                    e._objectEach(this._silent, function(e) {
                        i._pending[e] = !0;
                    });
                    var s = n.extend({}, t.changes, this._silent);
                    if (this._silent = {}, e._objectEach(s, function(e, n) {
                        i.trigger("change:" + n, i, i.get(n), t);
                    }), r) return this;
                    for (var a = function(e, t) {
                        i._pending[t] || i._silent[t] || delete i.changed[t];
                    }; !n.isEmpty(this._pending); ) this._pending = {}, this.trigger("change", this, t), 
                    e._objectEach(this.changed, a), i._previousAttributes = n.clone(this.attributes);
                    return this._changing = !1, this;
                },
                existed: function() {
                    return this._existed;
                },
                hasChanged: function(e) {
                    return arguments.length ? this.changed && n.has(this.changed, e) : !n.isEmpty(this.changed);
                },
                changedAttributes: function(t) {
                    if (!t) return this.hasChanged() ? n.clone(this.changed) : !1;
                    var r = {}, i = this._previousAttributes;
                    return e._objectEach(t, function(e, t) {
                        n.isEqual(i[t], e) || (r[t] = e);
                    }), r;
                },
                previous: function(e) {
                    return arguments.length && this._previousAttributes ? this._previousAttributes[e] : null;
                },
                previousAttributes: function() {
                    return n.clone(this._previousAttributes);
                },
                isValid: function() {
                    return !this.validate(this.attributes);
                },
                validate: function(t) {
                    return !n.has(t, "ACL") || t.ACL instanceof e.ACL ? !1 : new e.Error(e.Error.OTHER_CAUSE, "ACL must be a AV.ACL.");
                },
                _validate: function(e, t) {
                    if (t.silent || !this.validate) return !0;
                    e = n.extend({}, this.attributes, e);
                    var r = this.validate(e, t);
                    return r ? (t && t.error ? t.error(this, r, t) : this.trigger("error", this, r, t), 
                    !1) : !0;
                },
                getACL: function() {
                    return this.get("ACL");
                },
                setACL: function(e, t) {
                    return this.set("ACL", e, t);
                }
            }), e.Object.createWithoutData = function(t, n, r) {
                var i = new e.Object(t);
                return i.id = n, i._hasData = r, i;
            }, e.Object.destroyAll = function(t, n) {
                if (null == t || 0 == t.length) return e.Promise.as()._thenRunCallbacks(n);
                var r = t[0].className, i = "", s = !0;
                t.forEach(function(e) {
                    if (e.className != r) throw "AV.Object.destroyAll requires the argument object array's classNames must be the same";
                    if (!e.id) throw "Could not delete unsaved object";
                    s ? (i = e.id, s = !1) : i = i + "," + e.id;
                });
                var a = e._request("classes", r, i, "DELETE");
                return a._thenRunCallbacks(n);
            }, e.Object._getSubclass = function(t) {
                if (!n.isString(t)) throw "AV.Object._getSubclass requires a string argument.";
                var r = e.Object._classMap[t];
                return r || (r = e.Object.extend(t), e.Object._classMap[t] = r), r;
            }, e.Object._create = function(t, n, r) {
                var i = e.Object._getSubclass(t);
                return new i(n, r);
            }, e.Object._classMap = {}, e.Object._extend = e._extend, e.Object["new"] = function(t, n) {
                return new e.Object(t, n);
            }, e.Object.extend = function(t, r, i) {
                if (!n.isString(t)) {
                    if (t && n.has(t, "className")) return e.Object.extend(t.className, t, r);
                    throw new Error("AV.Object.extend's first argument should be the className.");
                }
                "User" === t && (t = "_User");
                var s = null;
                if (n.has(e.Object._classMap, t)) {
                    var a = e.Object._classMap[t];
                    s = a._extend(r, i);
                } else r = r || {}, r.className = t, s = this._extend(r, i);
                return s.extend = function(r) {
                    if (n.isString(r) || r && n.has(r, "className")) return e.Object.extend.apply(s, arguments);
                    var i = [ t ].concat(e._.toArray(arguments));
                    return e.Object.extend.apply(s, i);
                }, s["new"] = function(e, t) {
                    return new s(e, t);
                }, e.Object._classMap[t] = s, s;
            }, e.Object._findUnsavedChildren = function(t, n, r) {
                e._traverse(t, function(t) {
                    return t instanceof e.Object ? (t._refreshCache(), void (t.dirty() && n.push(t))) : t instanceof e.File ? void (t.url() || t.id || r.push(t)) : void 0;
                });
            }, e.Object._canBeSerializedAsValue = function(t) {
                var r = !0;
                return t instanceof e.Object || t instanceof e.File ? r = !!t.id : n.isArray(t) ? e._arrayEach(t, function(t) {
                    e.Object._canBeSerializedAsValue(t) || (r = !1);
                }) : n.isObject(t) && e._objectEach(t, function(t) {
                    e.Object._canBeSerializedAsValue(t) || (r = !1);
                }), r;
            }, e.Object._deepSaveAsync = function(t, r) {
                var i = [], s = [];
                e.Object._findUnsavedChildren(t, i, s), r && (i = n.filter(i, function(e) {
                    return e != r;
                }));
                var a = e.Promise.as();
                n.each(s, function(e) {
                    a = a.then(function() {
                        return e.save();
                    });
                });
                var o = n.uniq(i), u = n.uniq(o);
                return a.then(function() {
                    return e.Promise._continueWhile(function() {
                        return u.length > 0;
                    }, function() {
                        var t = [], r = [];
                        if (e._arrayEach(u, function(e) {
                            return t.length > 20 ? void r.push(e) : void (e._canBeSerialized() ? t.push(e) : r.push(e));
                        }), u = r, 0 === t.length) return e.Promise.error(new e.Error(e.Error.OTHER_CAUSE, "Tried to save a batch with a cycle."));
                        var i = e.Promise.when(n.map(t, function(t) {
                            return t._allPreviousSaves || e.Promise.as();
                        })), s = new e.Promise();
                        return e._arrayEach(t, function(e) {
                            e._allPreviousSaves = s;
                        }), i._continueWith(function() {
                            return e._request("batch", null, null, "POST", {
                                requests: n.map(t, function(e) {
                                    var t = e._getSaveJSON(), n = "POST", r = "/1.1/classes/" + e.className;
                                    return e.id && (r = r + "/" + e.id, n = "PUT"), e._startSave(), {
                                        method: n,
                                        path: r,
                                        body: t
                                    };
                                })
                            }).then(function(n, r, i) {
                                var s;
                                return e._arrayEach(t, function(e, t) {
                                    n[t].success ? e._finishSave(e.parse(n[t].success, r, i)) : (s = s || n[t].error, 
                                    e._cancelSave());
                                }), s ? e.Promise.error(new e.Error(s.code, s.error)) : void 0;
                            }).then(function(e) {
                                return s.resolve(e), e;
                            }, function(t) {
                                return s.reject(t), e.Promise.error(t);
                            });
                        });
                    });
                }).then(function() {
                    return t;
                });
            };
        };
    }, {
        underscore: 29
    } ],
    15: [ function(e, t) {
        "use strict";
        var n = e("underscore");
        t.exports = function(e) {
            e.Op = function() {
                this._initialize.apply(this, arguments);
            }, e.Op.prototype = {
                _initialize: function() {}
            }, n.extend(e.Op, {
                _extend: e._extend,
                _opDecoderMap: {},
                _registerDecoder: function(t, n) {
                    e.Op._opDecoderMap[t] = n;
                },
                _decode: function(t) {
                    var n = e.Op._opDecoderMap[t.__op];
                    return n ? n(t) : void 0;
                }
            }), e.Op._registerDecoder("Batch", function(t) {
                var n = null;
                return e._arrayEach(t.ops, function(t) {
                    t = e.Op._decode(t), n = t._mergeWithPrevious(n);
                }), n;
            }), e.Op.Set = e.Op._extend({
                _initialize: function(e) {
                    this._value = e;
                },
                value: function() {
                    return this._value;
                },
                toJSON: function() {
                    return e._encode(this.value());
                },
                _mergeWithPrevious: function() {
                    return this;
                },
                _estimate: function() {
                    return this.value();
                }
            }), e.Op._UNSET = {}, e.Op.Unset = e.Op._extend({
                toJSON: function() {
                    return {
                        __op: "Delete"
                    };
                },
                _mergeWithPrevious: function() {
                    return this;
                },
                _estimate: function() {
                    return e.Op._UNSET;
                }
            }), e.Op._registerDecoder("Delete", function() {
                return new e.Op.Unset();
            }), e.Op.Increment = e.Op._extend({
                _initialize: function(e) {
                    this._amount = e;
                },
                amount: function() {
                    return this._amount;
                },
                toJSON: function() {
                    return {
                        __op: "Increment",
                        amount: this._amount
                    };
                },
                _mergeWithPrevious: function(t) {
                    if (t) {
                        if (t instanceof e.Op.Unset) return new e.Op.Set(this.amount());
                        if (t instanceof e.Op.Set) return new e.Op.Set(t.value() + this.amount());
                        if (t instanceof e.Op.Increment) return new e.Op.Increment(this.amount() + t.amount());
                        throw "Op is invalid after previous op.";
                    }
                    return this;
                },
                _estimate: function(e) {
                    return e ? e + this.amount() : this.amount();
                }
            }), e.Op._registerDecoder("Increment", function(t) {
                return new e.Op.Increment(t.amount);
            }), e.Op.Add = e.Op._extend({
                _initialize: function(e) {
                    this._objects = e;
                },
                objects: function() {
                    return this._objects;
                },
                toJSON: function() {
                    return {
                        __op: "Add",
                        objects: e._encode(this.objects())
                    };
                },
                _mergeWithPrevious: function(t) {
                    if (t) {
                        if (t instanceof e.Op.Unset) return new e.Op.Set(this.objects());
                        if (t instanceof e.Op.Set) return new e.Op.Set(this._estimate(t.value()));
                        if (t instanceof e.Op.Add) return new e.Op.Add(t.objects().concat(this.objects()));
                        throw "Op is invalid after previous op.";
                    }
                    return this;
                },
                _estimate: function(e) {
                    return e ? e.concat(this.objects()) : n.clone(this.objects());
                }
            }), e.Op._registerDecoder("Add", function(t) {
                return new e.Op.Add(e._decode(void 0, t.objects));
            }), e.Op.AddUnique = e.Op._extend({
                _initialize: function(e) {
                    this._objects = n.uniq(e);
                },
                objects: function() {
                    return this._objects;
                },
                toJSON: function() {
                    return {
                        __op: "AddUnique",
                        objects: e._encode(this.objects())
                    };
                },
                _mergeWithPrevious: function(t) {
                    if (t) {
                        if (t instanceof e.Op.Unset) return new e.Op.Set(this.objects());
                        if (t instanceof e.Op.Set) return new e.Op.Set(this._estimate(t.value()));
                        if (t instanceof e.Op.AddUnique) return new e.Op.AddUnique(this._estimate(t.objects()));
                        throw "Op is invalid after previous op.";
                    }
                    return this;
                },
                _estimate: function(t) {
                    if (t) {
                        var r = n.clone(t);
                        return e._arrayEach(this.objects(), function(t) {
                            if (t instanceof e.Object && t.id) {
                                var i = n.find(r, function(n) {
                                    return n instanceof e.Object && n.id === t.id;
                                });
                                if (i) {
                                    var s = n.indexOf(r, i);
                                    r[s] = t;
                                } else r.push(t);
                            } else n.contains(r, t) || r.push(t);
                        }), r;
                    }
                    return n.clone(this.objects());
                }
            }), e.Op._registerDecoder("AddUnique", function(t) {
                return new e.Op.AddUnique(e._decode(void 0, t.objects));
            }), e.Op.Remove = e.Op._extend({
                _initialize: function(e) {
                    this._objects = n.uniq(e);
                },
                objects: function() {
                    return this._objects;
                },
                toJSON: function() {
                    return {
                        __op: "Remove",
                        objects: e._encode(this.objects())
                    };
                },
                _mergeWithPrevious: function(t) {
                    if (t) {
                        if (t instanceof e.Op.Unset) return t;
                        if (t instanceof e.Op.Set) return new e.Op.Set(this._estimate(t.value()));
                        if (t instanceof e.Op.Remove) return new e.Op.Remove(n.union(t.objects(), this.objects()));
                        throw "Op is invalid after previous op.";
                    }
                    return this;
                },
                _estimate: function(t) {
                    if (t) {
                        var r = n.difference(t, this.objects());
                        return e._arrayEach(this.objects(), function(t) {
                            t instanceof e.Object && t.id && (r = n.reject(r, function(n) {
                                return n instanceof e.Object && n.id === t.id;
                            }));
                        }), r;
                    }
                    return [];
                }
            }), e.Op._registerDecoder("Remove", function(t) {
                return new e.Op.Remove(e._decode(void 0, t.objects));
            }), e.Op.Relation = e.Op._extend({
                _initialize: function(t, r) {
                    this._targetClassName = null;
                    var i = this, s = function(t) {
                        if (t instanceof e.Object) {
                            if (!t.id) throw "You can't add an unsaved AV.Object to a relation.";
                            if (i._targetClassName || (i._targetClassName = t.className), i._targetClassName !== t.className) throw "Tried to create a AV.Relation with 2 different types: " + i._targetClassName + " and " + t.className + ".";
                            return t.id;
                        }
                        return t;
                    };
                    this.relationsToAdd = n.uniq(n.map(t, s)), this.relationsToRemove = n.uniq(n.map(r, s));
                },
                added: function() {
                    var t = this;
                    return n.map(this.relationsToAdd, function(n) {
                        var r = e.Object._create(t._targetClassName);
                        return r.id = n, r;
                    });
                },
                removed: function() {
                    var t = this;
                    return n.map(this.relationsToRemove, function(n) {
                        var r = e.Object._create(t._targetClassName);
                        return r.id = n, r;
                    });
                },
                toJSON: function() {
                    var e = null, t = null, r = this, i = function(e) {
                        return {
                            __type: "Pointer",
                            className: r._targetClassName,
                            objectId: e
                        };
                    }, s = null;
                    return this.relationsToAdd.length > 0 && (s = n.map(this.relationsToAdd, i), e = {
                        __op: "AddRelation",
                        objects: s
                    }), this.relationsToRemove.length > 0 && (s = n.map(this.relationsToRemove, i), 
                    t = {
                        __op: "RemoveRelation",
                        objects: s
                    }), e && t ? {
                        __op: "Batch",
                        ops: [ e, t ]
                    } : e || t || {};
                },
                _mergeWithPrevious: function(t) {
                    if (t) {
                        if (t instanceof e.Op.Unset) throw "You can't modify a relation after deleting it.";
                        if (t instanceof e.Op.Relation) {
                            if (t._targetClassName && t._targetClassName !== this._targetClassName) throw "Related object must be of class " + t._targetClassName + ", but " + this._targetClassName + " was passed in.";
                            var r = n.union(n.difference(t.relationsToAdd, this.relationsToRemove), this.relationsToAdd), i = n.union(n.difference(t.relationsToRemove, this.relationsToAdd), this.relationsToRemove), s = new e.Op.Relation(r, i);
                            return s._targetClassName = this._targetClassName, s;
                        }
                        throw "Op is invalid after previous op.";
                    }
                    return this;
                },
                _estimate: function(t, n, r) {
                    if (t) {
                        if (t instanceof e.Relation) {
                            if (this._targetClassName) if (t.targetClassName) {
                                if (t.targetClassName !== this._targetClassName) throw "Related object must be a " + t.targetClassName + ", but a " + this._targetClassName + " was passed in.";
                            } else t.targetClassName = this._targetClassName;
                            return t;
                        }
                        throw "Op is invalid after previous op.";
                    }
                    var i = new e.Relation(n, r);
                    i.targetClassName = this._targetClassName;
                }
            }), e.Op._registerDecoder("AddRelation", function(t) {
                return new e.Op.Relation(e._decode(void 0, t.objects), []);
            }), e.Op._registerDecoder("RemoveRelation", function(t) {
                return new e.Op.Relation([], e._decode(void 0, t.objects));
            });
        };
    }, {
        underscore: 29
    } ],
    16: [ function(e, t) {
        (function(n) {
            "use strict";
            var r = e("underscore"), i = t.exports = function(e) {
                this._resolved = !1, this._rejected = !1, this._resolvedCallbacks = [], this._rejectedCallbacks = [], 
                this.doResolve(e);
            }, s = function(e) {
                return r.isNull(e) || r.isUndefined(e);
            }, a = !1;
            "undefined" != typeof n && n.versions && n.versions.node && (a = !0), r.extend(i, {
                _isPromisesAPlusCompliant: !a,
                _debugError: !1,
                setPromisesAPlusCompliant: function(e) {
                    i._isPromisesAPlusCompliant = e;
                },
                setDebugError: function(e) {
                    i._debugError = e;
                },
                is: function(e) {
                    return e && e.then && r.isFunction(e.then);
                },
                as: function() {
                    var e = new i();
                    return e.resolve.apply(e, arguments), e;
                },
                error: function() {
                    var e = new i();
                    return e.reject.apply(e, arguments), e;
                },
                when: function(e) {
                    var t;
                    t = e && s(e.length) ? arguments : e;
                    var n = r.last(arguments);
                    n = r.isBoolean(n) ? n : !1;
                    var a = t.length, o = !1, u = [], c = [];
                    if (u.length = t.length, c.length = t.length, 0 === a) return n ? i.as.call(this, u) : i.as.apply(this, u);
                    var l = new i(), h = function(e) {
                        return a -= 1, o && !l._rejected && n ? void l.reject.call(l, c[e]) : void (0 === a && (o && !l._rejected ? l.reject.call(l, c) : n ? l._rejected || l.resolve.call(l, u) : l.resolve.apply(l, u)));
                    };
                    return r.each(t, function(e, t) {
                        i.is(e) ? e.then(function(e) {
                            u[t] = e, h(t);
                        }, function(e) {
                            c[t] = e, o = !0, h(t);
                        }) : (u[t] = e, h(t));
                    }), l;
                },
                race: function(e) {
                    var t;
                    t = e && s(e.length) ? arguments : e;
                    var n = t.length, a = !1, o = [], u = [];
                    if (o.length = u.length = t.length, 0 === n) return i.as.call(this);
                    var c = new i(), l = function(e) {
                        c._resolved || c._rejected || (a ? c.reject.call(c, u[e]) : c.resolve.call(c, o[e]));
                    };
                    return r.each(t, function(e, t) {
                        i.is(e) ? e.then(function(e) {
                            o[t] = e, l(t);
                        }, function(e) {
                            u[t] = e, a = !0, l(t);
                        }) : (o[t] = e, l(t));
                    }), c;
                },
                _continueWhile: function(e, t) {
                    return e() ? t().then(function() {
                        return i._continueWhile(e, t);
                    }) : i.as();
                }
            }), i.all = function(e) {
                return i.when(e, !0);
            }, r.extend(i.prototype, {
                resolve: function() {
                    if (this._resolved || this._rejected) throw "A promise was resolved even though it had already been " + (this._resolved ? "resolved" : "rejected") + ".";
                    this._resolved = !0, this._result = arguments;
                    var e = arguments;
                    r.each(this._resolvedCallbacks, function(t) {
                        t.apply(this, e);
                    }), this._resolvedCallbacks = [], this._rejectedCallbacks = [];
                },
                doResolve: function(e) {
                    if (e) {
                        var t = !1, n = this;
                        try {
                            e(function(e) {
                                t || (t = !0, n.resolve.call(n, e));
                            }, function(e) {
                                t || (t = !0, n.reject.call(n, e));
                            });
                        } catch (r) {
                            if (t) return;
                            t = !0, n.reject.call(n, r);
                        }
                    }
                },
                reject: function(e) {
                    if (this._resolved || this._rejected) throw "A promise was rejected even though it had already been " + (this._resolved ? "resolved" : "rejected") + ".";
                    this._rejected = !0, this._error = e, r.each(this._rejectedCallbacks, function(t) {
                        t(e);
                    }), this._resolvedCallbacks = [], this._rejectedCallbacks = [];
                },
                then: function(e, t) {
                    var s = new i(), a = function() {
                        var t = arguments;
                        if (e) if (i._isPromisesAPlusCompliant) try {
                            t = [ e.apply(this, t) ];
                        } catch (n) {
                            i._debugError && n && console.error("Error occurred in promise resolve callback.", n.stack || n), 
                            t = [ i.error(n) ];
                        } else t = [ e.apply(this, t) ];
                        1 === t.length && i.is(t[0]) ? t[0].then(function() {
                            s.resolve.apply(s, arguments);
                        }, function(e) {
                            s.reject(e);
                        }) : s.resolve.apply(s, t);
                    }, o = function(e) {
                        var n = [];
                        if (t) {
                            if (i._isPromisesAPlusCompliant) try {
                                n = [ t(e) ];
                            } catch (r) {
                                i._debugError && r && console.error("Error occurred in promise reject callback.", r.stack || r), 
                                n = [ i.error(r) ];
                            } else n = [ t(e) ];
                            1 === n.length && i.is(n[0]) ? n[0].then(function() {
                                s.resolve.apply(s, arguments);
                            }, function(e) {
                                s.reject(e);
                            }) : i._isPromisesAPlusCompliant ? s.resolve.apply(s, n) : s.reject(n[0]);
                        } else s.reject(e);
                    }, u = function(e) {
                        e.call();
                    };
                    i._isPromisesAPlusCompliant && ("undefined" != typeof window && r.isFunction(window.setImmediate) ? u = function(e) {
                        window.setImmediate(e);
                    } : "undefined" != typeof n && n.nextTick ? u = function(e) {
                        n.nextTick(e);
                    } : "undefined" != typeof setTimeout && r.isFunction(setTimeout) && (u = function(e) {
                        setTimeout(e, 0);
                    }));
                    var c = this;
                    return this._resolved ? u(function() {
                        a.apply(c, c._result);
                    }) : this._rejected ? u(function() {
                        o.apply(c, [ c._error ]);
                    }) : (this._resolvedCallbacks.push(a), this._rejectedCallbacks.push(o)), s;
                },
                "catch": function(e) {
                    return this.then(void 0, e);
                },
                always: function(e) {
                    return this.then(e, e);
                },
                done: function(e) {
                    return this.then(e);
                },
                fail: function(e) {
                    return this.then(null, e);
                },
                _thenRunCallbacks: function(e, t) {
                    var n;
                    if (r.isFunction(e)) {
                        var s = e;
                        n = {
                            success: function(e) {
                                s(e, null);
                            },
                            error: function(e) {
                                s(null, e);
                            }
                        };
                    } else n = r.clone(e);
                    return n = n || {}, this.then(function(e) {
                        return n.success ? n.success.apply(this, arguments) : t && t.trigger("sync", t, e, n), 
                        i.as.apply(i, arguments);
                    }, function(e) {
                        return n.error ? r.isUndefined(t) ? n.error(e) : n.error(t, e) : t && t.trigger("error", t, e, n), 
                        i.error(e);
                    });
                },
                _continueWith: function(e) {
                    return this.then(function() {
                        return e(arguments, null);
                    }, function(t) {
                        return e(null, t);
                    });
                }
            }), i.prototype["finally"] = i.prototype.always, i.prototype["try"] = i.prototype.done;
        }).call(this, e("_process"));
    }, {
        _process: 27,
        underscore: 29
    } ],
    17: [ function(e, t) {
        "use strict";
        t.exports = function(e) {
            e.Installation = e.Object.extend("_Installation"), e.Push = e.Push || {}, e.Push.send = function(t, n) {
                if (t.where && (t.where = t.where.toJSON().where), t.where && t.cql) throw "Both where and cql can't be set";
                if (t.push_time && (t.push_time = t.push_time.toJSON()), t.expiration_time && (t.expiration_time = t.expiration_time.toJSON()), 
                t.expiration_time && t.expiration_time_interval) throw "Both expiration_time and expiration_time_interval can't be set";
                var r = e._request("push", null, null, "POST", t);
                return r._thenRunCallbacks(n);
            };
        };
    }, {} ],
    18: [ function(e, t) {
        "use strict";
        var n = e("underscore");
        t.exports = function(e) {
            e.Query = function(t) {
                n.isString(t) && (t = e.Object._getSubclass(t)), this.objectClass = t, this.className = t.prototype.className, 
                this._where = {}, this._include = [], this._limit = -1, this._skip = 0, this._extraOptions = {};
            }, e.Query.or = function() {
                var t = n.toArray(arguments), r = null;
                e._arrayEach(t, function(e) {
                    if (n.isNull(r) && (r = e.className), r !== e.className) throw "All queries must be for the same class";
                });
                var i = new e.Query(r);
                return i._orQuery(t), i;
            }, e.Query.and = function() {
                var t = n.toArray(arguments), r = null;
                e._arrayEach(t, function(e) {
                    if (n.isNull(r) && (r = e.className), r !== e.className) throw "All queries must be for the same class";
                });
                var i = new e.Query(r);
                return i._andQuery(t), i;
            }, e.Query.doCloudQuery = function(t, r, i) {
                var s = {
                    cql: t
                };
                n.isArray(r) ? s.pvalues = r : i = r;
                var a = e._request("cloudQuery", null, null, "GET", s);
                return a.then(function(t) {
                    var r = new e.Query(t.className), i = n.map(t.results, function(e) {
                        var n = r._newObject(t);
                        return n._finishFetch(r._processResult(e), !0), n;
                    });
                    return {
                        results: i,
                        count: t.count,
                        className: t.className
                    };
                })._thenRunCallbacks(i);
            }, e.Query._extend = e._extend, e.Query.prototype = {
                _processResult: function(e) {
                    return e;
                },
                get: function(t, n) {
                    if (!t) {
                        var r = new e.Error(e.Error.OBJECT_NOT_FOUND, "Object not found.");
                        return e.Promise.error(r);
                    }
                    var i = this;
                    return i.equalTo("objectId", t), i.first().then(function(t) {
                        if (!e._.isEmpty(t)) return t;
                        var n = new e.Error(e.Error.OBJECT_NOT_FOUND, "Object not found.");
                        return e.Promise.error(n);
                    })._thenRunCallbacks(n, null);
                },
                toJSON: function() {
                    var t = {
                        where: this._where
                    };
                    return this._include.length > 0 && (t.include = this._include.join(",")), this._select && (t.keys = this._select.join(",")), 
                    this._limit >= 0 && (t.limit = this._limit), this._skip > 0 && (t.skip = this._skip), 
                    void 0 !== this._order && (t.order = this._order), e._objectEach(this._extraOptions, function(e, n) {
                        t[n] = e;
                    }), t;
                },
                _newObject: function(t) {
                    var n;
                    return n = t && t.className ? new e.Object(t.className) : new this.objectClass();
                },
                _createRequest: function(t) {
                    return e._request("classes", this.className, null, "GET", t || this.toJSON());
                },
                find: function(e) {
                    var t = this, r = this._createRequest();
                    return r.then(function(e) {
                        return n.map(e.results, function(n) {
                            var r = t._newObject(e);
                            return r._finishFetch(t._processResult(n), !0), r;
                        });
                    })._thenRunCallbacks(e);
                },
                destroyAll: function(t) {
                    var n = this;
                    return n.find().then(function(t) {
                        return e.Object.destroyAll(t);
                    })._thenRunCallbacks(t);
                },
                count: function(e) {
                    var t = this.toJSON();
                    t.limit = 0, t.count = 1;
                    var n = this._createRequest(t);
                    return n.then(function(e) {
                        return e.count;
                    })._thenRunCallbacks(e);
                },
                first: function(e) {
                    var t = this, r = this.toJSON();
                    r.limit = 1;
                    var i = this._createRequest(r);
                    return i.then(function(e) {
                        return n.map(e.results, function(e) {
                            var n = t._newObject();
                            return n._finishFetch(t._processResult(e), !0), n;
                        })[0];
                    })._thenRunCallbacks(e);
                },
                collection: function(t, r) {
                    return r = r || {}, new e.Collection(t, n.extend(r, {
                        model: this._objectClass || this.objectClass,
                        query: this
                    }));
                },
                skip: function(e) {
                    return this._skip = e, this;
                },
                limit: function(e) {
                    return this._limit = e, this;
                },
                equalTo: function(t, n) {
                    return this._where[t] = e._encode(n), this;
                },
                _addCondition: function(t, n, r) {
                    return this._where[t] || (this._where[t] = {}), this._where[t][n] = e._encode(r), 
                    this;
                },
                sizeEqualTo: function(e, t) {
                    this._addCondition(e, "$size", t);
                },
                notEqualTo: function(e, t) {
                    return this._addCondition(e, "$ne", t), this;
                },
                lessThan: function(e, t) {
                    return this._addCondition(e, "$lt", t), this;
                },
                greaterThan: function(e, t) {
                    return this._addCondition(e, "$gt", t), this;
                },
                lessThanOrEqualTo: function(e, t) {
                    return this._addCondition(e, "$lte", t), this;
                },
                greaterThanOrEqualTo: function(e, t) {
                    return this._addCondition(e, "$gte", t), this;
                },
                containedIn: function(e, t) {
                    return this._addCondition(e, "$in", t), this;
                },
                notContainedIn: function(e, t) {
                    return this._addCondition(e, "$nin", t), this;
                },
                containsAll: function(e, t) {
                    return this._addCondition(e, "$all", t), this;
                },
                exists: function(e) {
                    return this._addCondition(e, "$exists", !0), this;
                },
                doesNotExist: function(e) {
                    return this._addCondition(e, "$exists", !1), this;
                },
                matches: function(e, t, n) {
                    return this._addCondition(e, "$regex", t), n || (n = ""), t.ignoreCase && (n += "i"), 
                    t.multiline && (n += "m"), n && n.length && this._addCondition(e, "$options", n), 
                    this;
                },
                matchesQuery: function(e, t) {
                    var n = t.toJSON();
                    return n.className = t.className, this._addCondition(e, "$inQuery", n), this;
                },
                doesNotMatchQuery: function(e, t) {
                    var n = t.toJSON();
                    return n.className = t.className, this._addCondition(e, "$notInQuery", n), this;
                },
                matchesKeyInQuery: function(e, t, n) {
                    var r = n.toJSON();
                    return r.className = n.className, this._addCondition(e, "$select", {
                        key: t,
                        query: r
                    }), this;
                },
                doesNotMatchKeyInQuery: function(e, t, n) {
                    var r = n.toJSON();
                    return r.className = n.className, this._addCondition(e, "$dontSelect", {
                        key: t,
                        query: r
                    }), this;
                },
                _orQuery: function(e) {
                    var t = n.map(e, function(e) {
                        return e.toJSON().where;
                    });
                    return this._where.$or = t, this;
                },
                _andQuery: function(e) {
                    var t = n.map(e, function(e) {
                        return e.toJSON().where;
                    });
                    return this._where.$and = t, this;
                },
                _quote: function(e) {
                    return "\\Q" + e.replace("\\E", "\\E\\\\E\\Q") + "\\E";
                },
                contains: function(e, t) {
                    return this._addCondition(e, "$regex", this._quote(t)), this;
                },
                startsWith: function(e, t) {
                    return this._addCondition(e, "$regex", "^" + this._quote(t)), this;
                },
                endsWith: function(e, t) {
                    return this._addCondition(e, "$regex", this._quote(t) + "$"), this;
                },
                ascending: function(e) {
                    return this._order = e, this;
                },
                addAscending: function(e) {
                    return this._order ? this._order += "," + e : this._order = e, this;
                },
                descending: function(e) {
                    return this._order = "-" + e, this;
                },
                addDescending: function(e) {
                    return this._order ? this._order += ",-" + e : this._order = "-" + e, e;
                },
                near: function(t, n) {
                    return n instanceof e.GeoPoint || (n = new e.GeoPoint(n)), this._addCondition(t, "$nearSphere", n), 
                    this;
                },
                withinRadians: function(e, t, n) {
                    return this.near(e, t), this._addCondition(e, "$maxDistance", n), this;
                },
                withinMiles: function(e, t, n) {
                    return this.withinRadians(e, t, n / 3958.8);
                },
                withinKilometers: function(e, t, n) {
                    return this.withinRadians(e, t, n / 6371);
                },
                withinGeoBox: function(t, n, r) {
                    return n instanceof e.GeoPoint || (n = new e.GeoPoint(n)), r instanceof e.GeoPoint || (r = new e.GeoPoint(r)), 
                    this._addCondition(t, "$within", {
                        $box: [ n, r ]
                    }), this;
                },
                include: function() {
                    var t = this;
                    return e._arrayEach(arguments, function(e) {
                        n.isArray(e) ? t._include = t._include.concat(e) : t._include.push(e);
                    }), this;
                },
                select: function() {
                    var t = this;
                    return this._select = this._select || [], e._arrayEach(arguments, function(e) {
                        n.isArray(e) ? t._select = t._select.concat(e) : t._select.push(e);
                    }), this;
                },
                each: function(t, r) {
                    if (r = r || {}, this._order || this._skip || this._limit >= 0) {
                        var i = "Cannot iterate on a query with sort, skip, or limit.";
                        return e.Promise.error(i)._thenRunCallbacks(r);
                    }
                    var s = (new e.Promise(), new e.Query(this.objectClass));
                    s._limit = r.batchSize || 100, s._where = n.clone(this._where), s._include = n.clone(this._include), 
                    s.ascending("objectId");
                    var a = !1;
                    return e.Promise._continueWhile(function() {
                        return !a;
                    }, function() {
                        return s.find().then(function(n) {
                            var r = e.Promise.as();
                            return e._.each(n, function(e) {
                                r = r.then(function() {
                                    return t(e);
                                });
                            }), r.then(function() {
                                n.length >= s._limit ? s.greaterThan("objectId", n[n.length - 1].id) : a = !0;
                            });
                        });
                    })._thenRunCallbacks(r);
                }
            }, e.FriendShipQuery = e.Query._extend({
                _objectClass: e.User,
                _newObject: function() {
                    return new e.User();
                },
                _processResult: function(e) {
                    if (e && e[this._friendshipTag]) {
                        var t = e[this._friendshipTag];
                        return "Pointer" === t.__type && "_User" === t.className && (delete t.__type, delete t.className), 
                        t;
                    }
                    return null;
                }
            });
        };
    }, {
        underscore: 29
    } ],
    19: [ function(e, t) {
        "use strict";
        var n = e("underscore");
        t.exports = function(e) {
            e.Relation = function(e, t) {
                if (!n.isString(t)) throw new TypeError("key must be a string");
                this.parent = e, this.key = t, this.targetClassName = null;
            }, e.Relation.reverseQuery = function(t, n, r) {
                var i = new e.Query(t);
                return i.equalTo(n, r._toPointer()), i;
            }, e.Relation.prototype = {
                _ensureParentAndKey: function(e, t) {
                    if (this.parent = this.parent || e, this.key = this.key || t, this.parent !== e) throw "Internal Error. Relation retrieved from two different Objects.";
                    if (this.key !== t) throw "Internal Error. Relation retrieved from two different keys.";
                },
                add: function(t) {
                    n.isArray(t) || (t = [ t ]);
                    var r = new e.Op.Relation(t, []);
                    this.parent.set(this.key, r), this.targetClassName = r._targetClassName;
                },
                remove: function(t) {
                    n.isArray(t) || (t = [ t ]);
                    var r = new e.Op.Relation([], t);
                    this.parent.set(this.key, r), this.targetClassName = r._targetClassName;
                },
                toJSON: function() {
                    return {
                        __type: "Relation",
                        className: this.targetClassName
                    };
                },
                query: function() {
                    var t, n;
                    return this.targetClassName ? (t = e.Object._getSubclass(this.targetClassName), 
                    n = new e.Query(t)) : (t = e.Object._getSubclass(this.parent.className), n = new e.Query(t), 
                    n._extraOptions.redirectClassNameForKey = this.key), n._addCondition("$relatedTo", "object", this.parent._toPointer()), 
                    n._addCondition("$relatedTo", "key", this.key), n;
                }
            };
        };
    }, {
        underscore: 29
    } ],
    20: [ function(e, t) {
        "use strict";
        var n = e("underscore");
        t.exports = function(e) {
            e.Role = e.Object.extend("_Role", {
                constructor: function(t, r) {
                    if (n.isString(t) ? (e.Object.prototype.constructor.call(this, null, null), this.setName(t)) : e.Object.prototype.constructor.call(this, t, r), 
                    void 0 === r) {
                        var i = new e.ACL();
                        i.setPublicReadAccess(!0), this.getACL() || this.setACL(i);
                    } else {
                        if (!(r instanceof e.ACL)) throw new TypeError("acl must be an instance of AV.ACL");
                        this.setACL(r);
                    }
                },
                getName: function() {
                    return this.get("name");
                },
                setName: function(e, t) {
                    return this.set("name", e, t);
                },
                getUsers: function() {
                    return this.relation("users");
                },
                getRoles: function() {
                    return this.relation("roles");
                },
                validate: function(t, r) {
                    if ("name" in t && t.name !== this.getName()) {
                        var i = t.name;
                        if (this.id && this.id !== t.objectId) return new e.Error(e.Error.OTHER_CAUSE, "A role's name can only be set before it has been saved.");
                        if (!n.isString(i)) return new e.Error(e.Error.OTHER_CAUSE, "A role's name must be a String.");
                        if (!/^[0-9a-zA-Z\-_ ]+$/.test(i)) return new e.Error(e.Error.OTHER_CAUSE, "A role's name can only contain alphanumeric characters, _, -, and spaces.");
                    }
                    return e.Object.prototype.validate ? e.Object.prototype.validate.call(this, t, r) : !1;
                }
            });
        };
    }, {
        underscore: 29
    } ],
    21: [ function(e, t) {
        "use strict";
        var n = e("underscore");
        t.exports = function(e) {
            e.SearchSortBuilder = function() {
                this._sortFields = [];
            }, e.SearchSortBuilder.prototype = {
                _addField: function(e, t, n, r) {
                    var i = {};
                    return i[e] = {
                        order: t || "asc",
                        mode: n || "avg",
                        missing: "_" + (r || "last")
                    }, this._sortFields.push(i), this;
                },
                ascending: function(e, t, n) {
                    return this._addField(e, "asc", t, n);
                },
                descending: function(e, t, n) {
                    return this._addField(e, "desc", t, n);
                },
                whereNear: function(e, t, n) {
                    n = n || {};
                    var r = {}, i = {
                        lat: t.latitude,
                        lon: t.longitude
                    }, s = {
                        order: n.order || "asc",
                        mode: n.mode || "avg",
                        unit: n.unit || "km"
                    };
                    return s[e] = i, r._geo_distance = s, this._sortFields.push(r), this;
                },
                build: function() {
                    return JSON.stringify(e._encode(this._sortFields));
                }
            }, e.SearchQuery = e.Query._extend({
                _sid: null,
                _hits: 0,
                _queryString: null,
                _highlights: null,
                _sortBuilder: null,
                _createRequest: function(t) {
                    return e._request("search/select", null, null, "GET", t || this.toJSON());
                },
                sid: function(e) {
                    return this._sid = e, this;
                },
                queryString: function(e) {
                    return this._queryString = e, this;
                },
                highlights: function(e) {
                    var t;
                    return t = e && n.isString(e) ? arguments : e, this._highlights = t, this;
                },
                sortBy: function(e) {
                    return this._sortBuilder = e, this;
                },
                hits: function() {
                    return this._hits || (this._hits = 0), this._hits;
                },
                _processResult: function(e) {
                    return delete e.className, delete e._app_url, delete e._deeplink, e;
                },
                hasMore: function() {
                    return !this._hitEnd;
                },
                reset: function() {
                    this._hitEnd = !1, this._sid = null, this._hits = 0;
                },
                find: function(e) {
                    var t = this, r = this._createRequest();
                    return r.then(function(e) {
                        return e.sid ? (t._oldSid = t._sid, t._sid = e.sid) : (t._sid = null, t._hitEnd = !0), 
                        t._hits = e.hits || 0, n.map(e.results, function(n) {
                            n.className && (e.className = n.className);
                            var r = t._newObject(e);
                            return r.appURL = n._app_url, r._finishFetch(t._processResult(n), !0), r;
                        });
                    })._thenRunCallbacks(e);
                },
                toJSON: function() {
                    var t = e.SearchQuery.__super__.toJSON.call(this);
                    if (delete t.where, this.className && (t.clazz = this.className), this._sid && (t.sid = this._sid), 
                    !this._queryString) throw "Please set query string.";
                    if (t.q = this._queryString, this._highlights && (t.highlights = this._highlights.join(",")), 
                    this._sortBuilder && t.order) throw "sort and order can not be set at same time.";
                    return this._sortBuilder && (t.sort = this._sortBuilder.build()), t;
                }
            });
        };
    }, {
        underscore: 29
    } ],
    22: [ function(e, t) {
        "use strict";
        var n = e("underscore");
        t.exports = function(e) {
            e.Status = function(e, t) {
                return this.data = {}, this.inboxType = "default", this.query = null, e && "object" == typeof e ? this.data = e : (e && (this.data.image = e), 
                t && (this.data.message = t)), this;
            }, e.Status.prototype = {
                get: function(e) {
                    return this.data[e];
                },
                set: function(e, t) {
                    return this.data[e] = t, this;
                },
                destroy: function(t) {
                    if (!this.id) return e.Promise.error("The status id is not exists.")._thenRunCallbacks(t);
                    var n = e._request("statuses", null, this.id, "DELETE");
                    return n._thenRunCallbacks(t);
                },
                toObject: function() {
                    return this.id ? e.Object.createWithoutData("_Status", this.id) : null;
                },
                _getDataJSON: function() {
                    var t = e._.clone(this.data);
                    return e._encode(t);
                },
                send: function(t) {
                    if (!e.User.current()) throw "Please signin an user.";
                    if (!this.query) return e.Status.sendStatusToFollowers(this, t);
                    var n = this.query.toJSON();
                    n.className = this.query.className;
                    var r = {};
                    r.query = n, this.data = this.data || {};
                    var i = e.Object.createWithoutData("_User", e.User.current().id)._toPointer();
                    this.data.source = this.data.source || i, r.data = this._getDataJSON(), r.inboxType = this.inboxType || "default";
                    var s = e._request("statuses", null, null, "POST", r), a = this;
                    return s.then(function(t) {
                        return a.id = t.objectId, a.createdAt = e._parseDate(t.createdAt), a;
                    })._thenRunCallbacks(t);
                },
                _finishFetch: function(t) {
                    this.id = t.objectId, this.createdAt = e._parseDate(t.createdAt), this.updatedAt = e._parseDate(t.updatedAt), 
                    this.messageId = t.messageId, delete t.messageId, delete t.objectId, delete t.createdAt, 
                    delete t.updatedAt, this.data = e._decode(void 0, t);
                }
            }, e.Status.sendStatusToFollowers = function(t, n) {
                if (!e.User.current()) throw "Please signin an user.";
                var r = {};
                r.className = "_Follower", r.keys = "follower";
                var i = e.Object.createWithoutData("_User", e.User.current().id)._toPointer();
                r.where = {
                    user: i
                };
                var s = {};
                s.query = r, t.data = t.data || {}, t.data.source = t.data.source || i, s.data = t._getDataJSON(), 
                s.inboxType = t.inboxType || "default";
                var a = e._request("statuses", null, null, "POST", s);
                return a.then(function(n) {
                    return t.id = n.objectId, t.createdAt = e._parseDate(n.createdAt), t;
                })._thenRunCallbacks(n);
            }, e.Status.sendPrivateStatus = function(t, r, i) {
                if (!e.User.current()) throw "Please signin an user.";
                if (!r) throw "Invalid target user.";
                var s = n.isString(r) ? r : r.id;
                if (!s) throw "Invalid target user.";
                var a = {};
                a.className = "_User";
                var o = e.Object.createWithoutData("_User", e.User.current().id)._toPointer();
                a.where = {
                    objectId: s
                };
                var u = {};
                u.query = a, t.data = t.data || {}, t.data.source = t.data.source || o, u.data = t._getDataJSON(), 
                u.inboxType = "private", t.inboxType = "private";
                var c = e._request("statuses", null, null, "POST", u);
                return c.then(function(n) {
                    return t.id = n.objectId, t.createdAt = e._parseDate(n.createdAt), t;
                })._thenRunCallbacks(i);
            }, e.Status.countUnreadStatuses = function(t) {
                if (!e.User.current() && null == t) throw "Please signin an user or pass the owner objectId.";
                t = t || e.User.current();
                var r = n.isString(arguments[1]) ? arguments[2] : arguments[1], i = n.isString(arguments[1]) ? arguments[1] : "default", s = {};
                s.inboxType = e._encode(i), s.owner = e._encode(t);
                var a = e._request("subscribe/statuses/count", null, null, "GET", s);
                return a._thenRunCallbacks(r);
            }, e.Status.statusQuery = function(t) {
                var n = new e.Query("_Status");
                return t && n.equalTo("source", t), n;
            }, e.InboxQuery = e.Query._extend({
                _objectClass: e.Status,
                _sinceId: 0,
                _maxId: 0,
                _inboxType: "default",
                _owner: null,
                _newObject: function() {
                    return new e.Status();
                },
                _createRequest: function(t) {
                    return e._request("subscribe/statuses", null, null, "GET", t || this.toJSON());
                },
                sinceId: function(e) {
                    return this._sinceId = e, this;
                },
                maxId: function(e) {
                    return this._maxId = e, this;
                },
                owner: function(e) {
                    return this._owner = e, this;
                },
                inboxType: function(e) {
                    return this._inboxType = e, this;
                },
                toJSON: function() {
                    var t = e.InboxQuery.__super__.toJSON.call(this);
                    return t.owner = e._encode(this._owner), t.inboxType = e._encode(this._inboxType), 
                    t.sinceId = e._encode(this._sinceId), t.maxId = e._encode(this._maxId), t;
                }
            }), e.Status.inboxQuery = function(t, n) {
                var r = new e.InboxQuery(e.Status);
                return t && (r._owner = t), n && (r._inboxType = n), r;
            };
        };
    }, {
        underscore: 29
    } ],
    23: [ function(e, t) {
        "use strict";
        var n = e("underscore");
        t.exports = function(e) {
            e.User = e.Object.extend("_User", {
                _isCurrentUser: !1,
                _mergeMagicFields: function(t) {
                    t.sessionToken && (this._sessionToken = t.sessionToken, delete t.sessionToken), 
                    e.User.__super__._mergeMagicFields.call(this, t);
                },
                _cleanupAuthData: function() {
                    if (this.isCurrent()) {
                        var t = this.get("authData");
                        t && e._objectEach(this.get("authData"), function(e, n) {
                            t[n] || delete t[n];
                        });
                    }
                },
                _synchronizeAllAuthData: function() {
                    var t = this.get("authData");
                    if (t) {
                        var n = this;
                        e._objectEach(this.get("authData"), function(e, t) {
                            n._synchronizeAuthData(t);
                        });
                    }
                },
                _synchronizeAuthData: function(t) {
                    if (this.isCurrent()) {
                        var r;
                        n.isString(t) ? (r = t, t = e.User._authProviders[r]) : r = t.getAuthType();
                        var i = this.get("authData");
                        if (i && t) {
                            var s = t.restoreAuthentication(i[r]);
                            s || this._unlinkFrom(t);
                        }
                    }
                },
                _handleSaveResult: function(t) {
                    t && (this._isCurrentUser = !0), this._cleanupAuthData(), this._synchronizeAllAuthData(), 
                    delete this._serverData.password, this._rebuildEstimatedDataForKey("password"), 
                    this._refreshCache(), (t || this.isCurrent()) && e.User._saveCurrentUser(this);
                },
                _linkWith: function(t, r) {
                    var i;
                    if (n.isString(t) ? (i = t, t = e.User._authProviders[t]) : i = t.getAuthType(), 
                    n.has(r, "authData")) {
                        var s = this.get("authData") || {};
                        s[i] = r.authData, this.set("authData", s);
                        var a = n.clone(r) || {};
                        return a.success = function(e) {
                            e._handleSaveResult(!0), r.success && r.success.apply(this, arguments);
                        }, this.save({
                            authData: s
                        }, a);
                    }
                    var o = this, u = new e.Promise();
                    return t.authenticate({
                        success: function(e, t) {
                            o._linkWith(e, {
                                authData: t,
                                success: r.success,
                                error: r.error
                            }).then(function() {
                                u.resolve(o);
                            });
                        },
                        error: function(e, t) {
                            r.error && r.error(o, t), u.reject(t);
                        }
                    }), u;
                },
                _unlinkFrom: function(t, r) {
                    var i;
                    n.isString(t) ? (i = t, t = e.User._authProviders[t]) : i = t.getAuthType();
                    var s = n.clone(r), a = this;
                    return s.authData = null, s.success = function() {
                        a._synchronizeAuthData(t), r.success && r.success.apply(this, arguments);
                    }, this._linkWith(t, s);
                },
                _isLinked: function(e) {
                    var t;
                    t = n.isString(e) ? e : e.getAuthType();
                    var r = this.get("authData") || {};
                    return !!r[t];
                },
                _logOutWithAll: function() {
                    var t = this.get("authData");
                    if (t) {
                        var n = this;
                        e._objectEach(this.get("authData"), function(e, t) {
                            n._logOutWith(t);
                        });
                    }
                },
                _logOutWith: function(t) {
                    this.isCurrent() && (n.isString(t) && (t = e.User._authProviders[t]), t && t.deauthenticate && t.deauthenticate());
                },
                signUp: function(t, r) {
                    var i;
                    r = r || {};
                    var s = t && t.username || this.get("username");
                    if (!s || "" === s) return i = new e.Error(e.Error.OTHER_CAUSE, "Cannot sign up user with an empty name."), 
                    r && r.error && r.error(this, i), e.Promise.error(i);
                    var a = t && t.password || this.get("password");
                    if (!a || "" === a) return i = new e.Error(e.Error.OTHER_CAUSE, "Cannot sign up user with an empty password."), 
                    r && r.error && r.error(this, i), e.Promise.error(i);
                    var o = n.clone(r);
                    return o.success = function(e) {
                        e._handleSaveResult(!0), r.success && r.success.apply(this, arguments);
                    }, this.save(t, o);
                },
                signUpOrlogInWithMobilePhone: function(t, r) {
                    var i;
                    r = r || {};
                    var s = t && t.mobilePhoneNumber || this.get("mobilePhoneNumber");
                    if (!s || "" === s) return i = new e.Error(e.Error.OTHER_CAUSE, "Cannot sign up or login user by mobilePhoneNumber with an empty mobilePhoneNumber."), 
                    r && r.error && r.error(this, i), e.Promise.error(i);
                    var a = t && t.smsCode || this.get("smsCode");
                    if (!a || "" === a) return i = new e.Error(e.Error.OTHER_CAUSE, "Cannot sign up or login user by mobilePhoneNumber  with an empty smsCode."), 
                    r && r.error && r.error(this, i), e.Promise.error(i);
                    var o = n.clone(r);
                    return o._makeRequest = function(t, n, r, i, s) {
                        return e._request("usersByMobilePhone", null, null, "POST", s);
                    }, o.success = function(e) {
                        e._handleSaveResult(!0), delete e.attributes.smsCode, delete e._serverData.smsCode, 
                        r.success && r.success.apply(this, arguments);
                    }, this.save(t, o);
                },
                logIn: function(t) {
                    var n = this, r = e._request("login", null, null, "GET", this.toJSON());
                    return r.then(function(e, t, r) {
                        var i = n.parse(e, t, r);
                        return n._finishFetch(i), n._handleSaveResult(!0), i.smsCode || delete n.attributes.smsCode, 
                        n;
                    })._thenRunCallbacks(t, this);
                },
                save: function(t, r, i) {
                    var s, a;
                    n.isObject(t) || n.isNull(t) || n.isUndefined(t) ? (s = t, a = r) : (s = {}, s[t] = r, 
                    a = i), a = a || {};
                    var o = n.clone(a);
                    return o.success = function(e) {
                        e._handleSaveResult(!1), a.success && a.success.apply(this, arguments);
                    }, e.Object.prototype.save.call(this, s, o);
                },
                follow: function(t, r) {
                    if (!this.id) throw "Please signin.";
                    if (!t) throw "Invalid target user.";
                    var i = n.isString(t) ? t : t.id;
                    if (!i) throw "Invalid target user.";
                    var s = "users/" + this.id + "/friendship/" + i, a = e._request(s, null, null, "POST", null);
                    return a._thenRunCallbacks(r);
                },
                unfollow: function(t, r) {
                    if (!this.id) throw "Please signin.";
                    if (!t) throw "Invalid target user.";
                    var i = n.isString(t) ? t : t.id;
                    if (!i) throw "Invalid target user.";
                    var s = "users/" + this.id + "/friendship/" + i, a = e._request(s, null, null, "DELETE", null);
                    return a._thenRunCallbacks(r);
                },
                followerQuery: function() {
                    return e.User.followerQuery(this.id);
                },
                followeeQuery: function() {
                    return e.User.followeeQuery(this.id);
                },
                fetch: function(t) {
                    var r = t ? n.clone(t) : {};
                    return r.success = function(e) {
                        e._handleSaveResult(!1), t && t.success && t.success.apply(this, arguments);
                    }, e.Object.prototype.fetch.call(this, r);
                },
                updatePassword: function(t, n, r) {
                    var i = "users/" + this.id + "/updatePassword", s = {
                        old_password: t,
                        new_password: n
                    }, a = e._request(i, null, null, "PUT", s);
                    return a._thenRunCallbacks(r, this);
                },
                isCurrent: function() {
                    return this._isCurrentUser;
                },
                getUsername: function() {
                    return this.get("username");
                },
                getMobilePhoneNumber: function() {
                    return this.get("mobilePhoneNumber");
                },
                setMobilePhoneNumber: function(e, t) {
                    return this.set("mobilePhoneNumber", e, t);
                },
                setUsername: function(e, t) {
                    return this.set("username", e, t);
                },
                setPassword: function(e, t) {
                    return this.set("password", e, t);
                },
                getEmail: function() {
                    return this.get("email");
                },
                setEmail: function(e, t) {
                    return this.set("email", e, t);
                },
                authenticated: function() {
                    return !!this._sessionToken && e.User.current() && e.User.current().id === this.id;
                }
            }, {
                _currentUser: null,
                _currentUserMatchesDisk: !1,
                _CURRENT_USER_KEY: "currentUser",
                _authProviders: {},
                signUp: function(t, n, r, i) {
                    r = r || {}, r.username = t, r.password = n;
                    var s = e.Object._create("_User");
                    return s.signUp(r, i);
                },
                logIn: function(t, n, r) {
                    var i = e.Object._create("_User");
                    return i._finishFetch({
                        username: t,
                        password: n
                    }), i.logIn(r);
                },
                become: function(t, n) {
                    n = n || {};
                    var r = e.Object._create("_User");
                    return e._request("users", "me", null, "GET", {
                        useMasterKey: n.useMasterKey,
                        session_token: t
                    }).then(function(e, t, n) {
                        var i = r.parse(e, t, n);
                        return r._finishFetch(i), r._handleSaveResult(!0), r;
                    })._thenRunCallbacks(n, r);
                },
                logInWithMobilePhoneSmsCode: function(t, n, r) {
                    var i = e.Object._create("_User");
                    return i._finishFetch({
                        mobilePhoneNumber: t,
                        smsCode: n
                    }), i.logIn(r);
                },
                signUpOrlogInWithMobilePhone: function(t, n, r, i) {
                    r = r || {}, r.mobilePhoneNumber = t, r.smsCode = n;
                    var s = e.Object._create("_User");
                    return s.signUpOrlogInWithMobilePhone(r, i);
                },
                logInWithMobilePhone: function(t, n, r) {
                    var i = e.Object._create("_User");
                    return i._finishFetch({
                        mobilePhoneNumber: t,
                        password: n
                    }), i.logIn(r);
                },
                logOut: function() {
                    null !== e.User._currentUser && (e.User._currentUser._logOutWithAll(), e.User._currentUser._isCurrentUser = !1), 
                    e.User._currentUserMatchesDisk = !0, e.User._currentUser = null, e.localStorage.removeItem(e._getAVPath(e.User._CURRENT_USER_KEY));
                },
                followerQuery: function(t) {
                    if (!t || !n.isString(t)) throw "Invalid user object id.";
                    var r = new e.FriendShipQuery("_Follower");
                    return r._friendshipTag = "follower", r.equalTo("user", e.Object.createWithoutData("_User", t)), 
                    r;
                },
                followeeQuery: function(t) {
                    if (!t || !n.isString(t)) throw "Invalid user object id.";
                    var r = new e.FriendShipQuery("_Followee");
                    return r._friendshipTag = "followee", r.equalTo("user", e.Object.createWithoutData("_User", t)), 
                    r;
                },
                requestPasswordReset: function(t, n) {
                    var r = {
                        email: t
                    }, i = e._request("requestPasswordReset", null, null, "POST", r);
                    return i._thenRunCallbacks(n);
                },
                requestEmailVerify: function(t, n) {
                    var r = {
                        email: t
                    }, i = e._request("requestEmailVerify", null, null, "POST", r);
                    return i._thenRunCallbacks(n);
                },
                requestEmailVerfiy: function(t, n) {
                    var r = {
                        email: t
                    }, i = e._request("requestEmailVerify", null, null, "POST", r);
                    return i._thenRunCallbacks(n);
                },
                requestMobilePhoneVerify: function(t, n) {
                    var r = {
                        mobilePhoneNumber: t
                    }, i = e._request("requestMobilePhoneVerify", null, null, "POST", r);
                    return i._thenRunCallbacks(n);
                },
                requestPasswordResetBySmsCode: function(t, n) {
                    var r = {
                        mobilePhoneNumber: t
                    }, i = e._request("requestPasswordResetBySmsCode", null, null, "POST", r);
                    return i._thenRunCallbacks(n);
                },
                resetPasswordBySmsCode: function(t, n, r) {
                    var i = {
                        password: n
                    }, s = e._request("resetPasswordBySmsCode", null, t, "PUT", i);
                    return s._thenRunCallbacks(r);
                },
                verifyMobilePhone: function(t, n) {
                    var r = e._request("verifyMobilePhone", null, t, "POST", null);
                    return r._thenRunCallbacks(n);
                },
                requestLoginSmsCode: function(t, n) {
                    var r = {
                        mobilePhoneNumber: t
                    }, i = e._request("requestLoginSmsCode", null, null, "POST", r);
                    return i._thenRunCallbacks(n);
                },
                current: function() {
                    if (e.User._currentUser) return e.User._currentUser;
                    if (e.User._currentUserMatchesDisk) return e.User._currentUser;
                    e.User._currentUserMatchesDisk = !0;
                    var t = e.localStorage.getItem(e._getAVPath(e.User._CURRENT_USER_KEY));
                    if (!t) return null;
                    e.User._currentUser = e.Object._create("_User"), e.User._currentUser._isCurrentUser = !0;
                    var n = JSON.parse(t);
                    return e.User._currentUser.id = n._id, delete n._id, e.User._currentUser._sessionToken = n._sessionToken, 
                    delete n._sessionToken, e.User._currentUser._finishFetch(n), e.User._currentUser._synchronizeAllAuthData(), 
                    e.User._currentUser._refreshCache(), e.User._currentUser._opSetQueue = [ {} ], e.User._currentUser;
                },
                _saveCurrentUser: function(t) {
                    e.User._currentUser !== t && e.User.logOut(), t._isCurrentUser = !0, e.User._currentUser = t, 
                    e.User._currentUserMatchesDisk = !0;
                    var n = t.toJSON();
                    n._id = t.id, n._sessionToken = t._sessionToken, e.localStorage.setItem(e._getAVPath(e.User._CURRENT_USER_KEY), JSON.stringify(n));
                },
                _registerAuthenticationProvider: function(t) {
                    e.User._authProviders[t.getAuthType()] = t, e.User.current() && e.User.current()._synchronizeAuthData(t.getAuthType());
                },
                _logInWith: function(t, n) {
                    var r = e.Object._create("_User");
                    return r._linkWith(t, n);
                }
            });
        };
    }, {
        underscore: 29
    } ],
    24: [ function(e, t) {
        (function(n) {
            "use strict";
            e("underscore"), t.exports = function(e) {
                "undefined" != typeof $ && (e.$ = $);
                var t = function() {}, r = function(n, r, i) {
                    var s;
                    return s = r && r.hasOwnProperty("constructor") ? r.constructor : function() {
                        n.apply(this, arguments);
                    }, e._.extend(s, n), t.prototype = n.prototype, s.prototype = new t(), r && e._.extend(s.prototype, r), 
                    i && e._.extend(s, i), s.prototype.constructor = s, s.__super__ = n.prototype, s;
                };
                e.serverURL = "https://api.leancloud.cn", "undefined" != typeof n && n.versions && n.versions.node && (e._isNode = !0), 
                e.initialize = function(t, n, r) {
                    if (r) throw new Error("AV.initialize() was passed a Master Key, which is only allowed from within Node.js.");
                    e._initialize(t, n, r);
                }, e._initialize = function(t, n, r) {
                    void 0 !== e.applicationId && t !== e.applicationId && n !== e.applicationKey && r !== e.masterKey && console.warn("AVOSCloud SDK is already initialized, please don't reinitialize it."), 
                    e.applicationId = t, e.applicationKey = n, e.masterKey = r, e._useMasterKey = !1;
                }, e.setProduction = function(t) {
                    e._isNullOrUndefined(t) || (t = t ? 1 : 0), e.applicationProduction = e._isNullOrUndefined(t) ? 1 : t;
                }, e._isNode && (e.initialize = e._initialize, e.Cloud = e.Cloud || {}, e.Cloud.useMasterKey = function() {
                    e._useMasterKey = !0;
                }), e.useAVCloudCN = function() {
                    e.serverURL = "https://leancloud.cn";
                }, e.useAVCloudUS = function() {
                    e.serverURL = "https://us-api.leancloud.cn";
                }, e._getAVPath = function(t) {
                    if (!e.applicationId) throw "You need to call AV.initialize before using AV.";
                    if (t || (t = ""), !e._.isString(t)) throw "Tried to get a localStorage path that wasn't a String.";
                    return "/" === t[0] && (t = t.substring(1)), "AV/" + e.applicationId + "/" + t;
                }, e._installationId = null, e._getInstallationId = function() {
                    if (e._installationId) return e._installationId;
                    var t = e._getAVPath("installationId");
                    if (e._installationId = e.localStorage.getItem(t), !e._installationId || "" === e._installationId) {
                        var n = function() {
                            return Math.floor(65536 * (1 + Math.random())).toString(16).substring(1);
                        };
                        e._installationId = n() + n() + "-" + n() + "-" + n() + "-" + n() + "-" + n() + n() + n(), 
                        e.localStorage.setItem(t, e._installationId);
                    }
                    return e._installationId;
                }, e._parseDate = function(e) {
                    var t = new RegExp("^([0-9]{1,4})-([0-9]{1,2})-([0-9]{1,2})T([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2})(.([0-9]+))?Z$"), n = t.exec(e);
                    if (!n) return null;
                    var r = n[1] || 0, i = (n[2] || 1) - 1, s = n[3] || 0, a = n[4] || 0, o = n[5] || 0, u = n[6] || 0, c = n[8] || 0;
                    return new Date(Date.UTC(r, i, s, a, o, u, c));
                }, e._ajaxIE8 = function(t, n, r) {
                    var i = new e.Promise(), s = new XDomainRequest();
                    return s.onload = function() {
                        var e;
                        try {
                            e = JSON.parse(s.responseText);
                        } catch (t) {
                            i.reject(t);
                        }
                        e && i.resolve(e);
                    }, s.onerror = s.ontimeout = function() {
                        ({
                            responseText: JSON.stringify({
                                code: e.Error.X_DOMAIN_REQUEST,
                                error: "IE's XDomainRequest does not supply error info."
                            })
                        }), i.reject(s);
                    }, s.onprogress = function() {}, s.open(t, n), s.send(r), i;
                }, e._useXDomainRequest = function() {
                    return "undefined" != typeof XDomainRequest ? "withCredentials" in new XMLHttpRequest() ? !1 : !0 : !1;
                }, e._ajax = function(t, r, i, s, a) {
                    var o = {
                        success: s,
                        error: a
                    };
                    if (e._useXDomainRequest()) return e._ajaxIE8(t, r, i)._thenRunCallbacks(o);
                    var u = new e.Promise(), c = !1, l = new e.XMLHttpRequest();
                    return l.onreadystatechange = function() {
                        if (4 === l.readyState) {
                            if (c) return;
                            if (c = !0, l.status >= 200 && l.status < 300) {
                                var e;
                                try {
                                    e = JSON.parse(l.responseText);
                                } catch (t) {
                                    u.reject(t);
                                }
                                e && u.resolve(e, l.status, l);
                            } else u.reject(l);
                        }
                    }, l.open(t, r, !0), l.setRequestHeader("Content-Type", "text/plain"), e._isNode && l.setRequestHeader("User-Agent", "AV/" + e.VERSION + " (NodeJS " + n.versions.node + ")"), 
                    l.send(i), u._thenRunCallbacks(o);
                }, e._extend = function(e, t) {
                    var n = r(this, e, t);
                    return n.extend = this.extend, n;
                }, e._request = function(t, n, r, i, s) {
                    if (!e.applicationId) throw "You must specify your applicationId using AV.initialize";
                    if (!e.applicationKey && !e.masterKey) throw "You must specify a key using AV.initialize";
                    if ("batch" !== t && "classes" !== t && "files" !== t && "date" !== t && "functions" !== t && "login" !== t && "push" !== t && "search/select" !== t && "requestPasswordReset" !== t && "requestEmailVerify" !== t && "requestPasswordResetBySmsCode" !== t && "resetPasswordBySmsCode" !== t && "requestMobilePhoneVerify" !== t && "requestLoginSmsCode" !== t && "verifyMobilePhone" !== t && "requestSmsCode" !== t && "verifySmsCode" !== t && "users" !== t && "usersByMobilePhone" !== t && "cloudQuery" !== t && "qiniu" !== t && "statuses" !== t && "bigquery" !== t && "search/select" !== t && "subscribe/statuses/count" !== t && "subscribe/statuses" !== t && !/users\/[^\/]+\/updatePassword/.test(t) && !/users\/[^\/]+\/friendship\/[^\/]+/.test(t)) throw "Bad route: '" + t + "'.";
                    var a = e.serverURL;
                    "/" !== a.charAt(a.length - 1) && (a += "/"), a += "1.1/" + t, n && (a += "/" + n), 
                    r && (a += "/" + r), ("users" === t || "classes" === t) && s && s._fetchWhenSave && (delete s._fetchWhenSave, 
                    a += "?new=true"), s = e._.clone(s || {}), "POST" !== i && (s._method = i, i = "POST"), 
                    s._ApplicationId = e.applicationId, s._ApplicationKey = e.applicationKey, e._isNullOrUndefined(e.applicationProduction) || (s._ApplicationProduction = e.applicationProduction), 
                    e._useMasterKey && (s._MasterKey = e.masterKey), s._ClientVersion = e.VERSION, s._InstallationId = e._getInstallationId();
                    var o = e.User.current();
                    o && o._sessionToken && (s._SessionToken = o._sessionToken);
                    var u = JSON.stringify(s);
                    return e._ajax(i, a, u).then(null, function(t) {
                        var n;
                        if (t && t.responseText) try {
                            var r = JSON.parse(t.responseText);
                            r && (n = new e.Error(r.code, r.error));
                        } catch (i) {}
                        return n = n || new e.Error(-1, t.responseText), e.Promise.error(n);
                    });
                }, e._getValue = function(t, n) {
                    return t && t[n] ? e._.isFunction(t[n]) ? t[n]() : t[n] : null;
                }, e._encode = function(t, n, r) {
                    var i = e._;
                    if (t instanceof e.Object) {
                        if (r) throw "AV.Objects not allowed here";
                        if (!n || i.include(n, t) || !t._hasData) return t._toPointer();
                        if (!t.dirty()) return n = n.concat(t), e._encode(t._toFullJSON(n), n, r);
                        throw "Tried to save an object with a pointer to a new, unsaved object.";
                    }
                    if (t instanceof e.ACL) return t.toJSON();
                    if (i.isDate(t)) return {
                        __type: "Date",
                        iso: t.toJSON()
                    };
                    if (t instanceof e.GeoPoint) return t.toJSON();
                    if (i.isArray(t)) return i.map(t, function(t) {
                        return e._encode(t, n, r);
                    });
                    if (i.isRegExp(t)) return t.source;
                    if (t instanceof e.Relation) return t.toJSON();
                    if (t instanceof e.Op) return t.toJSON();
                    if (t instanceof e.File) {
                        if (!t.url() && !t.id) throw "Tried to save an object containing an unsaved file.";
                        return {
                            __type: "File",
                            id: t.id,
                            name: t.name(),
                            url: t.url()
                        };
                    }
                    if (i.isObject(t)) {
                        var s = {};
                        return e._objectEach(t, function(t, i) {
                            s[i] = e._encode(t, n, r);
                        }), s;
                    }
                    return t;
                }, e._decode = function(t, n) {
                    var r = e._;
                    if (!r.isObject(n)) return n;
                    if (r.isArray(n)) return e._arrayEach(n, function(t, r) {
                        n[r] = e._decode(r, t);
                    }), n;
                    if (n instanceof e.Object) return n;
                    if (n instanceof e.File) return n;
                    if (n instanceof e.Op) return n;
                    if (n.__op) return e.Op._decode(n);
                    if ("Pointer" === n.__type) {
                        var i = n.className, s = e.Object._create(i);
                        return n.createdAt ? (delete n.__type, delete n.className, s._finishFetch(n, !0)) : s._finishFetch({
                            objectId: n.objectId
                        }, !1), s;
                    }
                    if ("Object" === n.__type) {
                        var i = n.className;
                        delete n.__type, delete n.className;
                        var a = e.Object._create(i);
                        return a._finishFetch(n, !0), a;
                    }
                    if ("Date" === n.__type) return e._parseDate(n.iso);
                    if ("GeoPoint" === n.__type) return new e.GeoPoint({
                        latitude: n.latitude,
                        longitude: n.longitude
                    });
                    if ("ACL" === t) return n instanceof e.ACL ? n : new e.ACL(n);
                    if ("Relation" === n.__type) {
                        var o = new e.Relation(null, t);
                        return o.targetClassName = n.className, o;
                    }
                    if ("File" === n.__type) {
                        var u = new e.File(n.name);
                        return u._metaData = n.metaData || {}, u._url = n.url, u.id = n.objectId, u;
                    }
                    return e._objectEach(n, function(t, r) {
                        n[r] = e._decode(r, t);
                    }), n;
                }, e._arrayEach = e._.each, e._traverse = function(t, n, r) {
                    if (t instanceof e.Object) {
                        if (r = r || [], e._.indexOf(r, t) >= 0) return;
                        return r.push(t), e._traverse(t.attributes, n, r), n(t);
                    }
                    return t instanceof e.Relation || t instanceof e.File ? n(t) : e._.isArray(t) ? (e._.each(t, function(i, s) {
                        var a = e._traverse(i, n, r);
                        a && (t[s] = a);
                    }), n(t)) : e._.isObject(t) ? (e._each(t, function(i, s) {
                        var a = e._traverse(i, n, r);
                        a && (t[s] = a);
                    }), n(t)) : n(t);
                }, e._objectEach = e._each = function(t, n) {
                    var r = e._;
                    r.isObject(t) ? r.each(r.keys(t), function(e) {
                        n(t[e], e);
                    }) : r.each(t, n);
                }, e._isNullOrUndefined = function(t) {
                    return e._.isNull(t) || e._.isUndefined(t);
                };
            };
        }).call(this, e("_process"));
    }, {
        _process: 27,
        underscore: 29
    } ],
    25: [ function(e, t) {
        "use strict";
        t.exports = "js0.6.4";
    }, {} ],
    26: [ function(e, t, n) {
        (function(e) {
            function t(e, t) {
                for (var n = 0, r = e.length - 1; r >= 0; r--) {
                    var i = e[r];
                    "." === i ? e.splice(r, 1) : ".." === i ? (e.splice(r, 1), n++) : n && (e.splice(r, 1), 
                    n--);
                }
                if (t) for (;n--; n) e.unshift("..");
                return e;
            }
            function r(e, t) {
                if (e.filter) return e.filter(t);
                for (var n = [], r = 0; r < e.length; r++) t(e[r], r, e) && n.push(e[r]);
                return n;
            }
            var i = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, s = function(e) {
                return i.exec(e).slice(1);
            };
            n.resolve = function() {
                for (var n = "", i = !1, s = arguments.length - 1; s >= -1 && !i; s--) {
                    var a = s >= 0 ? arguments[s] : e.cwd();
                    if ("string" != typeof a) throw new TypeError("Arguments to path.resolve must be strings");
                    a && (n = a + "/" + n, i = "/" === a.charAt(0));
                }
                return n = t(r(n.split("/"), function(e) {
                    return !!e;
                }), !i).join("/"), (i ? "/" : "") + n || ".";
            }, n.normalize = function(e) {
                var i = n.isAbsolute(e), s = "/" === a(e, -1);
                return e = t(r(e.split("/"), function(e) {
                    return !!e;
                }), !i).join("/"), e || i || (e = "."), e && s && (e += "/"), (i ? "/" : "") + e;
            }, n.isAbsolute = function(e) {
                return "/" === e.charAt(0);
            }, n.join = function() {
                var e = Array.prototype.slice.call(arguments, 0);
                return n.normalize(r(e, function(e) {
                    if ("string" != typeof e) throw new TypeError("Arguments to path.join must be strings");
                    return e;
                }).join("/"));
            }, n.relative = function(e, t) {
                function r(e) {
                    for (var t = 0; t < e.length && "" === e[t]; t++) ;
                    for (var n = e.length - 1; n >= 0 && "" === e[n]; n--) ;
                    return t > n ? [] : e.slice(t, n - t + 1);
                }
                e = n.resolve(e).substr(1), t = n.resolve(t).substr(1);
                for (var i = r(e.split("/")), s = r(t.split("/")), a = Math.min(i.length, s.length), o = a, u = 0; a > u; u++) if (i[u] !== s[u]) {
                    o = u;
                    break;
                }
                for (var c = [], u = o; u < i.length; u++) c.push("..");
                return c = c.concat(s.slice(o)), c.join("/");
            }, n.sep = "/", n.delimiter = ":", n.dirname = function(e) {
                var t = s(e), n = t[0], r = t[1];
                return n || r ? (r && (r = r.substr(0, r.length - 1)), n + r) : ".";
            }, n.basename = function(e, t) {
                var n = s(e)[2];
                return t && n.substr(-1 * t.length) === t && (n = n.substr(0, n.length - t.length)), 
                n;
            }, n.extname = function(e) {
                return s(e)[3];
            };
            var a = "b" === "ab".substr(-1) ? function(e, t, n) {
                return e.substr(t, n);
            } : function(e, t, n) {
                return 0 > t && (t = e.length + t), e.substr(t, n);
            };
        }).call(this, e("_process"));
    }, {
        _process: 27
    } ],
    27: [ function(e, t) {
        function n() {
            c = !1, a.length ? u = a.concat(u) : l = -1, u.length && r();
        }
        function r() {
            if (!c) {
                var e = setTimeout(n);
                c = !0;
                for (var t = u.length; t; ) {
                    for (a = u, u = []; ++l < t; ) a[l].run();
                    l = -1, t = u.length;
                }
                a = null, c = !1, clearTimeout(e);
            }
        }
        function i(e, t) {
            this.fun = e, this.array = t;
        }
        function s() {}
        var a, o = t.exports = {}, u = [], c = !1, l = -1;
        o.nextTick = function(e) {
            var t = new Array(arguments.length - 1);
            if (arguments.length > 1) for (var n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
            u.push(new i(e, t)), 1 !== u.length || c || setTimeout(r, 0);
        }, i.prototype.run = function() {
            this.fun.apply(null, this.array);
        }, o.title = "browser", o.browser = !0, o.env = {}, o.argv = [], o.version = "", 
        o.versions = {}, o.on = s, o.addListener = s, o.once = s, o.off = s, o.removeListener = s, 
        o.removeAllListeners = s, o.emit = s, o.binding = function() {
            throw new Error("process.binding is not supported");
        }, o.cwd = function() {
            return "/";
        }, o.chdir = function() {
            throw new Error("process.chdir is not supported");
        }, o.umask = function() {
            return 0;
        };
    }, {} ],
    28: [ function(e, t, n) {
        !function(e) {
            var r = {}, i = {};
            r.length = 0, r.getItem = function(e) {
                return i[e] || null;
            }, r.setItem = function(e, t) {
                "undefined" == typeof t ? r.removeItem(e) : (i[e] = "" + t, r.length++);
            }, r.removeItem = function(e) {
                delete i[e], r.length--;
            }, r.key = function(e) {
                return Object.keys(i)[e] || null;
            }, r.clear = function() {
                i = {}, r.length = 0;
            }, "object" == typeof n ? t.exports = r : e.localStorageMemory = r;
        }(this);
    }, {} ],
    29: [ function(e, t, n) {
        (function() {
            function e(e) {
                function t(t, n, r, i, s, a) {
                    for (;s >= 0 && a > s; s += e) {
                        var o = i ? i[s] : s;
                        r = n(r, t[o], o, t);
                    }
                    return r;
                }
                return function(n, r, i, s) {
                    r = w(r, s, 4);
                    var a = !N(n) && y.keys(n), o = (a || n).length, u = e > 0 ? 0 : o - 1;
                    return arguments.length < 3 && (i = n[a ? a[u] : u], u += e), t(n, r, i, a, u, o);
                };
            }
            function r(e) {
                return function(t, n, r) {
                    n = O(n, r);
                    for (var i = E(t), s = e > 0 ? 0 : i - 1; s >= 0 && i > s; s += e) if (n(t[s], s, t)) return s;
                    return -1;
                };
            }
            function i(e, t, n) {
                return function(r, i, s) {
                    var a = 0, o = E(r);
                    if ("number" == typeof s) e > 0 ? a = s >= 0 ? s : Math.max(s + o, a) : o = s >= 0 ? Math.min(s + 1, o) : s + o + 1; else if (n && s && o) return s = n(r, i), 
                    r[s] === i ? s : -1;
                    if (i !== i) return s = t(f.call(r, a, o), y.isNaN), s >= 0 ? s + a : -1;
                    for (s = e > 0 ? a : o - 1; s >= 0 && o > s; s += e) if (r[s] === i) return s;
                    return -1;
                };
            }
            function s(e, t) {
                var n = T.length, r = e.constructor, i = y.isFunction(r) && r.prototype || c, s = "constructor";
                for (y.has(e, s) && !y.contains(t, s) && t.push(s); n--; ) s = T[n], s in e && e[s] !== i[s] && !y.contains(t, s) && t.push(s);
            }
            var a = this, o = a._, u = Array.prototype, c = Object.prototype, l = Function.prototype, h = u.push, f = u.slice, d = c.toString, p = c.hasOwnProperty, _ = Array.isArray, m = Object.keys, v = l.bind, g = Object.create, b = function() {}, y = function(e) {
                return e instanceof y ? e : this instanceof y ? void (this._wrapped = e) : new y(e);
            };
            "undefined" != typeof n ? ("undefined" != typeof t && t.exports && (n = t.exports = y), 
            n._ = y) : a._ = y, y.VERSION = "1.8.3";
            var w = function(e, t, n) {
                if (void 0 === t) return e;
                switch (null == n ? 3 : n) {
                  case 1:
                    return function(n) {
                        return e.call(t, n);
                    };

                  case 2:
                    return function(n, r) {
                        return e.call(t, n, r);
                    };

                  case 3:
                    return function(n, r, i) {
                        return e.call(t, n, r, i);
                    };

                  case 4:
                    return function(n, r, i, s) {
                        return e.call(t, n, r, i, s);
                    };
                }
                return function() {
                    return e.apply(t, arguments);
                };
            }, O = function(e, t, n) {
                return null == e ? y.identity : y.isFunction(e) ? w(e, t, n) : y.isObject(e) ? y.matcher(e) : y.property(e);
            };
            y.iteratee = function(e, t) {
                return O(e, t, 1 / 0);
            };
            var S = function(e, t) {
                return function(n) {
                    var r = arguments.length;
                    if (2 > r || null == n) return n;
                    for (var i = 1; r > i; i++) for (var s = arguments[i], a = e(s), o = a.length, u = 0; o > u; u++) {
                        var c = a[u];
                        t && void 0 !== n[c] || (n[c] = s[c]);
                    }
                    return n;
                };
            }, x = function(e) {
                if (!y.isObject(e)) return {};
                if (g) return g(e);
                b.prototype = e;
                var t = new b();
                return b.prototype = null, t;
            }, A = function(e) {
                return function(t) {
                    return null == t ? void 0 : t[e];
                };
            }, j = Math.pow(2, 53) - 1, E = A("length"), N = function(e) {
                var t = E(e);
                return "number" == typeof t && t >= 0 && j >= t;
            };
            y.each = y.forEach = function(e, t, n) {
                t = w(t, n);
                var r, i;
                if (N(e)) for (r = 0, i = e.length; i > r; r++) t(e[r], r, e); else {
                    var s = y.keys(e);
                    for (r = 0, i = s.length; i > r; r++) t(e[s[r]], s[r], e);
                }
                return e;
            }, y.map = y.collect = function(e, t, n) {
                t = O(t, n);
                for (var r = !N(e) && y.keys(e), i = (r || e).length, s = Array(i), a = 0; i > a; a++) {
                    var o = r ? r[a] : a;
                    s[a] = t(e[o], o, e);
                }
                return s;
            }, y.reduce = y.foldl = y.inject = e(1), y.reduceRight = y.foldr = e(-1), y.find = y.detect = function(e, t, n) {
                var r;
                return r = N(e) ? y.findIndex(e, t, n) : y.findKey(e, t, n), void 0 !== r && -1 !== r ? e[r] : void 0;
            }, y.filter = y.select = function(e, t, n) {
                var r = [];
                return t = O(t, n), y.each(e, function(e, n, i) {
                    t(e, n, i) && r.push(e);
                }), r;
            }, y.reject = function(e, t, n) {
                return y.filter(e, y.negate(O(t)), n);
            }, y.every = y.all = function(e, t, n) {
                t = O(t, n);
                for (var r = !N(e) && y.keys(e), i = (r || e).length, s = 0; i > s; s++) {
                    var a = r ? r[s] : s;
                    if (!t(e[a], a, e)) return !1;
                }
                return !0;
            }, y.some = y.any = function(e, t, n) {
                t = O(t, n);
                for (var r = !N(e) && y.keys(e), i = (r || e).length, s = 0; i > s; s++) {
                    var a = r ? r[s] : s;
                    if (t(e[a], a, e)) return !0;
                }
                return !1;
            }, y.contains = y.includes = y.include = function(e, t, n, r) {
                return N(e) || (e = y.values(e)), ("number" != typeof n || r) && (n = 0), y.indexOf(e, t, n) >= 0;
            }, y.invoke = function(e, t) {
                var n = f.call(arguments, 2), r = y.isFunction(t);
                return y.map(e, function(e) {
                    var i = r ? t : e[t];
                    return null == i ? i : i.apply(e, n);
                });
            }, y.pluck = function(e, t) {
                return y.map(e, y.property(t));
            }, y.where = function(e, t) {
                return y.filter(e, y.matcher(t));
            }, y.findWhere = function(e, t) {
                return y.find(e, y.matcher(t));
            }, y.max = function(e, t, n) {
                var r, i, s = -1 / 0, a = -1 / 0;
                if (null == t && null != e) {
                    e = N(e) ? e : y.values(e);
                    for (var o = 0, u = e.length; u > o; o++) r = e[o], r > s && (s = r);
                } else t = O(t, n), y.each(e, function(e, n, r) {
                    i = t(e, n, r), (i > a || i === -1 / 0 && s === -1 / 0) && (s = e, a = i);
                });
                return s;
            }, y.min = function(e, t, n) {
                var r, i, s = 1 / 0, a = 1 / 0;
                if (null == t && null != e) {
                    e = N(e) ? e : y.values(e);
                    for (var o = 0, u = e.length; u > o; o++) r = e[o], s > r && (s = r);
                } else t = O(t, n), y.each(e, function(e, n, r) {
                    i = t(e, n, r), (a > i || 1 / 0 === i && 1 / 0 === s) && (s = e, a = i);
                });
                return s;
            }, y.shuffle = function(e) {
                for (var t, n = N(e) ? e : y.values(e), r = n.length, i = Array(r), s = 0; r > s; s++) t = y.random(0, s), 
                t !== s && (i[s] = i[t]), i[t] = n[s];
                return i;
            }, y.sample = function(e, t, n) {
                return null == t || n ? (N(e) || (e = y.values(e)), e[y.random(e.length - 1)]) : y.shuffle(e).slice(0, Math.max(0, t));
            }, y.sortBy = function(e, t, n) {
                return t = O(t, n), y.pluck(y.map(e, function(e, n, r) {
                    return {
                        value: e,
                        index: n,
                        criteria: t(e, n, r)
                    };
                }).sort(function(e, t) {
                    var n = e.criteria, r = t.criteria;
                    if (n !== r) {
                        if (n > r || void 0 === n) return 1;
                        if (r > n || void 0 === r) return -1;
                    }
                    return e.index - t.index;
                }), "value");
            };
            var C = function(e) {
                return function(t, n, r) {
                    var i = {};
                    return n = O(n, r), y.each(t, function(r, s) {
                        var a = n(r, s, t);
                        e(i, r, a);
                    }), i;
                };
            };
            y.groupBy = C(function(e, t, n) {
                y.has(e, n) ? e[n].push(t) : e[n] = [ t ];
            }), y.indexBy = C(function(e, t, n) {
                e[n] = t;
            }), y.countBy = C(function(e, t, n) {
                y.has(e, n) ? e[n]++ : e[n] = 1;
            }), y.toArray = function(e) {
                return e ? y.isArray(e) ? f.call(e) : N(e) ? y.map(e, y.identity) : y.values(e) : [];
            }, y.size = function(e) {
                return null == e ? 0 : N(e) ? e.length : y.keys(e).length;
            }, y.partition = function(e, t, n) {
                t = O(t, n);
                var r = [], i = [];
                return y.each(e, function(e, n, s) {
                    (t(e, n, s) ? r : i).push(e);
                }), [ r, i ];
            }, y.first = y.head = y.take = function(e, t, n) {
                return null == e ? void 0 : null == t || n ? e[0] : y.initial(e, e.length - t);
            }, y.initial = function(e, t, n) {
                return f.call(e, 0, Math.max(0, e.length - (null == t || n ? 1 : t)));
            }, y.last = function(e, t, n) {
                return null == e ? void 0 : null == t || n ? e[e.length - 1] : y.rest(e, Math.max(0, e.length - t));
            }, y.rest = y.tail = y.drop = function(e, t, n) {
                return f.call(e, null == t || n ? 1 : t);
            }, y.compact = function(e) {
                return y.filter(e, y.identity);
            };
            var R = function(e, t, n, r) {
                for (var i = [], s = 0, a = r || 0, o = E(e); o > a; a++) {
                    var u = e[a];
                    if (N(u) && (y.isArray(u) || y.isArguments(u))) {
                        t || (u = R(u, t, n));
                        var c = 0, l = u.length;
                        for (i.length += l; l > c; ) i[s++] = u[c++];
                    } else n || (i[s++] = u);
                }
                return i;
            };
            y.flatten = function(e, t) {
                return R(e, t, !1);
            }, y.without = function(e) {
                return y.difference(e, f.call(arguments, 1));
            }, y.uniq = y.unique = function(e, t, n, r) {
                y.isBoolean(t) || (r = n, n = t, t = !1), null != n && (n = O(n, r));
                for (var i = [], s = [], a = 0, o = E(e); o > a; a++) {
                    var u = e[a], c = n ? n(u, a, e) : u;
                    t ? (a && s === c || i.push(u), s = c) : n ? y.contains(s, c) || (s.push(c), i.push(u)) : y.contains(i, u) || i.push(u);
                }
                return i;
            }, y.union = function() {
                return y.uniq(R(arguments, !0, !0));
            }, y.intersection = function(e) {
                for (var t = [], n = arguments.length, r = 0, i = E(e); i > r; r++) {
                    var s = e[r];
                    if (!y.contains(t, s)) {
                        for (var a = 1; n > a && y.contains(arguments[a], s); a++) ;
                        a === n && t.push(s);
                    }
                }
                return t;
            }, y.difference = function(e) {
                var t = R(arguments, !0, !0, 1);
                return y.filter(e, function(e) {
                    return !y.contains(t, e);
                });
            }, y.zip = function() {
                return y.unzip(arguments);
            }, y.unzip = function(e) {
                for (var t = e && y.max(e, E).length || 0, n = Array(t), r = 0; t > r; r++) n[r] = y.pluck(e, r);
                return n;
            }, y.object = function(e, t) {
                for (var n = {}, r = 0, i = E(e); i > r; r++) t ? n[e[r]] = t[r] : n[e[r][0]] = e[r][1];
                return n;
            }, y.findIndex = r(1), y.findLastIndex = r(-1), y.sortedIndex = function(e, t, n, r) {
                n = O(n, r, 1);
                for (var i = n(t), s = 0, a = E(e); a > s; ) {
                    var o = Math.floor((s + a) / 2);
                    n(e[o]) < i ? s = o + 1 : a = o;
                }
                return s;
            }, y.indexOf = i(1, y.findIndex, y.sortedIndex), y.lastIndexOf = i(-1, y.findLastIndex), 
            y.range = function(e, t, n) {
                null == t && (t = e || 0, e = 0), n = n || 1;
                for (var r = Math.max(Math.ceil((t - e) / n), 0), i = Array(r), s = 0; r > s; s++, 
                e += n) i[s] = e;
                return i;
            };
            var I = function(e, t, n, r, i) {
                if (!(r instanceof t)) return e.apply(n, i);
                var s = x(e.prototype), a = e.apply(s, i);
                return y.isObject(a) ? a : s;
            };
            y.bind = function(e, t) {
                if (v && e.bind === v) return v.apply(e, f.call(arguments, 1));
                if (!y.isFunction(e)) throw new TypeError("Bind must be called on a function");
                var n = f.call(arguments, 2), r = function() {
                    return I(e, r, t, this, n.concat(f.call(arguments)));
                };
                return r;
            }, y.partial = function(e) {
                var t = f.call(arguments, 1), n = function() {
                    for (var r = 0, i = t.length, s = Array(i), a = 0; i > a; a++) s[a] = t[a] === y ? arguments[r++] : t[a];
                    for (;r < arguments.length; ) s.push(arguments[r++]);
                    return I(e, n, this, this, s);
                };
                return n;
            }, y.bindAll = function(e) {
                var t, n, r = arguments.length;
                if (1 >= r) throw new Error("bindAll must be passed function names");
                for (t = 1; r > t; t++) n = arguments[t], e[n] = y.bind(e[n], e);
                return e;
            }, y.memoize = function(e, t) {
                var n = function(r) {
                    var i = n.cache, s = "" + (t ? t.apply(this, arguments) : r);
                    return y.has(i, s) || (i[s] = e.apply(this, arguments)), i[s];
                };
                return n.cache = {}, n;
            }, y.delay = function(e, t) {
                var n = f.call(arguments, 2);
                return setTimeout(function() {
                    return e.apply(null, n);
                }, t);
            }, y.defer = y.partial(y.delay, y, 1), y.throttle = function(e, t, n) {
                var r, i, s, a = null, o = 0;
                n || (n = {});
                var u = function() {
                    o = n.leading === !1 ? 0 : y.now(), a = null, s = e.apply(r, i), a || (r = i = null);
                };
                return function() {
                    var c = y.now();
                    o || n.leading !== !1 || (o = c);
                    var l = t - (c - o);
                    return r = this, i = arguments, 0 >= l || l > t ? (a && (clearTimeout(a), a = null), 
                    o = c, s = e.apply(r, i), a || (r = i = null)) : a || n.trailing === !1 || (a = setTimeout(u, l)), 
                    s;
                };
            }, y.debounce = function(e, t, n) {
                var r, i, s, a, o, u = function() {
                    var c = y.now() - a;
                    t > c && c >= 0 ? r = setTimeout(u, t - c) : (r = null, n || (o = e.apply(s, i), 
                    r || (s = i = null)));
                };
                return function() {
                    s = this, i = arguments, a = y.now();
                    var c = n && !r;
                    return r || (r = setTimeout(u, t)), c && (o = e.apply(s, i), s = i = null), o;
                };
            }, y.wrap = function(e, t) {
                return y.partial(t, e);
            }, y.negate = function(e) {
                return function() {
                    return !e.apply(this, arguments);
                };
            }, y.compose = function() {
                var e = arguments, t = e.length - 1;
                return function() {
                    for (var n = t, r = e[t].apply(this, arguments); n--; ) r = e[n].call(this, r);
                    return r;
                };
            }, y.after = function(e, t) {
                return function() {
                    return --e < 1 ? t.apply(this, arguments) : void 0;
                };
            }, y.before = function(e, t) {
                var n;
                return function() {
                    return --e > 0 && (n = t.apply(this, arguments)), 1 >= e && (t = null), n;
                };
            }, y.once = y.partial(y.before, 2);
            var P = !{
                toString: null
            }.propertyIsEnumerable("toString"), T = [ "valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString" ];
            y.keys = function(e) {
                if (!y.isObject(e)) return [];
                if (m) return m(e);
                var t = [];
                for (var n in e) y.has(e, n) && t.push(n);
                return P && s(e, t), t;
            }, y.allKeys = function(e) {
                if (!y.isObject(e)) return [];
                var t = [];
                for (var n in e) t.push(n);
                return P && s(e, t), t;
            }, y.values = function(e) {
                for (var t = y.keys(e), n = t.length, r = Array(n), i = 0; n > i; i++) r[i] = e[t[i]];
                return r;
            }, y.mapObject = function(e, t, n) {
                t = O(t, n);
                for (var r, i = y.keys(e), s = i.length, a = {}, o = 0; s > o; o++) r = i[o], a[r] = t(e[r], r, e);
                return a;
            }, y.pairs = function(e) {
                for (var t = y.keys(e), n = t.length, r = Array(n), i = 0; n > i; i++) r[i] = [ t[i], e[t[i]] ];
                return r;
            }, y.invert = function(e) {
                for (var t = {}, n = y.keys(e), r = 0, i = n.length; i > r; r++) t[e[n[r]]] = n[r];
                return t;
            }, y.functions = y.methods = function(e) {
                var t = [];
                for (var n in e) y.isFunction(e[n]) && t.push(n);
                return t.sort();
            }, y.extend = S(y.allKeys), y.extendOwn = y.assign = S(y.keys), y.findKey = function(e, t, n) {
                t = O(t, n);
                for (var r, i = y.keys(e), s = 0, a = i.length; a > s; s++) if (r = i[s], t(e[r], r, e)) return r;
            }, y.pick = function(e, t, n) {
                var r, i, s = {}, a = e;
                if (null == a) return s;
                y.isFunction(t) ? (i = y.allKeys(a), r = w(t, n)) : (i = R(arguments, !1, !1, 1), 
                r = function(e, t, n) {
                    return t in n;
                }, a = Object(a));
                for (var o = 0, u = i.length; u > o; o++) {
                    var c = i[o], l = a[c];
                    r(l, c, a) && (s[c] = l);
                }
                return s;
            }, y.omit = function(e, t, n) {
                if (y.isFunction(t)) t = y.negate(t); else {
                    var r = y.map(R(arguments, !1, !1, 1), String);
                    t = function(e, t) {
                        return !y.contains(r, t);
                    };
                }
                return y.pick(e, t, n);
            }, y.defaults = S(y.allKeys, !0), y.create = function(e, t) {
                var n = x(e);
                return t && y.extendOwn(n, t), n;
            }, y.clone = function(e) {
                return y.isObject(e) ? y.isArray(e) ? e.slice() : y.extend({}, e) : e;
            }, y.tap = function(e, t) {
                return t(e), e;
            }, y.isMatch = function(e, t) {
                var n = y.keys(t), r = n.length;
                if (null == e) return !r;
                for (var i = Object(e), s = 0; r > s; s++) {
                    var a = n[s];
                    if (t[a] !== i[a] || !(a in i)) return !1;
                }
                return !0;
            };
            var U = function(e, t, n, r) {
                if (e === t) return 0 !== e || 1 / e === 1 / t;
                if (null == e || null == t) return e === t;
                e instanceof y && (e = e._wrapped), t instanceof y && (t = t._wrapped);
                var i = d.call(e);
                if (i !== d.call(t)) return !1;
                switch (i) {
                  case "[object RegExp]":
                  case "[object String]":
                    return "" + e == "" + t;

                  case "[object Number]":
                    return +e !== +e ? +t !== +t : 0 === +e ? 1 / +e === 1 / t : +e === +t;

                  case "[object Date]":
                  case "[object Boolean]":
                    return +e === +t;
                }
                var s = "[object Array]" === i;
                if (!s) {
                    if ("object" != typeof e || "object" != typeof t) return !1;
                    var a = e.constructor, o = t.constructor;
                    if (a !== o && !(y.isFunction(a) && a instanceof a && y.isFunction(o) && o instanceof o) && "constructor" in e && "constructor" in t) return !1;
                }
                n = n || [], r = r || [];
                for (var u = n.length; u--; ) if (n[u] === e) return r[u] === t;
                if (n.push(e), r.push(t), s) {
                    if (u = e.length, u !== t.length) return !1;
                    for (;u--; ) if (!U(e[u], t[u], n, r)) return !1;
                } else {
                    var c, l = y.keys(e);
                    if (u = l.length, y.keys(t).length !== u) return !1;
                    for (;u--; ) if (c = l[u], !y.has(t, c) || !U(e[c], t[c], n, r)) return !1;
                }
                return n.pop(), r.pop(), !0;
            };
            y.isEqual = function(e, t) {
                return U(e, t);
            }, y.isEmpty = function(e) {
                return null == e ? !0 : N(e) && (y.isArray(e) || y.isString(e) || y.isArguments(e)) ? 0 === e.length : 0 === y.keys(e).length;
            }, y.isElement = function(e) {
                return !(!e || 1 !== e.nodeType);
            }, y.isArray = _ || function(e) {
                return "[object Array]" === d.call(e);
            }, y.isObject = function(e) {
                var t = typeof e;
                return "function" === t || "object" === t && !!e;
            }, y.each([ "Arguments", "Function", "String", "Number", "Date", "RegExp", "Error" ], function(e) {
                y["is" + e] = function(t) {
                    return d.call(t) === "[object " + e + "]";
                };
            }), y.isArguments(arguments) || (y.isArguments = function(e) {
                return y.has(e, "callee");
            }), "function" != typeof /./ && "object" != typeof Int8Array && (y.isFunction = function(e) {
                return "function" == typeof e || !1;
            }), y.isFinite = function(e) {
                return isFinite(e) && !isNaN(parseFloat(e));
            }, y.isNaN = function(e) {
                return y.isNumber(e) && e !== +e;
            }, y.isBoolean = function(e) {
                return e === !0 || e === !1 || "[object Boolean]" === d.call(e);
            }, y.isNull = function(e) {
                return null === e;
            }, y.isUndefined = function(e) {
                return void 0 === e;
            }, y.has = function(e, t) {
                return null != e && p.call(e, t);
            }, y.noConflict = function() {
                return a._ = o, this;
            }, y.identity = function(e) {
                return e;
            }, y.constant = function(e) {
                return function() {
                    return e;
                };
            }, y.noop = function() {}, y.property = A, y.propertyOf = function(e) {
                return null == e ? function() {} : function(t) {
                    return e[t];
                };
            }, y.matcher = y.matches = function(e) {
                return e = y.extendOwn({}, e), function(t) {
                    return y.isMatch(t, e);
                };
            }, y.times = function(e, t, n) {
                var r = Array(Math.max(0, e));
                t = w(t, n, 1);
                for (var i = 0; e > i; i++) r[i] = t(i);
                return r;
            }, y.random = function(e, t) {
                return null == t && (t = e, e = 0), e + Math.floor(Math.random() * (t - e + 1));
            }, y.now = Date.now || function() {
                return new Date().getTime();
            };
            var k = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#x27;",
                "`": "&#x60;"
            }, D = y.invert(k), q = function(e) {
                var t = function(t) {
                    return e[t];
                }, n = "(?:" + y.keys(e).join("|") + ")", r = RegExp(n), i = RegExp(n, "g");
                return function(e) {
                    return e = null == e ? "" : "" + e, r.test(e) ? e.replace(i, t) : e;
                };
            };
            y.escape = q(k), y.unescape = q(D), y.result = function(e, t, n) {
                var r = null == e ? void 0 : e[t];
                return void 0 === r && (r = n), y.isFunction(r) ? r.call(e) : r;
            };
            var L = 0;
            y.uniqueId = function(e) {
                var t = ++L + "";
                return e ? e + t : t;
            }, y.templateSettings = {
                evaluate: /<%([\s\S]+?)%>/g,
                interpolate: /<%=([\s\S]+?)%>/g,
                escape: /<%-([\s\S]+?)%>/g
            };
            var M = /(.)^/, F = {
                "'": "'",
                "\\": "\\",
                "\r": "r",
                "\n": "n",
                "\u2028": "u2028",
                "\u2029": "u2029"
            }, V = /\\|'|\r|\n|\u2028|\u2029/g, J = function(e) {
                return "\\" + F[e];
            };
            y.template = function(e, t, n) {
                !t && n && (t = n), t = y.defaults({}, t, y.templateSettings);
                var r = RegExp([ (t.escape || M).source, (t.interpolate || M).source, (t.evaluate || M).source ].join("|") + "|$", "g"), i = 0, s = "__p+='";
                e.replace(r, function(t, n, r, a, o) {
                    return s += e.slice(i, o).replace(V, J), i = o + t.length, n ? s += "'+\n((__t=(" + n + "))==null?'':_.escape(__t))+\n'" : r ? s += "'+\n((__t=(" + r + "))==null?'':__t)+\n'" : a && (s += "';\n" + a + "\n__p+='"), 
                    t;
                }), s += "';\n", t.variable || (s = "with(obj||{}){\n" + s + "}\n"), s = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + s + "return __p;\n";
                try {
                    var a = new Function(t.variable || "obj", "_", s);
                } catch (o) {
                    throw o.source = s, o;
                }
                var u = function(e) {
                    return a.call(this, e, y);
                }, c = t.variable || "obj";
                return u.source = "function(" + c + "){\n" + s + "}", u;
            }, y.chain = function(e) {
                var t = y(e);
                return t._chain = !0, t;
            };
            var Q = function(e, t) {
                return e._chain ? y(t).chain() : t;
            };
            y.mixin = function(e) {
                y.each(y.functions(e), function(t) {
                    var n = y[t] = e[t];
                    y.prototype[t] = function() {
                        var e = [ this._wrapped ];
                        return h.apply(e, arguments), Q(this, n.apply(y, e));
                    };
                });
            }, y.mixin(y), y.each([ "pop", "push", "reverse", "shift", "sort", "splice", "unshift" ], function(e) {
                var t = u[e];
                y.prototype[e] = function() {
                    var n = this._wrapped;
                    return t.apply(n, arguments), "shift" !== e && "splice" !== e || 0 !== n.length || delete n[0], 
                    Q(this, n);
                };
            }), y.each([ "concat", "join", "slice" ], function(e) {
                var t = u[e];
                y.prototype[e] = function() {
                    return Q(this, t.apply(this._wrapped, arguments));
                };
            }), y.prototype.value = function() {
                return this._wrapped;
            }, y.prototype.valueOf = y.prototype.toJSON = y.prototype.value, y.prototype.toString = function() {
                return "" + this._wrapped;
            }, "function" == typeof define && define.amd && define("underscore", [], function() {
                return y;
            });
        }).call(this);
    }, {} ]
}, {}, [ 2 ]), function() {
    angular.module("HapiApp", [ "ionic", "pasvaz.bindonce", "angular-cache", "ConfigModule", "DeviceModule", "ToolboxModule" ]).run([ "$rootScope", "$ionicPlatform", "$state", "$ionicLoading", "$ionicPopup", "CacheFactory", "staticconfig", "$ionicHistory", "$http", "Devices", function($rootScope, $ionicPlatform, $state, $ionicLoading, $ionicPopup, CacheFactory, staticconfig, $ionicHistory, $http, Devices) {
        var appCache, appStore, autoLogin, bannerAdDone, initDB, loginFailTime, onBackKey1, showAd, showBannerAd;
        return window.domain = "http://localhost", window.deviceReady = !1, $rootScope.lasterr = null, 
        $rootScope.title = "SuperDevice", $rootScope.resetTitle = function() {
            return $rootScope.title = "SuperDevice";
        }, $rootScope.setTitle = function(title) {
            return $rootScope.title = title;
        }, $rootScope.onBackKey1 = onBackKey1 = function(e) {
            var backView, r;
            return console.log("SuperDevice onBackKey1"), cordova.plugins.Keyboard.isVisible ? (cordova.plugins.Keyboard.close(), 
            e.preventDefault(), !0) : (backView = $ionicHistory.backView(), backView ? (console.log("have back view"), 
            console.log(backView), $ionicHistory.goBack()) : (console.log("no back view"), r = confirm("确定要退出吗?"), 
            r === !0 && (window.superdevice.stopMockGPS(), ionic.Platform.exitApp())), e.preventDefault(), 
            !0);
        }, $ionicPlatform.registerBackButtonAction($rootScope.onBackKey1, 100), initDB = function() {
            var CREATE_TABLE_SCHEM, db;
            return db = window.sqlitePlugin.openDatabase({
                name: "history.db",
                androidDatabaseImplementation: 2,
                androidLockWorkaround: 1
            }), CREATE_TABLE_SCHEM = "CREATE TABLE IF NOT EXISTS history_tbl (id integer primary key, timestamp REAL, imei text, model text, brand text, product text, manufacturer text, board text, device text, display text, bootloader text, simoperator text, simoperatorname text, simserialnumber text, line1number text, networkoperatorname text, networkoperator text, macaddress text);", 
            db.transaction(function(tx) {
                return tx.executeSql(CREATE_TABLE_SCHEM);
            }, function(error) {
                return console.log("initDB transaction error: " + error.message), db.close();
            }, function() {
                return console.log("initDB transaction ok"), db.close();
            });
        }, $rootScope.passLocalAuth = !0, loginFailTime = 0, autoLogin = function() {
            var user;
            return $rootScope.loginUser = {
                username: "未登陆用户，联网后自动登陆",
                expired: !0
            }, $rootScope.loginUser.username = "正在登陆...", console.log("start login"), user = AV.User.logIn(window.superdevice.uuid, window.superdevice.uuid, {
                success: function(user) {
                    return console.log("login succ"), $rootScope.loginUser = user.attributes, console.log(loginUser.username), 
                    $rootScope.$apply();
                },
                error: function(user, err) {
                    return console.log("login fail"), err.op = "login", user = new AV.User(), user.set("username", window.superdevice.uuid), 
                    user.set("password", window.superdevice.uuid), user.set("imei", window.superdevice.imei), 
                    user.set("model", window.superdevice.model), user.set("brand", window.superdevice.brand), 
                    user.set("product", window.superdevice.product), user.set("loginTimes", 1), window.superdevice.line1number && user.set("line1number", window.superdevice.line1number), 
                    window.superdevice.imsi && user.set("imsi", window.superdevice.imsi), window.superdevice.simserialnumber && user.set("simserialnumber", window.superdevice.simserialnumber), 
                    211 === err.code ? user.signUp(null, {
                        success: function(user) {
                            return console.log("signUp succ"), console.log(user), $rootScope.loginUser = user.attributes, 
                            $rootScope.loginUser.expired = !1, $rootScope.$apply();
                        },
                        error: function(user, error) {
                            return error.op = "signUp", console.log("signUp fail"), $rootScope.lasterr = error, 
                            $rootScope.loginUser.expired = !1, $rootScope.loginUser.username = "未注册用户,请退出重试", 
                            $rootScope.$apply();
                        }
                    }) : (loginFailTime += 1, 3 >= loginFailTime ? (setTimeout(function() {
                        return autoLogin();
                    }, 5e3), $rootScope.loginUser.username = "登陆失败" + loginFailTime + "次,正在重新登录") : $rootScope.loginUser.username = $rootScope.lasterr.message, 
                    $rootScope.$apply());
                }
            });
        }, bannerAdDone = !1, showAd = function() {
            var admobid;
            return admobid = {
                banner: "ca-app-pub-7798193972099512/4031561787",
                interstitial: "ca-app-pub-7798193972099512/7043903783"
            }, Devices.requestInterstitialAd(), Devices.readyThenShowInterstitialAd();
        }, showBannerAd = function() {
            var admobid;
            return admobid = {
                banner: "ca-app-pub-7798193972099512/4031561787",
                interstitial: "ca-app-pub-7798193972099512/7043903783"
            }, bannerAdDone ? void 0 : (Devices.createBannerView(), Devices.showBannerAd(), 
            bannerAdDone = !0);
        }, $ionicPlatform.ready(function() {
            return window.cordova && window.cordova.plugins.Keyboard && cordova.plugins.Keyboard.hideKeyboardAccessoryBar(!0), 
            window.StatusBar && StatusBar.styleDefault(), window.deviceReady = !0, AV.initialize("LGTdNJIcIUICWn2bd9ItTbaS", "vWHGjxnQBp2wmbl2XfXsDmeU"), 
            autoLogin(), setInterval(showAd, 12e4), setTimeout(showBannerAd, 5e3), initDB();
        }), $rootScope.getConnectionType = function() {
            return navigator.connection.type;
        }, $rootScope.getConnectionTypeDesc = function() {
            var networkState, states;
            return networkState = navigator.connection.type, states = {}, states[Connection.UNKNOWN] = "未知的网络连接", 
            states[Connection.ETHERNET] = "已连接以太网", states[Connection.WIFI] = "已连接WIFI网络", states[Connection.CELL_2G] = "已连接2G网络", 
            states[Connection.CELL_3G] = "已连接3G网络", states[Connection.CELL_4G] = "已连接4G网络", 
            states[Connection.CELL] = "已连接无线网络", states[Connection.NONE] = "未连接网络", states[networkState];
        }, $rootScope.back = function() {
            return $ionicHistory.backView() ? $ionicHistory.goBack() : $state.go("app.device.me");
        }, $rootScope.showLoading = function() {
            return $rootScope.loading = $ionicLoading.show({
                content: '<i class=" ion-loading-c"></i> Loading...',
                delay: 1e3,
                animation: "fade-in",
                showBackdrop: !0
            });
        }, $rootScope.hideLoading = function() {
            return $ionicLoading.hide();
        }, $rootScope.showAlert = function(title, content) {
            return $rootScope.alert = $ionicPopup.alert({
                title: title,
                template: content
            });
        }, $rootScope.closeAlert = function() {
            return $rootScope.alert.close();
        }, appStore = CacheFactory.createCache("appStore", {
            deleteOnExpire: "aggressive",
            storageMode: "localStorage",
            maxAge: 9e5,
            cacheFlushInterval: 36e5
        }), appCache = CacheFactory.createCache("appCache", {
            deleteOnExpire: "aggressive",
            maxAge: 3e3,
            recycleFreq: 6e4,
            cacheFlushInterval: 36e5
        }), $http.defaults.cache = appCache, $rootScope.getStore = function() {
            return CacheFactory.get("appStore");
        }, $rootScope.getCache = function() {
            return CacheFactory.get("appCache");
        };
    } ]).config([ "$httpProvider", "$stateProvider", "$urlRouterProvider", "staticconfig", "$ionicConfigProvider", "CacheFactoryProvider", function($httpProvider, $stateProvider, $urlRouterProvider, staticconfig, $ionicConfigProvider, CacheFactoryProvider) {
        var app_state;
        return $ionicConfigProvider.tabs.position("bottom"), $ionicConfigProvider.tabs.style("standard"), 
        $ionicConfigProvider.navBar.alignTitle("center"), $ionicConfigProvider.backButton.previousTitleText(!1), 
        angular.extend(CacheFactoryProvider.defaults, {
            maxAge: 9e5
        }), app_state = {
            url: "/app",
            "abstract": !0,
            templateUrl: "partials_phone/main/empty_main.html"
        }, "slidemenu" === staticconfig.mainstyle && (app_state.templateUrl = "partials_phone/main/slide_main.html"), 
        $stateProvider.state("app", app_state), $urlRouterProvider.otherwise(staticconfig.mainurl), 
        $httpProvider.defaults.useXDomain = !0, $httpProvider.defaults.headers.common["X-Requested-With"] = "XMLHttpRequest";
    } ]), angular.module("ConfigModule", []).constant("staticconfig", {
        mainstyle: "empty",
        mainstate: "app.device.me",
        mainurl: "/app/device/me"
    }), window.largeadmob = [ "ca-app-pub-7798193972099512/7043903783", "ca-app-pub-7798193972099512/4090437382", "ca-app-pub-7798193972099512/8520636982", "ca-app-pub-7798193972099512/2474103385", "ca-app-pub-7798193972099512/3950836584", "ca-app-pub-7798193972099512/3950836584", "ca-app-pub-7798193972099512/6904302985", "ca-app-pub-7798193972099512/8381036183", "ca-app-pub-7798193972099512/9857769384", "ca-app-pub-7798193972099512/2334502580", "ca-app-pub-7798193972099512/5287968989" ], 
    window.smalladmob = [ "ca-app-pub-7798193972099512/4031561787" ], window.cities = [ {
        value: "sz",
        location: [ 22.553579, 114.117275 ],
        showName: "深圳"
    }, {
        value: "sha",
        location: [ 31.185358, 121.550165 ],
        showName: "上海"
    }, {
        value: "bj",
        location: [ 39.916527, 116.397128 ],
        showName: "北京"
    } ], angular.module("DeviceModule", [ "ionic", "Device.Services", "Device.Controllers" ]).config([ "$stateProvider", "$urlRouterProvider", function($stateProvider, $urlRouterProvider) {
        return $stateProvider.state("app.device", {
            url: "/device",
            "abstract": !0,
            views: {
                main: {
                    templateUrl: "partials_phone/device/main.html"
                }
            }
        }).state("app.device.deviceinfo", {
            url: "/deviceinfo",
            views: {
                tab1: {
                    templateUrl: "partials_phone/device/device.html",
                    controller: "DeviceCtrl"
                }
            }
        }).state("app.device.siminfo", {
            url: "/siminfo",
            views: {
                tab2: {
                    templateUrl: "partials_phone/device/sim.html",
                    controller: "SimCtrl"
                }
            }
        }).state("app.device.wifiinfo", {
            url: "/wifiinfo",
            views: {
                tab3: {
                    templateUrl: "partials_phone/device/wifi.html",
                    controller: "WifiCtrl"
                }
            }
        }).state("app.device.location", {
            url: "/location",
            views: {
                tab4: {
                    templateUrl: "partials_phone/device/location.html",
                    controller: "LocationCtrl",
                    resolve: {
                        DeviceInfo: function(Devices) {
                            return Devices.getLocationInfo().then(function(result) {
                                return result;
                            });
                        }
                    }
                }
            }
        }).state("app.locationsetting", {
            url: "/locationsetting",
            views: {
                main: {
                    templateUrl: "partials_phone/device/locationsetting.html",
                    controller: "LocationSettingCtrl",
                    resolve: {
                        DeviceInfo: function(Devices) {
                            return Devices.getLocationInfo().then(function(result) {
                                return result;
                            });
                        }
                    }
                }
            }
        }).state("app.device.verifycode", {
            url: "/verifycode",
            views: {
                tab5: {
                    templateUrl: "partials_phone/device/verifycode.html",
                    controller: "VerifyCodeCtrl"
                }
            }
        }).state("app.device.me", {
            url: "/me",
            views: {
                tab5: {
                    templateUrl: "partials_phone/device/me.html",
                    controller: "MeCtrl"
                }
            }
        }).state("app.history", {
            url: "/history",
            views: {
                main: {
                    templateUrl: "partials_phone/device/history.html",
                    controller: "HistoryCtrl"
                }
            }
        }).state("app.backup", {
            url: "/backup",
            views: {
                main: {
                    templateUrl: "partials_phone/device/backup.html",
                    controller: "BackupCtrl",
                    resolve: {
                        DeviceInfo: function(Devices) {
                            return Devices.getSimInfo().then(function(result) {
                                return Devices.getWifiInfo().then(function(result1) {
                                    return result1;
                                });
                            });
                        }
                    }
                }
            }
        }).state("app.help", {
            url: "/help",
            views: {
                main: {
                    templateUrl: "partials_phone/device/help.html",
                    controller: "HelpCtrl"
                }
            }
        });
    } ]), angular.module("Device.Controllers", [ "Device.Services" ]).controller("OriginDeviceInfoCtrl", [ "$scope", "$state", "Devices", "$ionicHistory", function($scope, $state, Devices, $ionicHistory) {
        return $ionicHistory.clearHistory(), $scope.superdevice = Devices.getDeviceInfo();
    } ]).controller("DeviceCtrl", [ "$scope", "$state", "Devices", "$ionicPopup", "$ionicHistory", function($scope, $state, Devices, $ionicPopup, $ionicHistory) {
        var updateModelList;
        return $ionicHistory.clearHistory(), $scope.superdevice = Devices.getDeviceInfo(), 
        $scope.manufacturerOpsList = $scope.brandOpsList = Object.keys(window.imeiStore), 
        $scope.produceRandomImei = function() {
            return $scope.superdevice.imei = Devices.produceRandomImei(), Devices.setDeviceId($scope.superdevice.imei);
        }, $scope.setManufacturer = function() {
            return Devices.setManufacturer($scope.superdevice.manufacturer);
        }, $scope.setBrand = function() {
            return Devices.setBrand($scope.superdevice.brand), $scope.modelOpsList = $scope.productOpsList = window.imeiStore[$scope.superdevice.brand], 
            $scope.superdevice.model = $scope.modelOpsList[0].model, Devices.setModel($scope.superdevice.model);
        }, $scope.setID = function() {
            return Devices.setID($scope.superdevice.id);
        }, $scope.setDevice = function() {
            return Devices.setDevice($scope.superdevice.device);
        }, $scope.setBootloader = function() {
            return Devices.setBootloader($scope.superdevice.bootloader);
        }, $scope.setDisplay = function() {
            return Devices.setDisplay($scope.superdevice.display);
        }, $scope.setProduct = function() {
            return Devices.setProduct($scope.superdevice.product);
        }, $scope.setModel = function() {
            return Devices.setModel($scope.superdevice.model);
        }, $scope.setBoard = function() {
            return Devices.setBoard($scope.superdevice.board);
        }, updateModelList = function() {
            return window.imeiStore[$scope.superdevice.manufacturer] ? $scope.modelOpsList = $scope.productOpsList = window.imeiStore[$scope.superdevice.brand] : $scope.modelOpsList = $scope.productOpsList = [];
        }, $scope.produceRandomDevice = function() {
            var confirmPopup;
            return confirmPopup = $ionicPopup.confirm({
                title: "确认提示",
                template: "确定要随机生成新的设备吗?",
                cancelText: "取消",
                okText: "确定"
            }), confirmPopup.then(function(res) {
                var newdevice;
                if (res) return newdevice = Devices.produceRandomDevice(), Devices.setWithBundle(newdevice).then(function() {
                    return updateModelList(), $scope.superdevice = Devices.getDeviceInfo(), $scope.showAlert("修改成功!");
                });
            });
        }, updateModelList();
    } ]).controller("SimCtrl", [ "$scope", "$state", "Devices", "$ionicPopup", "$ionicHistory", function($scope, $state, Devices, $ionicPopup, $ionicHistory) {
        return $ionicHistory.clearHistory(), $scope.superdevice = Devices.getDeviceInfo(), 
        Devices.getSimInfo(), $scope.setLine1Number = function() {
            return Devices.setLine1Number($scope.superdevice.line1number);
        }, $scope.setNetworkOperator = function() {
            return Devices.setNetworkOperator($scope.superdevice.networkoperator);
        }, $scope.setNetworkOperatorName = function() {
            return Devices.setNetworkOperatorName($scope.superdevice.networkoperatorname);
        }, $scope.setSimOperatorName = function() {
            return Devices.setSimOperatorName($scope.superdevice.simoperatorname);
        }, $scope.setSimOperator = function() {
            return Devices.setSimOperator($scope.superdevice.simoperator);
        }, $scope.setSimSerialNumber = function() {
            return Devices.setSimSerialNumber($scope.superdevice.simserialnumber);
        }, $scope.setImsi = function() {
            return Devices.setImsi($scope.superdevice.imsi);
        }, $scope.produceRandomSim = function() {
            var confirmPopup;
            return confirmPopup = $ionicPopup.confirm({
                title: "确认提示",
                template: "确定要随机生成新的SIM卡吗?",
                cancelText: "取消",
                okText: "确定"
            }), confirmPopup.then(function(res) {
                var newsim;
                if (res) return newsim = Devices.produceRandomSim(), Devices.setWithBundle(newsim).then(function() {
                    return $scope.superdevice = Devices.getDeviceInfo(), Devices.getSimInfo(), $scope.showAlert("修改成功!");
                });
            });
        };
    } ]).controller("WifiCtrl", [ "$scope", "$state", "Devices", "$ionicPopup", "$ionicHistory", function($scope, $state, Devices, $ionicPopup, $ionicHistory) {
        return $ionicHistory.clearHistory(), $scope.superdevice = Devices.getDeviceInfo(), 
        Devices.getWifiInfo(), $scope.setMacAddress = function() {
            return Devices.setMacAddress($scope.superdevice.macaddress);
        }, $scope.setIPAddress = function() {
            return Devices.setIPAddress($scope.superdevice.ipaddress);
        }, $scope.produceRandomMac = function() {
            var confirmPopup;
            return confirmPopup = $ionicPopup.confirm({
                title: "确认提示",
                template: "确定要随机生成新的MAC地址吗?",
                cancelText: "取消",
                okText: "确定"
            }), confirmPopup.then(function(res) {
                var mac;
                if (res) return mac = Devices.produceRandomMacAddress(), $scope.superdevice.macaddress = mac, 
                Devices.setMacAddress($scope.superdevice.macaddress);
            });
        };
    } ]).controller("LocationCtrl", [ "$scope", "$rootScope", "$state", "Devices", "$ionicHistory", "$interval", function($scope, $rootScope, $state, Devices, $ionicHistory, $interval) {
        var end_marker, getCityName, initMap, loadScript, polyline, resetPathSetting, resetRouter, start_marker, timer;
        return start_marker = null, end_marker = null, polyline = null, timer = null, $ionicHistory.clearHistory(), 
        $scope.superdevice = Devices.getDeviceInfo(), $scope.title = "模拟关闭", $scope.mockLocation = !1, 
        $scope.minutesOpsList = [ {
            showName: "20分钟",
            value: 20
        }, {
            showName: "30分钟",
            value: 30
        }, {
            showName: "40分钟",
            value: 40
        }, {
            showName: "1小时",
            value: 60
        }, {
            showName: "80分钟",
            value: 80
        }, {
            showName: "1.5小时",
            value: 90
        }, {
            showName: "100分钟",
            value: 100
        }, {
            showName: "2小时",
            value: 120
        }, {
            showName: "2.5小时",
            value: 150
        }, {
            showName: "3小时",
            value: 180
        } ], getCityName = function() {
            var city, item, _i, _len, _ref;
            for (city = $scope.superdevice.city, _ref = window.cities, _i = 0, _len = _ref.length; _len > _i; _i++) if (item = _ref[_i], 
            item.value === city) return item.showName;
            return "北京";
        }, resetPathSetting = function() {
            return "fix" === $scope.superdevice.locationmode ? $scope.pathSetting = {
                step: -1,
                minutes: 30,
                start: [],
                end: [],
                path: []
            } : $scope.pathSetting = {
                step: 1,
                minutes: 30,
                start: [],
                end: [],
                path: []
            };
        }, resetPathSetting(), $scope.openSetting = function() {
            return $state.go("app.locationsetting");
        }, loadScript = function() {
            var script;
            return script = document.createElement("script"), script.type = "text/javascript", 
            script.charset = "utf-8", script.src = "http://map.qq.com/api/js?v=2.exp&callback=initMap", 
            document.body.appendChild(script), window.loadSosoMap = !0, console.log("start load qq map");
        }, resetRouter = function() {
            return start_marker && start_marker.setMap(null), start_marker = null, end_marker && end_marker.setMap(null), 
            end_marker = null, polyline && polyline.setMap(null), polyline = null;
        }, initMap = window.initMap = function() {
            var center, myOptions;
            return console.log("qq map api loaded"), center = new qq.maps.LatLng($scope.superdevice.latitude, $scope.superdevice.longitude), 
            console.log("center is: " + $scope.superdevice.latitude + "," + $scope.superdevice.longitude), 
            myOptions = {
                zoom: 13,
                center: center,
                mapTypeId: qq.maps.MapTypeId.ROADMAP
            }, window.map = new qq.maps.Map(document.getElementById("container"), myOptions), 
            window.marker = new qq.maps.Marker({
                position: center,
                map: window.map
            }), window.directionsService = new qq.maps.DrivingService({
                complete: function(response) {
                    var anchor, directions_routes, end, end_icon, i, route, size, start, start_icon, _i, _ref, _results;
                    for (start = response.detail.start, end = response.detail.end, anchor = new qq.maps.Point(6, 6), 
                    size = new qq.maps.Size(24, 36), start_icon = new qq.maps.MarkerImage("phone_img/busmarker.png", size, new qq.maps.Point(0, 0), anchor), 
                    end_icon = new qq.maps.MarkerImage("phone_img/busmarker.png", size, new qq.maps.Point(24, 0), anchor), 
                    resetRouter(), start_marker = new qq.maps.Marker({
                        icon: start_icon,
                        position: start.latLng,
                        map: window.map,
                        zIndex: 1
                    }), end_marker = new qq.maps.Marker({
                        icon: end_icon,
                        position: end.latLng,
                        map: window.map,
                        zIndex: 1
                    }), directions_routes = response.detail.routes, _results = [], i = _i = 0, _ref = directions_routes.length; _ref >= 0 ? _ref >= _i : _i >= _ref; i = _ref >= 0 ? ++_i : --_i) route = directions_routes[i], 
                    console.log(route), $scope.pathSetting.path = route.path, window.map.fitBounds(response.detail.bounds), 
                    _results.push(polyline = new qq.maps.Polyline({
                        path: route.path,
                        strokeColor: "#3893F9",
                        strokeWeight: 6,
                        map: window.map
                    }));
                    return _results;
                }
            }), $scope.listener = qq.maps.event.addListener(window.map, "dblclick", function(event) {
                return $scope.superdevice.latitude = event.latLng.getLat(), $scope.superdevice.longitude = event.latLng.getLng(), 
                center = new qq.maps.LatLng($scope.superdevice.latitude, $scope.superdevice.longitude), 
                $scope.showAlert("您点击的位置为:\n" + $scope.superdevice.latitude + "\n" + $scope.superdevice.longitude), 
                Devices.setLatitude($scope.superdevice.latitude), Devices.setLongitude($scope.superdevice.longitude), 
                null !== window.marker && window.marker.setMap(null), window.map.setCenter(center), 
                window.marker = new qq.maps.Marker({
                    map: window.map,
                    position: center
                }), 1 === $scope.pathSetting.step ? (resetRouter(), $scope.pathSetting.step += 1, 
                $scope.pathSetting.start = [ $scope.superdevice.latitude, $scope.superdevice.longitude ]) : 2 === $scope.pathSetting.step ? ($scope.pathSetting.step += 1, 
                $scope.pathSetting.end = [ $scope.superdevice.latitude, $scope.superdevice.longitude ], 
                window.directionsService.setLocation(getCityName()), window.directionsService.setPolicy(qq.maps.DrivingPolicy.LEAST_TIME), 
                window.directionsService.search(new qq.maps.LatLng($scope.pathSetting.start[0], $scope.pathSetting.start[1]), new qq.maps.LatLng($scope.pathSetting.end[0], $scope.pathSetting.end[1]))) : void 0;
            });
        }, $scope.startMockGPS = function() {
            return $scope.mockLocation ? void $scope.showAlert("模拟定位已经开启") : "car" === $scope.superdevice.locationmode && 0 === $scope.pathSetting.path.length ? void $scope.showAlert("请先设置起点和终点") : ($scope.pathSetting.minutes || ($scope.pathSetting.minutes = 30), 
            $scope.mockLocation = !0, $scope.showAlert("开启模拟定位成功"), $scope.title = "模拟开启", "fix" === $scope.superdevice.locationmode ? $scope.superdevice.startMockGPS() : ($scope.superdevice.startWithLocationPath($scope.pathSetting.minutes, $scope.pathSetting.path), 
            timer = $interval(function() {
                return Devices.getLocationInfo().then(function(result) {
                    var center;
                    return $scope.superdevice = window.superdevice, center = new qq.maps.LatLng($scope.superdevice.latitude, $scope.superdevice.longitude), 
                    null !== window.marker && window.marker.setMap(null), window.map.setCenter(center), 
                    window.marker = new qq.maps.Marker({
                        map: window.map,
                        position: center
                    });
                });
            }, 1e3)));
        }, $scope.stopMockGPS = function() {
            return $scope.mockLocation ? ($scope.mockLocation = !1, $scope.showAlert("模拟定位关闭"), 
            $scope.title = "模拟关闭", resetPathSetting(), $scope.superdevice.stopMockGPS(), timer ? ($interval.cancel(timer), 
            timer = null) : void 0) : void $scope.showAlert("模拟定位已经关闭");
        }, window.loadSosoMap || loadScript(), $scope.$on("$destroy", function() {
            return timer ? ($interval.cancel(timer), timer = null) : void 0;
        }), $scope.$on("$ionicView.beforeEnter", function() {
            return Devices.getLocationInfo().then(function(result) {
                var center;
                return $scope.superdevice = window.superdevice, resetPathSetting(), console.log("$ionicView.beforeEnter"), 
                console.log("x=" + $scope.superdevice.latitude + ";y=" + $scope.superdevice.longitude), 
                window.map ? (center = new qq.maps.LatLng($scope.superdevice.latitude, $scope.superdevice.longitude), 
                null !== window.marker && window.marker.setMap(null), window.map.setCenter(center), 
                window.marker = new qq.maps.Marker({
                    map: window.map,
                    position: center
                })) : void 0;
            });
        });
    } ]).controller("LocationSettingCtrl", [ "$scope", "$rootScope", "Devices", "$ionicPopup", "$ionicHistory", "$timeout", function($scope, $rootScope, Devices, $ionicPopup, $ionicHistory, $timeout) {
        return $scope.superdevice = Devices.getDeviceInfo(), $scope.cityOpsList = window.cities, 
        $scope.setCity = function() {
            var city, item, _i, _len, _ref;
            for (city = $scope.superdevice.city, _ref = window.cities, _i = 0, _len = _ref.length; _len > _i; _i++) if (item = _ref[_i], 
            item.value === city) {
                $scope.superdevice.latitude = item.location[0], $scope.superdevice.longitude = item.location[1];
                break;
            }
            return Devices.setCity(city), Devices.setLatitude($scope.superdevice.latitude), 
            Devices.setLongitude($scope.superdevice.longitude);
        }, $scope.locationmodeOpsList = [ {
            showName: "固定坐标",
            value: "fix"
        }, {
            showName: "开车路线",
            value: "car"
        } ], $scope.setLocationMode = function() {
            return Devices.setLocationMode($scope.superdevice.locationmode);
        };
    } ]).controller("VerifyCodeCtrl", [ "$scope", "$state", "Devices", "$ionicPopup", "$ionicHistory", function($scope, $state, Devices, $ionicPopup, $ionicHistory) {} ]).controller("MeCtrl", [ "$scope", "$state", "Devices", "$ionicPopup", "$ionicHistory", "$interval", function($scope, $state, Devices, $ionicPopup, $ionicHistory, $interval) {
        var admobid, largeStartIndex, smallStartIndex;
        return $ionicHistory.clearHistory(), $scope.networkStatus = null, navigator.connection && navigator.connection.type && ($scope.networkStatus = $scope.getConnectionTypeDesc()), 
        smallStartIndex = Math.floor(Math.random() * window.smalladmob.length), largeStartIndex = Math.floor(Math.random() * window.largeadmob.length), 
        admobid = {
            banner: "ca-app-pub-7798193972099512/4031561787",
            interstitial: "ca-app-pub-7798193972099512/7043903783"
        }, $scope.createBannerView = function() {
            return Devices.createBannerView();
        }, $scope.showBannerAd = function() {
            return Devices.showBannerAd();
        }, $scope.destroyBannerView = function() {
            return Devices.destroyBannerView();
        }, $scope.requestInterstitialAd = function() {
            return Devices.requestInterstitialAd();
        }, $scope.showInterstitialAd = function() {
            return Devices.readyThenShowInterstitialAd();
        }, $scope.$on("$destroy", function() {});
    } ]).controller("BackupCtrl", [ "$scope", "$state", "Devices", "$ionicPopup", "$ionicHistory", function($scope, $state, Devices, $ionicPopup, $ionicHistory) {
        return $scope.superdevice = Devices.getDeviceInfo(), $scope.backup = function() {
            return Devices.backup().then(function() {
                return $scope.showAlert("备份成功!");
            }, function(reason) {
                return $scope.showAlert("备份失败!");
            });
        }, $scope.$on("$destroy", function() {
            return Devices.dbWorkaround();
        });
    } ]).controller("HistoryCtrl", [ "$scope", "$state", "Devices", "$ionicPopup", "$ionicHistory", function($scope, $state, Devices, $ionicPopup, $ionicHistory) {
        return $scope.superdevice = Devices.getDeviceInfo(), $scope.list = [], $scope.listHistory = function() {
            return Devices.listHistory().then(function(results) {
                var i, o, _i, _ref, _results;
                if ($scope.list = [], results.rows.length) {
                    for (_results = [], i = _i = 0, _ref = results.rows.length; _ref >= 0 ? _ref >= _i : _i >= _ref; i = _ref >= 0 ? ++_i : --_i) o = results.rows.item(i), 
                    o.timestamp1 = new Date(o.timestamp), _results.push($scope.list.push(o));
                    return _results;
                }
            }, function(reason) {
                return $scope.showAlert("数据库操作失败!");
            });
        }, $scope.restore = function(index) {
            var confirmPopup;
            return index >= $scope.list.length ? void $scope.showAlert("出现错误,请尝试退出当前页面，重新操作!") : (confirmPopup = $ionicPopup.confirm({
                title: "确认提示",
                template: "确定要恢复吗?",
                cancelText: "取消",
                okText: "确定"
            }), confirmPopup.then(function(res) {
                var item;
                if (res) return item = $scope.list[index], Devices.setWithBundle(item), $scope.showAlert("修改成功!");
            }));
        }, $scope["delete"] = function(index) {
            var confirmPopup;
            return index >= $scope.list.length ? void $scope.showAlert("出现错误,请尝试退出当前页面，重新操作!") : (confirmPopup = $ionicPopup.confirm({
                title: "确认提示",
                template: "确定要删除吗?",
                cancelText: "取消",
                okText: "确定"
            }), confirmPopup.then(function(res) {
                var item;
                if (res) return item = $scope.list[index], Devices.deleteDB(item.id), $scope.list.splice(index, 1), 
                $scope.showAlert("删除成功!");
            }));
        }, $scope.listHistory();
    } ]).controller("HelpCtrl", [ "$scope", "$state", "Devices", "$ionicPopup", "$ionicHistory", function($scope, $state, Devices, $ionicPopup, $ionicHistory) {
        var titles, totalPage;
        return $scope.page = 1, $scope.helpTitle = "帮助", titles = [ "帮助", "Root", "安装Xposed", "安装/激活赚客神器", "测试赚客神器", "如何清除应用残留", "如何备份/恢复当前数据", "如何暂时停用赚客神器" ], 
        totalPage = titles.length, $scope.previousPage = function() {
            return $scope.page > 1 && ($scope.page -= 1), $scope.helpTitle = titles[$scope.page - 1];
        }, $scope.nextPage = function() {
            return $scope.page < totalPage && ($scope.page += 1), $scope.helpTitle = titles[$scope.page - 1];
        }, $scope.go2Page = function(idx) {
            return $scope.page = idx, $scope.helpTitle = titles[$scope.page - 1];
        };
    } ]), angular.module("Device.Services", []).factory("Devices", [ "$q", "$http", "CacheFactory", function($q, $http, CacheFactory) {
        var admobid, backup, createBannerView, dbWorkaround, deleteDB, destroyBannerView, getDeviceInfo, getLocationInfo, getSimInfo, getWifiInfo, listHistory, produceIMSI, producePhonenumber, produceRandomDevice, produceRandomICCID, produceRandomImei, produceRandomMacAddress, produceRandomSim, readyThenShowInterstitialAd, requestInterstitialAd, setBoard, setBootloader, setBrand, setCity, setDevice, setDeviceId, setDisplay, setID, setIPAddress, setImsi, setLatitude, setLine1Number, setLocationMode, setLongitude, setMacAddress, setManufacturer, setModel, setNetworkOperator, setNetworkOperatorName, setProduct, setSimOperator, setSimOperatorName, setSimSerialNumber, setWithBundle, showBannerAd, showInterstitialAd, startMockGPS, startWithLocationPath, stopMockGPS;
        return getDeviceInfo = function() {
            return window.superdevice;
        }, getWifiInfo = function() {
            var deferred, fail, win;
            return deferred = $q.defer(), win = function(result) {
                return deferred.resolve(result);
            }, fail = function(err) {
                return deferred.reject(err);
            }, window.superdevice.getWifiInfo(win, fail), deferred.promise;
        }, getSimInfo = function() {
            var deferred, fail, win;
            return deferred = $q.defer(), win = function(result) {
                return deferred.resolve(result);
            }, fail = function(err) {
                return deferred.reject(err);
            }, window.superdevice.getSimInfo(win, fail), deferred.promise;
        }, getLocationInfo = function() {
            var deferred, fail, win;
            return deferred = $q.defer(), win = function(result) {
                return deferred.resolve(result);
            }, fail = function(err) {
                return deferred.reject(err);
            }, window.superdevice.getLocationInfo(win, fail), deferred.promise;
        }, startMockGPS = function() {
            return window.superdevice.startMockGPS();
        }, startWithLocationPath = function(minutes, path) {
            return window.superdevice.startWithLocationPath(minutes, path);
        }, stopMockGPS = function() {
            return window.superdevice.stopMockGPS();
        }, setCity = function(city) {
            return window.superdevice.setCity(city);
        }, setLocationMode = function(mode) {
            return window.superdevice.setLocationMode(mode);
        }, setLatitude = function(latitude) {
            return window.superdevice.setLatitude(latitude);
        }, setLongitude = function(longitude) {
            return window.superdevice.setLongitude(longitude);
        }, setID = function(id) {
            return window.superdevice.setID(id);
        }, setDeviceId = function(imei) {
            return window.superdevice.setDeviceId(imei);
        }, produceRandomImei = function() {
            var a, i, imei, _i;
            for (imei = "", i = _i = 0; 14 > _i; i = ++_i) a = Math.floor(10 * Math.random()), 
            imei += a;
            return imei;
        }, setManufacturer = function(data) {
            return window.superdevice.setManufacturer(data);
        }, setBrand = function(data) {
            return window.superdevice.setBrand(data);
        }, setProduct = function(data) {
            return window.superdevice.setProduct(data);
        }, setModel = function(data) {
            return window.superdevice.setModel(data);
        }, setBoard = function(data) {
            return window.superdevice.setBoard(data);
        }, setDevice = function(data) {
            return window.superdevice.setDevice(data);
        }, setDisplay = function(data) {
            return window.superdevice.setDisplay(data);
        }, setBootloader = function(data) {
            return window.superdevice.setBootloader(data);
        }, produceRandomDevice = function() {
            var a, brandList, i, item, productList, _i, _j;
            for (item = {}, item.imei = produceRandomImei(), brandList = Object.keys(window.imeiStore), 
            a = Math.floor(Math.random() * brandList.length), item.brand = brandList[a], item.manufacturer = brandList[a], 
            productList = window.imeiStore[item.brand], a = Math.floor(Math.random() * productList.length), 
            item.product = item.model = item.board = productList[a].model, item.device = item.product, 
            i = _i = 0; 5 > _i; i = ++_i) a = Math.floor(10 * Math.random()), item.device += a;
            for (item.display = item.product, i = _j = 0; 10 > _j; i = ++_j) a = Math.floor(10 * Math.random()), 
            item.display += a;
            return item.id = item.brand + item.product, item;
        }, setMacAddress = function(data) {
            return window.superdevice.setMacAddress(data);
        }, setIPAddress = function(data) {
            return window.superdevice.setIPAddress(data);
        }, produceRandomMacAddress = function() {
            var a, i, mac, values, _i;
            for (values = [ "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f" ], 
            mac = "", i = _i = 0; 17 > _i; i = ++_i) i > 0 && (i - 2) % 3 === 0 ? mac += ":" : (a = Math.floor(Math.random() * values.length), 
            console.log(a), mac += values[a]);
            return mac;
        }, setLine1Number = function(data) {
            return window.superdevice.setLine1Number(data);
        }, setNetworkOperator = function(data) {
            return window.superdevice.setNetworkOperator(data);
        }, setNetworkOperatorName = function(data) {
            return window.superdevice.setNetworkOperatorName(data);
        }, setSimOperatorName = function(data) {
            return window.superdevice.setSimOperatorName(data);
        }, setSimOperator = function(data) {
            return window.superdevice.setSimOperator(data);
        }, setSimSerialNumber = function(data) {
            return window.superdevice.setSimSerialNumber(data);
        }, setImsi = function(data) {
            return window.superdevice.setImsi(data);
        }, produceRandomICCID = function(opid) {
            var a, i, iccid, _i;
            for (iccid = "8986" + opid, a = Math.floor(10 * Math.random()), iccid += a, a = Math.floor(10 * Math.random()), 
            iccid += a, a = Math.floor(10 * Math.random()), iccid += a, a = Math.floor(10 * Math.random()), 
            iccid += a, a = Math.floor(2 * Math.random()), iccid += a, a = Math.floor(6 * Math.random()), 
            iccid += a, a = Math.floor(10 * Math.random()), iccid += a, i = _i = 0; 7 > _i; i = ++_i) a = Math.floor(10 * Math.random()), 
            iccid += a;
            return iccid;
        }, producePhonenumber = function(prefix) {
            var a, i, phonenumber, _i;
            for (phonenumber = prefix, i = _i = 0; 8 > _i; i = ++_i) a = Math.floor(10 * Math.random()), 
            phonenumber += a;
            return phonenumber;
        }, produceIMSI = function(opid) {
            var a, i, imsi, _i;
            for (imsi = "460", imsi += opid, i = _i = 0; 10 > _i; i = ++_i) a = Math.floor(10 * Math.random()), 
            imsi += a;
            return imsi;
        }, produceRandomSim = function() {
            var a, id, idList, item, name, opid, prefix, prefixList;
            return item = {}, idList = Object.keys(window.simStore), a = Math.floor(Math.random() * idList.length), 
            id = idList[a], item.simoperator = id, item.networkoperator = id, name = window.simStore[id].name, 
            item.simoperatorname = name, item.networkoperatorname = name, prefixList = window.simStore[id].numbers, 
            opid = window.simStore[id].id, a = Math.floor(Math.random() * prefixList.length), 
            prefix = prefixList[a], item.line1number = producePhonenumber(prefix), item.simserialnumber = produceRandomICCID(opid), 
            item.imsi = produceIMSI(opid), item;
        }, listHistory = function() {
            var db, deferred, fail, win;
            return deferred = $q.defer(), db = window.sqlitePlugin.openDatabase({
                name: "history.db",
                androidDatabaseImplementation: 2,
                androidLockWorkaround: 1
            }), win = function(xxx, results) {
                return deferred.resolve(results);
            }, fail = function(e, i) {
                return deferred.reject(e);
            }, db.transaction(function(tx) {
                return tx.executeSql("SELECT * FROM history_tbl ORDER BY timestamp DESC", [], win, fail);
            }, function(error) {
                return console.log("listHistory transaction error: " + error.message), db.close();
            }, function() {
                return console.log("listHistory transaction ok"), db.close(function() {
                    return console.log("listHistory database is closed ok");
                });
            }), deferred.promise;
        }, backup = function() {
            var INSERT_SCHEM, db, deferred, fail, values, win;
            return deferred = $q.defer(), db = window.sqlitePlugin.openDatabase({
                name: "history.db",
                androidDatabaseImplementation: 2,
                androidLockWorkaround: 1
            }), win = function(xxx, results) {
                return deferred.resolve(results);
            }, fail = function(e, i) {
                return deferred.reject(e);
            }, INSERT_SCHEM = "INSERT INTO history_tbl (timestamp, imei, model, brand, product, manufacturer, board, device, display, bootloader, simoperator, simoperatorname, simserialnumber, line1number, networkoperatorname, networkoperator, macaddress ) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)", 
            values = [ new Date(), window.superdevice.imei, window.superdevice.model, window.superdevice.brand, window.superdevice.product, window.superdevice.manufacturer, window.superdevice.board, window.superdevice.device, window.superdevice.display, window.superdevice.bootloader, window.superdevice.simoperator, window.superdevice.simoperatorname, window.superdevice.simserialnumber, window.superdevice.line1number, window.superdevice.networkoperatorname, window.superdevice.networkoperator, window.superdevice.macaddress ], 
            db.transaction(function(tx) {
                return tx.executeSql(INSERT_SCHEM, values, win, fail);
            }, function(error) {
                return console.log("backup transaction error: " + error.message), db.close();
            }, function() {
                return console.log("backup transaction ok"), db.close();
            }), deferred.promise;
        }, setWithBundle = function(items) {
            var deferred, fail, win;
            return deferred = $q.defer(), win = function(result) {
                return deferred.resolve(result);
            }, fail = function(err) {
                return deferred.reject(err);
            }, window.superdevice.setWithBundle(items, win, fail), deferred.promise;
        }, deleteDB = function(id) {
            var db, deferred, fail, win;
            return deferred = $q.defer(), db = window.sqlitePlugin.openDatabase({
                name: "history.db",
                androidDatabaseImplementation: 2,
                androidLockWorkaround: 1
            }), win = function(xxx, results) {
                return deferred.resolve(results);
            }, fail = function(e, i) {
                return deferred.reject(e);
            }, db.transaction(function(tx) {
                return tx.executeSql("DELETE FROM history_tbl where id = ?", [ id ], win, fail);
            }, function(error) {
                return console.log("deleteDB transaction error: " + error.message), db.close();
            }, function() {
                return console.log("deleteDB transaction ok"), db.close();
            }), deferred.promise;
        }, dbWorkaround = function() {
            var db;
            return db = window.sqlitePlugin.openDatabase({
                name: "history.db",
                androidDatabaseImplementation: 2,
                androidLockWorkaround: 1
            }), db.close();
        }, admobid = {
            banner: "ca-app-pub-7798193972099512/4031561787",
            interstitial: "ca-app-pub-7798193972099512/7043903783"
        }, createBannerView = function() {
            return AdMob ? AdMob.createBanner({
                adId: admobid.banner,
                position: AdMob.AD_POSITION.BOTTOM_CENTER,
                autoShow: !0
            }) : void 0;
        }, showBannerAd = function() {
            return AdMob ? AdMob.showBanner(AdMob.AD_POSITION.BOTTOM_CENTER) : void 0;
        }, destroyBannerView = function() {
            return AdMob ? AdMob.removeBanner() : void 0;
        }, requestInterstitialAd = function() {
            return AdMob ? AdMob.prepareInterstitial({
                adId: admobid.interstitial,
                autoShow: !0
            }) : void 0;
        }, showInterstitialAd = function() {
            return AdMob ? AdMob.showInterstitialAd() : void 0;
        }, readyThenShowInterstitialAd = function() {
            return AdMob ? AdMob.isInterstitialReady(function(isready) {
                return isready ? AdMob.showInterstitial() : void 0;
            }) : void 0;
        }, {
            getDeviceInfo: getDeviceInfo,
            getWifiInfo: getWifiInfo,
            getSimInfo: getSimInfo,
            getLocationInfo: getLocationInfo,
            startMockGPS: startMockGPS,
            startWithLocationPath: startWithLocationPath,
            stopMockGPS: stopMockGPS,
            setCity: setCity,
            setLatitude: setLatitude,
            setLongitude: setLongitude,
            setLocationMode: setLocationMode,
            setID: setID,
            setDeviceId: setDeviceId,
            produceRandomImei: produceRandomImei,
            setManufacturer: setManufacturer,
            setModel: setModel,
            setBoard: setBoard,
            setProduct: setProduct,
            setBrand: setBrand,
            setDevice: setDevice,
            setDisplay: setDisplay,
            setBootloader: setBootloader,
            produceRandomDevice: produceRandomDevice,
            setMacAddress: setMacAddress,
            setIPAddress: setIPAddress,
            produceRandomMacAddress: produceRandomMacAddress,
            setLine1Number: setLine1Number,
            setNetworkOperator: setNetworkOperator,
            setNetworkOperatorName: setNetworkOperatorName,
            setSimOperatorName: setSimOperatorName,
            setSimOperator: setSimOperator,
            setSimSerialNumber: setSimSerialNumber,
            setImsi: setImsi,
            produceRandomSim: produceRandomSim,
            listHistory: listHistory,
            backup: backup,
            setWithBundle: setWithBundle,
            deleteDB: deleteDB,
            dbWorkaround: dbWorkaround,
            createBannerView: createBannerView,
            showBannerAd: showBannerAd,
            destroyBannerView: destroyBannerView,
            requestInterstitialAd: requestInterstitialAd,
            showInterstitialAd: showInterstitialAd,
            readyThenShowInterstitialAd: readyThenShowInterstitialAd
        };
    } ]), window.imeiStore = {
        Coolpad: [ {
            model: "8730L",
            imei: "86317002",
            display: "720x1280"
        }, {
            model: "8908",
            imei: "86084502",
            display: "720x1280"
        }, {
            model: "5219",
            imei: "99000457",
            display: "480x854"
        }, {
            model: "8056",
            imei: "86985001",
            display: "320x480"
        }, {
            model: "8736",
            imei: "86281702",
            display: "720x1280"
        }, {
            model: "9930",
            imei: "99000048",
            display: "480x960"
        }, {
            model: "5879",
            imei: "99000316",
            display: "480x854"
        }, {
            model: "8022",
            imei: "86466801",
            display: "320x480"
        }, {
            model: "8297",
            imei: "86377702",
            display: "720x1280"
        }, {
            model: "8720L",
            imei: "86409302",
            display: "720x1280"
        }, {
            model: "8730",
            imei: "86881301",
            display: "720x1280"
        }, {
            model: "9150",
            imei: "99000455",
            display: "540x960"
        }, {
            model: "9976A",
            imei: "86306102",
            display: "1200x1920"
        }, {
            model: "5860A",
            imei: "A1000039",
            display: "480x800"
        }, {
            model: "5951",
            imei: "99000314",
            display: "720x1280"
        }, {
            model: "8085",
            imei: "86301802",
            display: "480x854"
        }, {
            model: "8017-T00",
            imei: "86513202",
            display: "480x854"
        } ],
        Huawei: [ {
            model: "H30-C00",
            imei: "A0000049",
            display: "540x960"
        }, {
            model: "H30-T00",
            imei: "A0000049",
            display: "540x960"
        }, {
            model: "C8816",
            imei: "A0000049",
            display: "540x960"
        }, {
            model: "HN3-U01",
            imei: "86457201",
            display: "720x1280"
        }, {
            model: "T8808D",
            imei: "86415301",
            display: "480x800"
        }, {
            model: "C8950D",
            imei: "a0000042",
            display: "540x960"
        }, {
            model: "G630-U00",
            imei: "86383702",
            display: "720x1280"
        }, {
            model: "G730-U30",
            imei: "86458102",
            display: "540x960"
        }, {
            model: "U8860",
            imei: "86894300",
            display: "480x854"
        }, {
            model: "7D-501u",
            imei: "86432302",
            display: "1200x1920"
        }, {
            model: "T9200",
            imei: "86375601",
            display: "540x960"
        }, {
            model: "Y210-2010",
            imei: "a0000043",
            display: "320x480"
        }, {
            model: "Y310-5000",
            imei: "86097900",
            display: "480x800"
        }, {
            model: "Y511-T00",
            imei: "86365502",
            display: "480x854"
        }, {
            model: "Y600-U00",
            imei: "35405402",
            display: "480x854"
        }, {
            model: "B199",
            imei: "A0000049",
            display: "720x1280"
        }, {
            model: "G716-L070",
            imei: "86237202",
            display: "720x1280"
        }, {
            model: "H30-L01",
            imei: "86450202",
            display: "720x1280"
        }, {
            model: "P2-6011",
            imei: "86104600",
            display: "720x1280"
        }, {
            model: "P7-L07",
            imei: "35745704",
            display: "1080x1920"
        }, {
            model: "C8817L",
            imei: "A000004F",
            display: "540x960"
        }, {
            model: "C8650",
            imei: "a000002d",
            display: "320x480"
        }, {
            model: "G610-C00",
            imei: "A0000033",
            display: "540x960"
        }, {
            model: "G620-L72",
            imei: "86403202",
            display: "540x960"
        }, {
            model: "G630-U00",
            imei: "86383702",
            display: "720x1280"
        }, {
            model: "U8818",
            imei: "86316601",
            display: "480x800"
        }, {
            model: "U9200",
            imei: "86310101",
            display: "540x960"
        } ],
        Hisense: [ {
            model: "HS-E820",
            imei: "a100003f",
            display: "320x480"
        }, {
            model: "HS-T9",
            imei: "86077702",
            display: "720x1280"
        }, {
            model: "HS-T959",
            imei: "86248202",
            display: "480x854"
        }, {
            model: "HS-EG966",
            imei: "A100003F",
            display: "480x854"
        } ],
        HEDY: [ {
            model: "H750",
            imei: "86271802",
            display: "540x960"
        }, {
            model: "H770",
            imei: "86270202",
            display: "720x1280"
        }, {
            model: "T730",
            imei: "86899800",
            display: "480x854"
        } ],
        DESAY: [ {
            model: "TS1008",
            imei: "86263702",
            display: "480x800"
        }, {
            model: "TS1218",
            imei: "86008302",
            display: "480x854"
        } ],
        GoDonie: [ {
            model: "N9008",
            imei: "86350002",
            display: "540x960"
        }, {
            model: "S8",
            imei: "86388802",
            display: "480x854"
        } ],
        OPSSON: [ {
            model: "US6",
            imei: "86470601",
            display: "540x960"
        } ],
        PULID: [ {
            model: "F18",
            imei: "86863000",
            display: "480x854"
        } ],
        ONN: [ {
            model: "K7",
            imei: "86012402",
            display: "720x1280"
        } ],
        LG: [ {
            model: "C660",
            imei: "00440234",
            display: "256x320"
        }, {
            model: "LG-P765",
            imei: "35430305",
            display: "540x960"
        } ],
        nubia: [ {
            model: "NX40X",
            imei: "86085401",
            display: "720x1280"
        }, {
            model: "NX501",
            imei: "86975001",
            display: "1080x1920"
        } ],
        OPPO: [ {
            model: "X909",
            imei: "86942101",
            display: "1080x1920"
        }, {
            model: "R2017",
            imei: "86461602",
            display: "540x960"
        }, {
            model: "R829T",
            imei: "86321602",
            display: "720x1280"
        }, {
            model: "R833T",
            imei: "86291002",
            display: "480x800"
        }, {
            model: "U705T",
            imei: "12624800",
            display: "540x960"
        }, {
            model: "U701",
            imei: "86404801",
            display: "480x800"
        }, {
            model: "R819T",
            imei: "86116002",
            display: "720x1280"
        }, {
            model: "T29",
            imei: "86752301",
            display: "540x960"
        } ],
        DOOV: [ {
            model: "D920",
            imei: "86781700",
            display: "480x854"
        }, {
            model: "D800",
            imei: "86276302",
            display: "540x960"
        }, {
            model: "D330",
            imei: "86365302",
            display: "540x960"
        }, {
            model: "D910",
            imei: "86699901",
            display: "480x800"
        }, {
            model: "S2",
            imei: "faf96116",
            display: "720x1280"
        } ],
        Amoi: [ {
            model: "A900T",
            imei: "86330502",
            display: "720x1280"
        }, {
            model: "N890",
            imei: "86715501",
            display: "540x960"
        } ],
        Motorola: [ {
            model: "MT870",
            imei: "86040400",
            display: "540x960"
        }, {
            model: "XT788",
            imei: "35254805",
            display: "540x960"
        }, {
            model: "ME860",
            imei: "35645104",
            display: "540x960"
        }, {
            model: "XT928",
            imei: "A000002C",
            display: "720x1280"
        }, {
            model: "ME811",
            imei: "A000002C",
            display: "480x854"
        }, {
            model: "XT531",
            imei: "35638404",
            display: "320x480"
        }, {
            model: "XT535",
            imei: "35898004",
            display: "480x854"
        }, {
            model: "XT685",
            imei: "35221305",
            display: "480x854"
        }, {
            model: "XT882",
            imei: "A000002C",
            display: "540x960"
        }, {
            model: "XT910",
            imei: "35652104",
            display: "544x960"
        }, {
            model: "A953",
            imei: "35278404",
            display: "480x854"
        } ],
        SAMSUNG: [ {
            model: "GT-I8580",
            imei: "35797505",
            display: "480x800"
        }, {
            model: "GT-I9118",
            imei: "35842505",
            display: "480x800"
        }, {
            model: "GT-S6812C",
            imei: "35763605",
            display: "320x480"
        }, {
            model: "GT-S7272C",
            imei: "35983005",
            display: "480x800"
        }, {
            model: "GT-S7278",
            imei: "35917105",
            display: "480x800"
        }, {
            model: "GT-S7278U",
            imei: "35963805",
            display: "480x800"
        }, {
            model: "SCH-I535",
            imei: "99000206",
            display: "720x1280"
        }, {
            model: "SCH-I545",
            imei: "99000351",
            display: "1080x1920"
        }, {
            model: "SCH-I699I",
            imei: "A0000045",
            display: "480x800"
        }, {
            model: "SHV-E220S",
            imei: "35472405",
            display: "720x1280"
        }, {
            model: "SM-C101",
            imei: "35743405",
            display: "540x960"
        }, {
            model: "SM-G3568V",
            imei: "35296606",
            display: "480x800"
        }, {
            model: "GT-I9195",
            imei: "35773705",
            display: "540x960"
        }, {
            model: "GT-I9205",
            imei: "35775005",
            display: "720x1280"
        }, {
            model: "GT-I9208",
            imei: "35629205",
            display: "720x1280"
        }, {
            model: "GT-I9300I",
            imei: "35977605",
            display: "720x1280"
        }, {
            model: "GT-N5110",
            imei: "4400018f",
            display: "800x1280"
        }, {
            model: "GT-N8010",
            imei: "a1699485",
            display: "1280x800"
        }, {
            model: "SCH-I589",
            imei: "A000002F",
            display: "320x480"
        }, {
            model: "SCH-i889",
            imei: "A0000030",
            display: "800x1280"
        }, {
            model: "SCH-P729",
            imei: "A0000044",
            display: "720x1280"
        }, {
            model: "SM-G3509",
            imei: "A0000045",
            display: "480x800"
        }, {
            model: "GT-I8160",
            imei: "35568605",
            display: "480x800"
        }, {
            model: "GT-I9108",
            imei: "35780604",
            display: "480x800"
        }, {
            model: "GT-I9158",
            imei: "35613105",
            display: "540x960"
        }, {
            model: "GT-I9200",
            imei: "35652105",
            display: "720x1280"
        }, {
            model: "GT-I9502",
            imei: "35598105",
            display: "1080x1920"
        }, {
            model: "GT-S5830",
            imei: "35879404",
            display: "320x480"
        }, {
            model: "I9001",
            imei: "35172205",
            display: "480x800"
        }, {
            model: "SM-G3818",
            imei: "35885805",
            display: "540x960"
        }, {
            model: "SM-T2558",
            imei: "35272906",
            display: "720x1280"
        } ],
        ZTE: [ {
            model: "U930HD",
            imei: "86844701",
            display: "720x1280"
        }, {
            model: "V967S",
            imei: "86572101",
            display: "540x960"
        }, {
            model: "N5",
            imei: "86018402",
            display: "720x1280"
        }, {
            model: "N5S",
            imei: "70fda8c0",
            display: "720x1280"
        }, {
            model: "N880E",
            imei: "a1000023",
            display: "480x800"
        }, {
            model: "N980",
            imei: "A0000038",
            display: "540x960"
        }, {
            model: "Q501U",
            imei: "86276902",
            display: "480x854"
        }, {
            model: "U9180",
            imei: "86450102",
            display: "720x1280"
        }, {
            model: "U950",
            imei: "86633501",
            display: "480x800"
        }, {
            model: "V975",
            imei: "86837601",
            display: "720x1280"
        }, {
            model: "N855D",
            imei: "A0000037",
            display: "320x480"
        }, {
            model: "U5S",
            imei: "86299902",
            display: "720x1280"
        }, {
            model: "U807",
            imei: "86205901",
            display: "480x800"
        }, {
            model: "N970",
            imei: "A0000037",
            display: "540x960"
        } ],
        PHICOMM: [ {
            model: "i600w",
            imei: "86883101",
            display: "480x800"
        }, {
            model: "FWS610",
            imei: "86097501",
            display: "320x480"
        }, {
            model: "FWS910",
            imei: "86211301",
            display: "480x800"
        }, {
            model: "C230v",
            imei: "86204902",
            display: "480x800"
        } ],
        SONY: [ {
            model: "ST26i",
            imei: "35184706",
            display: "480x854"
        }, {
            model: "L39h",
            imei: "35809405",
            display: "1080x1920"
        }, {
            model: "ST17i",
            imei: "35851004",
            display: "320x480"
        }, {
            model: "MT25i",
            imei: "35289005",
            display: "480x854"
        }, {
            model: "S50h",
            imei: "35277406",
            display: "540x960"
        } ],
        kliton: [ {
            model: "I888KX",
            imei: "86092602",
            display: "480x854"
        } ],
        AUX: [ {
            model: "I7",
            imei: "86400202",
            display: "720x1280"
        }, {
            model: "M678A",
            imei: "35828700",
            display: "480x800"
        }, {
            model: "V965T",
            imei: "86204802",
            display: "480x854"
        }, {
            model: "W1",
            imei: "86245002",
            display: "1080x1920"
        } ],
        BiRD: [ {
            model: "i600",
            imei: "86507001",
            display: "480x800"
        }, {
            model: "T9600",
            imei: "86103800",
            display: "540x960"
        }, {
            model: "XL200",
            imei: "86365602",
            display: "720x1280"
        }, {
            model: "I8S",
            imei: "86322702",
            display: "540x960"
        } ],
        "K-Touch": [ {
            model: "E800",
            imei: "a1000014",
            display: "480x800"
        }, {
            model: "W98",
            imei: "86231402",
            display: "480x854"
        }, {
            model: "T81",
            imei: "86082702",
            display: "480x854"
        }, {
            model: "W700",
            imei: "86506100",
            display: "480x800"
        }, {
            model: "W800",
            imei: "86887600",
            display: "480x800"
        }, {
            model: "S5",
            imei: "86070502",
            display: "540x960"
        }, {
            model: "W96",
            imei: "86213902",
            display: "480x854"
        } ],
        Onda: [ {
            model: "V819",
            imei: "86362102",
            display: "768x1024"
        } ],
        lenovo: [ {
            model: "A820e",
            imei: "A1000030",
            display: "540x960"
        }, {
            model: "K900",
            imei: "86048602",
            display: "1080x1920"
        }, {
            model: "A630",
            imei: "86899801",
            display: "480x854"
        }, {
            model: "A860e",
            imei: "A100003A",
            display: "540x960"
        }, {
            model: "S686",
            imei: "86541201",
            display: "480x800"
        }, {
            model: "S870e",
            imei: "A1000030",
            display: "540x960"
        }, {
            model: "S938t",
            imei: "86335302",
            display: "720x1280"
        }, {
            model: "S968t",
            imei: "86324702",
            display: "1080x1920"
        }, {
            model: "A390",
            imei: "86126901",
            display: "480x800"
        }, {
            model: "A820",
            imei: "86121302",
            display: "540x960"
        }, {
            model: "S720i",
            imei: "86964901",
            display: "540x960"
        }, {
            model: "S820",
            imei: "86036502",
            display: "720x1280"
        }, {
            model: "A680",
            imei: "86280202",
            display: "480x854"
        }, {
            model: "K2110A",
            imei: "de7a47dd",
            display: "1280x800"
        }, {
            model: "K800",
            imei: "86174001",
            display: "720x1280"
        }, {
            model: "K860i",
            imei: "86946001",
            display: "720x1280"
        }, {
            model: "S920",
            imei: "86007102",
            display: "720x1280"
        }, {
            model: "3GW101",
            imei: "86887700",
            display: "480x800"
        }, {
            model: "A670t",
            imei: "86036602",
            display: "480x854"
        }, {
            model: "A708t",
            imei: "86303402",
            display: "540x960"
        }, {
            model: "A788t",
            imei: "86318402",
            display: "480x854"
        } ],
        HTC: [ {
            model: "T329t",
            imei: "35435605",
            display: "480x800"
        }, {
            model: "D816w",
            imei: "35224606",
            display: "720x1280"
        }, {
            model: "T-Mobile",
            imei: "35911603",
            display: "G2"
        }, {
            model: "D516d",
            imei: "A1000037",
            display: "540x960"
        }, {
            model: "M8St",
            imei: "35411306",
            display: "1080x1920"
        }, {
            model: "X720d",
            imei: "A1000031",
            display: "720x1280"
        }, {
            model: "Z560e",
            imei: "35291005",
            display: "540x960"
        }, {
            model: "A510c",
            imei: "A100000D",
            display: "320x480"
        }, {
            model: "S710d",
            imei: "A100000D",
            display: "480x800"
        }, {
            model: "C510e",
            imei: "86636500",
            display: "320x480"
        }, {
            model: "T327t",
            imei: "35531805",
            display: "480x800"
        }, {
            model: "Z715e",
            imei: "35945804",
            display: "544x960"
        }, {
            model: "T328w",
            imei: "35363805",
            display: "480x800"
        }, {
            model: "5088",
            imei: "35716305",
            display: "480x800"
        }, {
            model: "606w",
            imei: "35638005",
            display: "540x960"
        }, {
            model: "ADR6300",
            imei: "A1000013",
            display: "480x800"
        }, {
            model: "S510e",
            imei: "35806704",
            display: "480x800"
        } ],
        Gionee: [ {
            model: "E5",
            imei: "86063602",
            display: "720x1280"
        }, {
            model: "X817",
            imei: "86091902",
            display: "720x1280"
        } ],
        MI: [ {
            model: "2S",
            imei: "86031202",
            display: "720x1280"
        }, {
            model: "ONE",
            imei: "86017301",
            display: "480x854"
        } ],
        vivo: [ {
            model: "S11t",
            imei: "86127602",
            display: "480x800"
        } ],
        NAMO: [ {
            model: "N860",
            imei: "86408401",
            display: "480x800"
        } ],
        HUAWEI: [ {
            model: "H30-C00",
            imei: "A0000049",
            display: "540x960"
        }, {
            model: "H30-T00",
            imei: "A0000049",
            display: "540x960"
        }, {
            model: "C8816",
            imei: "A0000049",
            display: "540x960"
        }, {
            model: "HN3-U01",
            imei: "86457201",
            display: "720x1280"
        }, {
            model: "T8808D",
            imei: "86415301",
            display: "480x800"
        }, {
            model: "C8950D",
            imei: "a0000042",
            display: "540x960"
        }, {
            model: "G630-U00",
            imei: "86383702",
            display: "720x1280"
        }, {
            model: "G730-U30",
            imei: "86458102",
            display: "540x960"
        }, {
            model: "U8860",
            imei: "86894300",
            display: "480x854"
        }, {
            model: "7D-501u",
            imei: "86432302",
            display: "1200x1920"
        }, {
            model: "T9200",
            imei: "86375601",
            display: "540x960"
        }, {
            model: "Y210-2010",
            imei: "a0000043",
            display: "320x480"
        }, {
            model: "Y310-5000",
            imei: "86097900",
            display: "480x800"
        }, {
            model: "Y511-T00",
            imei: "86365502",
            display: "480x854"
        }, {
            model: "Y600-U00",
            imei: "35405402",
            display: "480x854"
        }, {
            model: "B199",
            imei: "A0000049",
            display: "720x1280"
        }, {
            model: "G716-L070",
            imei: "86237202",
            display: "720x1280"
        }, {
            model: "H30-L01",
            imei: "86450202",
            display: "720x1280"
        }, {
            model: "P2-6011",
            imei: "86104600",
            display: "720x1280"
        }, {
            model: "P7-L07",
            imei: "35745704",
            display: "1080x1920"
        }, {
            model: "C8817L",
            imei: "A000004F",
            display: "540x960"
        }, {
            model: "C8650",
            imei: "a000002d",
            display: "320x480"
        }, {
            model: "G610-C00",
            imei: "A0000033",
            display: "540x960"
        }, {
            model: "G620-L72",
            imei: "86403202",
            display: "540x960"
        }, {
            model: "G630-U00",
            imei: "86383702",
            display: "720x1280"
        }, {
            model: "U8818",
            imei: "86316601",
            display: "480x800"
        }, {
            model: "U9200",
            imei: "86310101",
            display: "540x960"
        } ],
        "T-smart": [ {
            model: "D28X",
            imei: "86354801",
            display: "480x854"
        }, {
            model: "D58X",
            imei: "86555801",
            display: "540x960"
        } ],
        ASUS: [ {
            model: "ME371MG",
            imei: "35538305",
            display: "800x1280"
        }, {
            model: "T00J",
            imei: "35225106",
            display: "720x1280"
        }, {
            model: "T00G",
            imei: "35225006",
            display: "720x1280"
        }, {
            model: "K012",
            imei: "35249606",
            display: "600x1024"
        } ]
    }, window.simStore = {
        "46000": {
            name: "中国移动",
            id: "00",
            numbers: [ "135", "136", "137", "138", "139", "139" ]
        },
        "46002": {
            name: "中国移动",
            id: "00",
            numbers: [ "134", "150", "151", "152", "158", "159", "187" ]
        },
        "46007": {
            name: "中国移动",
            id: "00",
            numbers: [ "157", "188", "147" ]
        },
        "46001": {
            name: "中国联通",
            id: "01",
            numbers: [ "130", "131", "132", "155", "156" ]
        },
        "46006": {
            name: "中国联通",
            id: "01",
            numbers: [ "186" ]
        },
        "46003": {
            name: "中国电信",
            id: "03",
            numbers: [ "133", "153", "189", "181" ]
        }
    }, angular.module("ToolboxModule", [ "ionic", "Toolbox.Services", "Toolbox.Controllers" ]).config([ "$stateProvider", "$urlRouterProvider", function($stateProvider, $urlRouterProvider) {
        return $stateProvider.state("app.device.toolbox", {
            url: "/toolbox",
            views: {
                tab4: {
                    templateUrl: "partials_phone/toolbox/menu.html",
                    controller: "ToolboxCtrl"
                }
            }
        }).state("app.systempackagelist", {
            url: "/systempackagelist",
            views: {
                main: {
                    templateUrl: "partials_phone/toolbox/packagelist.html",
                    controller: "PackageListCtrl"
                }
            },
            params: {
                isSystem: !0,
                title: "系统应用"
            }
        }).state("app.nosystempackagelist", {
            url: "/nosystempackagelist",
            views: {
                main: {
                    templateUrl: "partials_phone/toolbox/packagelist.html",
                    controller: "PackageListCtrl"
                }
            },
            params: {
                isSystem: !1,
                title: "非系统应用"
            }
        });
    } ]), angular.module("Toolbox.Controllers", [ "Toolbox.Services" ]).controller("ToolboxCtrl", [ "$scope", "$state", "$ionicHistory", function($scope, $state, $ionicHistory) {
        return $ionicHistory.clearHistory();
    } ]).controller("PackageListCtrl", [ "$scope", "$state", "Packages", function($scope, $state, Packages) {
        var processlist, updateList, updatePackageList, updateProcessList;
        return $scope.list = [], $scope.title = $state.params.title, $scope.isSystem = $state.params.isSystem, 
        $scope.showLoading(), processlist = [], updatePackageList = function() {
            return $scope.isSystem ? Packages.getSystemPackages().then(function(result) {
                return $scope.list = result, updateList(), $scope.hideLoading();
            }) : Packages.getNoSystemPackages().then(function(result) {
                return $scope.list = result, updateList(), $scope.hideLoading();
            });
        }, updateProcessList = function() {
            var isAll;
            return isAll = $scope.isSystem, Packages.getProcessList(isAll).then(function(result) {
                return processlist = result, updateList();
            });
        }, updateList = function() {
            var pakcageItem, pkg, process, _i, _len, _ref, _results;
            if (0 !== $scope.list.length && 0 !== processlist.length) {
                for (_ref = $scope.list, _results = [], _i = 0, _len = _ref.length; _len > _i; _i++) pakcageItem = _ref[_i], 
                pakcageItem.process = [], pakcageItem.processLabel = "进程列表:", _results.push(function() {
                    var _j, _len1, _results1;
                    for (_results1 = [], _j = 0, _len1 = processlist.length; _len1 > _j; _j++) process = processlist[_j], 
                    _results1.push(function() {
                        var _k, _len2, _ref1, _results2;
                        for (_ref1 = process.pkgList, _results2 = [], _k = 0, _len2 = _ref1.length; _len2 > _k; _k++) pkg = _ref1[_k], 
                        pkg === pakcageItem.packageName ? (pakcageItem.process.push(process.pid), pakcageItem.processLabel += "[" + process.pid + "]", 
                        _results2.push(pakcageItem.processLabel += " ")) : _results2.push(void 0);
                        return _results2;
                    }());
                    return _results1;
                }());
                return _results;
            }
        }, updatePackageList(), updateProcessList(), $scope.clear = function(item) {
            return Packages.clearData(item.packageName).then(function() {
                return $scope.showAlert("删除残留数据成功！");
            });
        }, $scope.killProcesses = function(item) {
            return Packages.killBackgroundProcesses(item.packageName), Packages.killProcesses(item.process).then(function() {
                return updateProcessList(), $scope.showAlert("强制关闭成功！");
            });
        }, $scope.uninstall = function(item) {
            return Packages.uninstall(item.packageName).then(function() {
                return updatePackageList(), $scope.showAlert("卸载成功！");
            });
        };
    } ]).controller("ProcessListCtrl", [ "$scope", "$state", "Packages", function($scope, $state, Packages) {
        return $scope.list = [], $scope.title = $state.params.title, $scope.showLoading(), 
        Packages.getProcessList(!0).then(function(result) {
            return $scope.list = result, $scope.hideLoading();
        });
    } ]).controller("ResolveListCtrl", [ "$scope", "$state", "Packages", "packageList", function($scope, $state, Packages, packageList) {
        return $scope.list = packageList;
    } ]), angular.module("Toolbox.Services", []).factory("Packages", [ "$q", "$http", "CacheFactory", function($q, $http, CacheFactory) {
        var clearData, getApplicationInfo, getNoSystemPackages, getPackageInfo, getPackageManage, getProcessList, getResolveinfo, getSystemPackages, killBackgroundProcesses, killProcesses, uninstall;
        return getPackageManage = function() {
            return window.packagemanage;
        }, getPackageInfo = function(packagename) {
            var deferred, fail, win;
            return deferred = $q.defer(), win = function(result) {
                return deferred.resolve(result);
            }, fail = function(err) {
                return deferred.reject(err);
            }, window.packagemanage.getPackageInfo(packagename, win, fail), deferred.promise;
        }, getSystemPackages = function() {
            var deferred, fail, win;
            return deferred = $q.defer(), win = function(result) {
                return deferred.resolve(result);
            }, fail = function(err) {
                return deferred.reject(err);
            }, window.packagemanage.getSystemPackages(win, fail), deferred.promise;
        }, getNoSystemPackages = function() {
            var deferred, fail, win;
            return deferred = $q.defer(), win = function(result) {
                return deferred.resolve(result);
            }, fail = function(err) {
                return deferred.reject(err);
            }, window.packagemanage.getNoSystemPackages(win, fail), deferred.promise;
        }, clearData = function(packagename) {
            var deferred, fail, win;
            return deferred = $q.defer(), win = function(result) {
                return deferred.resolve(result);
            }, fail = function(err) {
                return deferred.reject(err);
            }, window.packagemanage.clearData(packagename, win, fail), deferred.promise;
        }, getProcessList = function(isAll) {
            var deferred, fail, win;
            return null == isAll && (isAll = !1), deferred = $q.defer(), win = function(result) {
                return deferred.resolve(result);
            }, fail = function(err) {
                return deferred.reject(err);
            }, window.packagemanage.getProcessList(isAll, win, fail), deferred.promise;
        }, killProcesses = function(processes) {
            var deferred, fail, win;
            return deferred = $q.defer(), win = function(result) {
                return deferred.resolve(result);
            }, fail = function(err) {
                return deferred.reject(err);
            }, window.packagemanage.killProcesses(processes, win, fail), deferred.promise;
        }, killBackgroundProcesses = function(packagename) {
            var deferred, fail, win;
            return deferred = $q.defer(), win = function(result) {
                return deferred.resolve(result);
            }, fail = function(err) {
                return deferred.reject(err);
            }, window.packagemanage.killBackgroundProcesses(packagename, win, fail), deferred.promise;
        }, uninstall = function(packagename) {
            var deferred, fail, win;
            return deferred = $q.defer(), win = function(result) {
                return deferred.resolve(result);
            }, fail = function(err) {
                return deferred.reject(err);
            }, window.packagemanage.uninstall(packagename, win, fail), deferred.promise;
        }, getResolveinfo = function() {
            var deferred, fail, win;
            return deferred = $q.defer(), win = function(result) {
                return deferred.resolve(result);
            }, fail = function(err) {
                return deferred.reject(err);
            }, window.packagemanage.getResolveinfo(win, fail), deferred.promise;
        }, getApplicationInfo = function(packagename) {
            var deferred, fail, win;
            return deferred = $q.defer(), win = function(result) {
                return deferred.resolve(result);
            }, fail = function(err) {
                return deferred.reject(err);
            }, window.packagemanage.getApplicationInfo(packagename, win, fail), deferred.promise;
        }, {
            getSystemPackages: getSystemPackages,
            getNoSystemPackages: getNoSystemPackages,
            clearData: clearData,
            getProcessList: getProcessList,
            killProcesses: killProcesses,
            killBackgroundProcesses: killBackgroundProcesses,
            uninstall: uninstall,
            getPackageManage: getPackageManage,
            getPackageInfo: getPackageInfo,
            getApplicationInfo: getApplicationInfo,
            getResolveinfo: getResolveinfo
        };
    } ]);
}.call(this), angular.module("HapiApp").run([ "$templateCache", function($templateCache) {
    "use strict";
    $templateCache.put("partials_phone/device/backup.html", '<ion-view title="备份" cache-view="false"><ion-nav-bar class="bar-assertive nav-title-slide-ios7"><ion-nav-buttons side="left"><i class="button button-icon icon ion-chevron-left" ng-click="back()"></i></ion-nav-buttons><ion-nav-buttons side="right"><button class="button" ng-click="backup()">备份</button></ion-nav-buttons></ion-nav-bar><ion-content class="has-header"><div class="list"><div class="item item-divider">设备</div><label class="item item-input"><span class="input-label">手机串号</span> <span class="mybadge badge-assertive">{{ superdevice.imei }}</span></label><label class="item item-input"><span class="input-label">品牌</span> <span class="mybadge badge-assertive">{{ superdevice.brand }}</span></label><label class="item item-input"><span class="input-label">生产厂商</span> <span class="mybadge badge-assertive">{{ superdevice.manufacturer }}</span></label><label class="item item-input"><span class="input-label">型号</span> <span class="mybadge badge-assertive">{{ superdevice.model }}</span></label><label class="item item-input"><span class="input-label">Product</span> <span class="mybadge badge-assertive">{{ superdevice.product }}</span></label><label class="item item-input"><span class="input-label">Board</span> <span class="mybadge badge-assertive">{{ superdevice.board }}</span></label><label class="item item-input"><span class="input-label">Device</span> <span class="mybadge badge-assertive">{{ superdevice.device }}</span></label><label class="item item-input"><span class="input-label">Display</span> <span class="mybadge badge-assertive">{{ superdevice.display }}</span></label><div class="item item-divider">Wifi</div><label class="item item-input"><div class="input-label">MacAddress</div><span class="mybadge badge-assertive">{{ superdevice.macaddress }}</span></label><div class="item item-divider">手机卡</div><label class="item item-input"><div class="input-label">SimOperator</div><span class="mybadge badge-assertive">{{ superdevice.simoperator }}</span></label><label class="item item-input"><div class="input-label">SimOperatorName</div><span class="mybadge badge-assertive">{{ superdevice.simoperatorname }}</span></label><label class="item item-input"><div class="input-label">SimOperator</div><span class="mybadge badge-assertive">{{ superdevice.simoperator }}</span></label><label class="item item-input"><div class="input-label">ICCID</div><span class="mybadge badge-assertive">{{ superdevice.simserialnumber }}</span></label><label class="item item-input"><div class="input-label">手机号</div><span class="mybadge badge-assertive">{{ superdevice.line1number }}</span></label><label class="item item-input"><div class="input-label">运营商</div><span class="mybadge badge-assertive">{{ superdevice.networkoperatorname }}</span></label><label class="item item-input"><div class="input-label">运营商ID</div><span class="mybadge badge-assertive">{{ superdevice.networkoperator }}</span></label></div></ion-content></ion-view>'), 
    $templateCache.put("partials_phone/device/device.html", '<ion-view title="设备" cache-view="false"><ion-nav-bar class="bar-assertive nav-title-slide-ios7"><!--\r\n  <ion-nav-buttons side="left"> \r\n    <i class="button button-icon icon ion-chevron-left" ng-click="onBackKey1()"></i>\r\n  </ion-nav-buttons>\r\n\r\n  --></ion-nav-bar><ion-content class="has-header"><div class="list"><label class="item item-input"><span class="input-label">UUID</span> <input type="text" name="text" ng-model="superdevice.uuid" ng-disabled="true"></label><!--\r\n        <label class="item item-input">\r\n          <span class="input-label">Cordova</span>\r\n          <input type="text" ng-model="superdevice.cordova"  ng-readonly=true></input>\r\n        </label>\r\n        --><label class="item item-input"><span class="input-label">平台</span> <input type="text" name="text" ng-model="superdevice.platform" ng-disabled="true"><!--<span class="mybadge badge-assertive">{{ superdevice.platform }}</span>--></label><label class="item item-input"><span class="input-label">版本</span> <input type="text" name="text" ng-model="superdevice.version" ng-disabled="true"></label><label class="item item-input"><span class="input-label">CPU_ABI</span> <input type="text" name="text" ng-model="superdevice.cpu_abi" ng-disabled="true"></label><label class="item item-input"><span class="input-label">CPU_ABI2</span> <input type="text" name="text" ng-model="superdevice.cpu_abi2" ng-disabled="true"></label><label class="item item-input item-stacked-label"><span class="input-label">手机串号</span> <button class="button button-small button-positive pull-right" ng-click="produceRandomImei()" ng-disabled="loginUser.expired">Randam</button> <input type="text" ng-model="superdevice.imei" ng-readonly="true"></label><label class="item item-input"><div class="input-label">品牌</div><select ng-model="superdevice.brand" ng-options="item for item in brandOpsList" ng-change="setBrand()" ng-disabled="loginUser.expired"></select></label><label class="item item-input"><div class="input-label">生产厂商</div><select ng-model="superdevice.manufacturer" ng-options="item for item in manufacturerOpsList" ng-change="setManufacturer()" ng-disabled="loginUser.expired"></select></label><label class="item item-input"><div class="input-label">型号</div><select ng-model="superdevice.model" ng-options="item.model as item.model for item in modelOpsList" ng-change="setModel()" ng-disabled="loginUser.expired"></select></label><label class="item item-input"><span class="input-label">ID</span> <input type="text" name="text" ng-model="superdevice.id" ng-model-options="{updateOn:\'blur\',debounce:{default:1000,blur:0}}" ng-change="setID()" ng-disabled="loginUser.expired"></label><label class="item item-input"><span class="input-label">Device</span> <input type="text" name="text" ng-model="superdevice.device" ng-model-options="{updateOn:\'blur\',debounce:{default:1000,blur:0}}" ng-change="setDevice()" ng-disabled="loginUser.expired"></label><label class="item item-input"><span class="input-label">Product</span> <input type="text" name="text" ng-model="superdevice.product" ng-model-options="{updateOn:\'blur\',debounce:{default:1000,blur:0}}" ng-change="setProduct()" ng-disabled="loginUser.expired"></label><label class="item item-input"><span class="input-label">Display</span> <input type="text" name="text" ng-model="superdevice.display" ng-model-options="{updateOn:\'blur\',debounce:{default:1000,blur:0}}" ng-change="setDisplay()" ng-disabled="loginUser.expired"></label><label class="item item-input"><span class="input-label">Bootloader</span> <input type="text" name="text" ng-model="superdevice.bootloader" ng-model-options="{updateOn:\'blur\',debounce:{default:1000,blur:0}}" ng-change="setBootloader()" ng-disabled="loginUser.expired"></label><label class="item item-input"><span class="input-label">Board</span> <input type="text" name="text" ng-model="superdevice.board" ng-model-options="{updateOn:\'blur\',debounce:{default:1000,blur:0}}" ng-change="setBoard()" ng-disabled="loginUser.expired"></label></div><button class="button button-block button-positive" ng-click="produceRandomDevice()" ng-disabled="loginUser.expired">一键随机生成新设备</button></ion-content></ion-view>'), 
    $templateCache.put("partials_phone/device/help.html", '<ion-view title="{{helpTitle}}"><ion-nav-bar class="bar-assertive nav-title-slide-ios7"><ion-nav-buttons side="left"><i class="button button-icon icon ion-chevron-left" ng-click="back()"></i></ion-nav-buttons><ion-nav-bar class="bar-assertive nav-title-slide-ios7"></ion-nav-bar><ion-content class="has-header"><div class="box" ng-if="page==1"><div class="card"><div class="item item-text-wrap"><ui type="circle"><li>本软件是基于Xposed框架,使用前必须先Root,然后安装Xposed框架</li><li>支持Android 4.0.2到4.4.x之间的版本，推荐华为荣耀3C</li><li>请参考下面的步骤安装/使用</li></ui></div></div><div class="list"><a class="item item-icon-left" ng-click="go2Page(2)"><i class="icon ion-ios-circle-filled"></i> Root</a> <a class="item item-icon-left" ng-click="go2Page(3)"><i class="icon ion-ios-circle-filled"></i> 安装Xposed框架</a> <a class="item item-icon-left" ng-click="go2Page(5)"><i class="icon ion-ios-circle-filled"></i> 安装/激活赚客神器</a> <a class="item item-icon-left" ng-click="go2Page(6)"><i class="icon ion-ios-circle-filled"></i> 测试赚客神器</a> <a class="item item-icon-left" ng-click="go2Page(7)"><i class="icon ion-ios-circle-filled"></i> 如何清除应用残留</a> <a class="item item-icon-left" ng-click="go2Page(8)"><i class="icon ion-ios-circle-filled"></i> 如何备份/恢复当前数据</a> <a class="item item-icon-left" ng-click="go2Page(9)"><i class="icon ion-ios-circle-filled"></i> 如何暂时停用赚客神器</a></div></div><div class="box" ng-if="page==2"><div class="card list"><div class="item item-divider">Root</div><div class="item item-text-wrap">建议使用KingRoot Root,请自行下载. 如果不行，再试试360Root之类的.</div></div></div><div class="box" ng-if="page==3"><div class="card list"><div class="item item-divider">安装Xposed</div><div class="item item-text-wrap"><ui type="circle"><li>Xposed目前只支持Android 4.0.2 到4.4.x之间的版本</li><li>安装Xposed可能会导致您的手机变成砖头，所以安装之前请准备好刷机工具.</li></ui></div><div class="item item-text-wrap"><a href="http://dl-xda.xposed.info/modules/de.robv.android.xposed.installer_v33_36570c.apk">官方2.7版本</a></div><div class="item item-text-wrap"><a href="http://share.weiyun.com/8c8a5d049d389201d75685f7aa0edc95">微云共享的2.7版本</a></div><div class="item item-text-wrap"><a href="http://yun.baidu.com/s/1kUecqfd?fid=1072140134213127">百度云共享的2.7版本</a></div></div></div><div class="box" ng-if="page==4"><div class="card list"><div class="item item-divider">安装/激活赚客神器,然后重启手机</div><div class="item item-image"><img src="img_phone/jihuo.jpg"></div></div></div><div class="box" ng-if="page==5"><div class="card list"><div class="item item-divider">测试赚客神器</div><div class="item item-text-wrap"><ui type="circle"><li>打开赚客神器，修改串号</li><li>拨号界面输入*#06#，确认修改是否有效</li></ui></div><div class="item item-image"><img src="img_phone/imei.jpg"></div><div class="item item-image"><img src="img_phone/06.jpg"></div></div></div><div class="box" ng-if="page==6"><div class="card list"><div class="item item-divider">如何清除应用残留</div><div class="item item-image"><img src="img_phone/cleardata.jpg"></div></div></div><div class="box" ng-if="page==7"><div class="card list"><div class="item item-divider">如何备份/恢复当前数据</div><div class="item item-image"><img src="img_phone/backup.jpg"></div><div class="item item-image"><img src="img_phone/restore.jpg"></div></div></div><div class="box" ng-if="page==8"><div class="card list"><div class="item item-divider">如何暂时停用赚客神器</div><div class="item item-text-wrap">在框架里面取消激活，然后重启即可</div><div class="item item-image"><img src="img_phone/jihuo.jpg"></div></div></div></ion-content><div class="bar bar-footer"><button class="button button-outline button-positive" ng-click="previousPage()">上一页</button><div class="title" ng-click="go2Page(1)">帮助</div><button class="button button-outline button-positive" ng-click="nextPage()">下一页</button></div></ion-nav-bar></ion-view>'), 
    $templateCache.put("partials_phone/device/history.html", '<ion-view title="历史数据:{{list.length}}个"><ion-nav-bar class="bar-assertive nav-title-slide-ios7"><ion-nav-buttons side="left"><i class="button button-icon icon ion-chevron-left" ng-click="back()"></i></ion-nav-buttons><ion-nav-bar class="bar-assertive nav-title-slide-ios7"><!--\r\n  <ion-nav-buttons side="left">\r\n    <button menu-toggle="left" class="button button-icon icon ion-navicon"></button>\r\n  </ion-nav-buttons>\r\n  --></ion-nav-bar><ion-content class="has-header" delegate-handle="mainScroll"><div ng-if="list.length>0"><div class="list card" ng-repeat="item in list"><div class="item item-divider item-button-right-me">{{item.timestamp1 | date:\'yyyy-MM-dd HH:mm:ss\'}}</div><label class="item item-input"><span class="input-label">手机串号</span> <span class="input-label">{{ item.imei }}</span></label><label class="item item-input"><span class="input-label">品牌</span> <span class="input-label">{{ item.brand }}</span></label><label class="item item-input"><span class="input-label">型号</span> <span class="input-label">{{ item.model }}</span></label><label class="item item-input"><span class="input-label">MacAddress</span> <span class="input-label">{{ item.macaddress }}</span></label><label class="item item-input"><span class="input-label">手机号</span> <span class="input-label">{{ item.line1number }}</span></label><label class="item item-input"><span class="input-label">ICCID</span> <span class="input-label">{{ item.simserialnumber }}</span></label><div class="item tabs tabs-secondary tabs-icon-left"><a class="tab-item" ng-click="restore($index)"><i class="icon ion-thumbsup"></i> 恢复</a> <a class="tab-item" ng-click="delete($index)"><i class="icon ion-chatbox"></i> 删除</a></div></div></div></ion-content></ion-nav-bar></ion-view>'), 
    $templateCache.put("partials_phone/device/location.html", '<ion-view title="{{title}}" cache-view="true"><ion-nav-bar class="bar-assertive nav-title-slide-ios7"><ion-nav-buttons side="left"><button ng-if="mockLocation" class="button" ng-click="stopMockGPS()">关闭模拟定位</button> <button ng-if="!mockLocation" class="button" ng-click="startMockGPS()">开启模拟定位</button></ion-nav-buttons><ion-nav-buttons side="right"><button class="button" ng-click="openSetting()">设置</button></ion-nav-buttons></ion-nav-bar><ion-content class="has-header"><div ng-if="!mockLocation"><div class="item item-button-right" ng-if="pathSetting.step==1">双击设置起始位置 <button class="button button-positive" ng-click="resetPathSettin()">重置</button></div><div class="item item-button-right" ng-if="pathSetting.step==2">双击设置结束位置 <button class="button button-positive" ng-click="resetPathSettin()">重置</button></div><div class="item item-input" ng-if="pathSetting.step==3"><span class="input-label">时间</span><select ng-model="pathSetting.minutes" ng-options="item.value as item.showName for item in minutesOpsList"></select></div><label class="item item-input" ng-if="pathSetting.step==3">点击做上角的"开启模拟定位"</label></div><div id="container" style="width:400px; height:440px"></div><div class="item item-divider">当前(双击选择):{{superdevice.latitude | number:6 }}/{{superdevice.longitude| number:6}}</div><!--<div class="card"> <pre>{{getConnectionTypeDesc()}}</pre></div>--><!--<div class="card"> <pre>{{superdevice | json}}</pre></div>--></ion-content></ion-view>'), 
    $templateCache.put("partials_phone/device/locationsetting.html", '<ion-view title="定位设置"><ion-nav-bar class="bar-assertive nav-title-slide-ios7"><ion-nav-buttons side="left"><i class="button button-icon icon ion-chevron-left" ng-click="back()"></i></ion-nav-buttons></ion-nav-bar><ion-content class="has-header"><div class="list"><label class="item item-input item-select"><div class="input-label">城市</div><select ng-model="superdevice.city" ng-options="item.value as item.showName for item in cityOpsList" ng-change="setCity()"></select></label><label class="item item-input item-select"><div class="input-label">定位模式</div><select ng-model="superdevice.locationmode" ng-options="item.value as item.showName for item in locationmodeOpsList" ng-change="setLocationMode()"></select></label><div class="card"><div class="item item-text-wrap">固定位置:坐标固定在一个点上</div><div class="item item-text-wrap">步行路线：根据您选中的起始和结束位置确定步行路线,然后根据设定的时间,动态调整坐标</div><div class="item item-text-wrap">步行路线：根据您选中的起始和结束位置确定车行路线,然后根据设定的时间,动态调整坐标</div></div></div></ion-content></ion-view>'), 
    $templateCache.put("partials_phone/device/main.html", '<ion-tabs class="tabs-icon-top tabs-dark"><ion-tab title="设备" icon-on="icon ion-ios-filing" icon-off="icon ion-ios-filing-outline" ui-sref="app.device.deviceinfo"><ion-nav-view name="tab1"></ion-nav-view></ion-tab><!--href="#/shop/shoppingcart" also works --><ion-tab title="手机卡" icon-on="icon ion-ios-telephone" icon-off="icon ion-ios-telephone-outline" ui-sref="app.device.siminfo"><ion-nav-view name="tab2"></ion-nav-view></ion-tab><ion-tab title="Wifi" icon-on="icon ion-ios-flower" icon-off="icon ion-ios-flower-outline" ui-sref="app.device.wifiinfo"><ion-nav-view name="tab3"></ion-nav-view></ion-tab><ion-tab title="工具箱" icon-on="ion-ios-gear" icon-off="ion-ios-gear-outline" ui-sref="app.device.toolbox"><ion-nav-view name="tab4"></ion-nav-view></ion-tab><!--\r\n  <ion-tab title="定位" icon-on="ion-ios-paw" icon-off="ion-ios-paw-outline" ui-sref="app.device.location">\r\n    <ion-nav-view name="tab4"></ion-nav-view>\r\n  </ion-tab>\r\n--><ion-tab title="我" icon-on="ion-ios-person" icon-off="ion-ios-person-outline" ui-sref="app.device.me"><ion-nav-view name="tab5"></ion-nav-view></ion-tab></ion-tabs>'), 
    $templateCache.put("partials_phone/device/me.html", '<ion-view title="我" cache-view="false"><ion-nav-bar class="bar-assertive nav-title-slide-ios7"></ion-nav-bar><ion-content class="has-header"><div class="list"><a class="item item-avatar"><img src="img_phone/head_1.jpg"><h2 ng-if="!loginUser">未登陆用户，联网后自动登陆</h2><h2 ng-if="loginUser">ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:{{loginUser.username}}</h2><!--\r\n        <p ng-if="loginUser.sessionEndDate">有效期至&nbsp;:{{loginUser.sessionEndDate | date:\'yyyy-MM-dd HH:mm:ss\'}}</p>\r\n        <p ng-if="!loginUser.sessionEndDate">有效期至&nbsp;:有效期结束,请充值使用！</p>\r\n        --><p ng-if="loginUser">有效期&nbsp;&nbsp;:{{loginUser.expiredDate | date:\'yyyy-MM-dd HH:mm:ss\'}}</p></a><div class="item item-text-wrap">充值请联系管理员QQ:2708183946<br>QQ群: 493065259</div><div class="item item-text-wrap" ng-if="networkStatus">网络状态: {{networkStatus}}</div><a class="item item-icon-left" ui-sref="app.help"><i class="icon ion-chatbubble-working"></i> 帮助</a><!--\r\n      <a class="item item-icon-left" ng-click="createBannerView()">\r\n        <i class="icon ion-cube"></i>\r\n        createBannerView\r\n      </a>\r\n      <a class="item item-icon-left" ng-click="showBannerAd()">\r\n        <i class="icon ion-cube"></i>\r\n        showBannerAd\r\n      </a>\r\n\r\n      <a class="item item-icon-left" ng-click="destroyBannerView()">\r\n        <i class="icon ion-cube"></i>\r\n        destroyBannerView\r\n      </a>\r\n      <a class="item item-icon-left" ng-click="requestInterstitialAd()">\r\n        <i class="icon ion-cube"></i>\r\n        requestInterstitialAd\r\n      </a>\r\n      <a class="item item-icon-left" ng-click="showInterstitialAd()">\r\n        <i class="icon ion-cube"></i>\r\n        showInterstitialAd\r\n      </a>\r\n  \r\n      <div class="item card">\r\n        <pre>{{lasterr | json}}</pre>\r\n      </div>\r\n      <div class="item card">\r\n        <pre>{{loginUser | json}}</pre>\r\n      </div>\r\n\r\n      <div class="item card">\r\n        <pre>{{adClickCount | json}}</pre>\r\n      </div>\r\n    --></div></ion-content></ion-view>'), 
    $templateCache.put("partials_phone/device/sim.html", '<ion-view title="手机卡" cache-view="false"><ion-nav-bar class="bar-assertive nav-title-slide-ios7"></ion-nav-bar><ion-content class="has-header"><div class="list"><label class="item item-input"><div class="input-label">SIM运营商ID</div><input type="text" name="text" ng-model="superdevice.simoperator" ng-model-options="{updateOn:\'blur\',debounce:{default:1000,blur:0}}" ng-change="setSimOperator()" ng-disabled="loginUser.expired"></label><label class="item item-input"><div class="input-label">SIM运营商</div><input type="text" name="text" ng-model="superdevice.simoperatorname" ng-model-options="{updateOn:\'blur\',debounce:{default:1000,blur:0}}" ng-change="setSimOperatorName()" ng-disabled="loginUser.expired"></label><label class="item item-input"><div class="input-label">ICCID</div><input type="text" name="text" ng-model="superdevice.simserialnumber" ng-model-options="{updateOn:\'blur\',debounce:{default:1000,blur:0}}" ng-change="setSimSerialNumber()" ng-disabled="loginUser.expired"></label><label class="item item-input"><div class="input-label">IMSI</div><input type="text" name="text" ng-model="superdevice.imsi" ng-model-options="{updateOn:\'blur\',debounce:{default:1000,blur:0}}" ng-change="setImsi()" ng-disabled="loginUser.expired"></label><label class="item item-input"><div class="input-label">运营商</div><input type="text" name="text" ng-model="superdevice.networkoperatorname" ng-model-options="{updateOn:\'blur\',debounce:{default:1000,blur:0}}" ng-change="setNetworkOperatorName()" ng-disabled="loginUser.expired"></label><label class="item item-input"><div class="input-label">运营商ID</div><input type="text" name="text" ng-model="superdevice.networkoperator" ng-model-options="{updateOn:\'blur\',debounce:{default:1000,blur:0}}" ng-change="setNetworkOperator()" ng-disabled="loginUser.expired"></label><label class="item item-input"><div class="input-label">手机号</div><input type="text" name="text" ng-model="superdevice.line1number" ng-model-options="{updateOn:\'blur\',debounce:{default:1000,blur:0}}" ng-change="setLine1Number()" ng-disabled="loginUser.expired"></label></div><button class="button button-block button-positive" ng-click="produceRandomSim()" ng-disabled="loginUser.expired">一键随机生成</button></ion-content></ion-view>'), 
    $templateCache.put("partials_phone/device/verifycode.html", '<ion-view title="verifycode" cache-view="false"><ion-nav-bar class="bar-assertive nav-title-slide-ios7"><ion-nav-buttons side="left"><i class="button button-icon icon ion-chevron-left" ng-click="back()"></i></ion-nav-buttons><ion-nav-buttons side="right"><button class="button" ng-click="save()">保存</button></ion-nav-buttons></ion-nav-bar><ion-content class="has-header">verifycode</ion-content></ion-view>'), 
    $templateCache.put("partials_phone/device/wifi.html", '<ion-view title="Wifi" cache-view="false"><ion-nav-bar class="bar-assertive nav-title-slide-ios7"></ion-nav-bar><ion-content class="has-header"><div class="list"><label class="item item-input"><div class="input-label">BSSID</div><input type="text" name="text" ng-model="superdevice.bssid" ng-disabled="true"></label><label class="item item-input"><div class="input-label">路由器</div><input type="text" name="text" ng-model="superdevice.ssid" ng-disabled="true"></label><label class="item item-input"><div class="input-label">接收信号强度</div><input type="text" name="text" ng-model="superdevice.rssi" ng-disabled="true"></label><label class="item item-input"><div class="input-label">NetworkId</div><input type="text" name="text" ng-model="superdevice.networkid" ng-disabled="true"></label><label class="item item-input"><div class="input-label">NetworkOperator</div><input type="text" name="text" ng-model="superdevice.networkoperator" ng-disabled="true"></label><label class="item item-input"><div class="input-label">MacAddress</div><input type="text" name="text" ng-model="superdevice.macaddress" ng-model-options="{updateOn:\'blur\',debounce:{default:1000,blur:0}}" ng-change="setMacAddress()" ng-disabled="loginUser.expired"></label><!--\r\n      <label class="item item-input">\r\n        <div class="input-label">IP地址</div>\r\n        <input type="text" name="text" ng-model="superdevice.ipaddress" ng-model-options="{updateOn:\'blur\',debounce:{default:1000,blur:0}}" ng-change="setIPAddress()" ng-disabled="loginUser.expired>\r\n     \r\n      </label>\r\n      --></div><button class="button button-block button-positive" ng-click="produceRandomMac()" ng-disabled="loginUser.expired">一键随机生成MAC地址</button></ion-content></ion-view>'), 
    $templateCache.put("partials_phone/main/empty_main.html", '<ion-nav-view name="main" animation="slide-left-right"></ion-nav-view>'), 
    $templateCache.put("partials_phone/main/imgshow.html", '<div class="card"><img ng-src="http://api.map.baidu.com/staticimage?width=400&height=400&center={{court.coordinate}}&markers={{court.coordinate}}&zoom=18&markerStyles=l,0" ng-click="closeMap()"></div>'), 
    $templateCache.put("partials_phone/main/slide_main.html", '<ion-side-menus><ion-pane ion-side-menu-content><!--\r\n    <ion-nav-bar class="bar-assertive nav-title-slide-ios7">\r\n      <ion-nav-back-button class="button button-icon icon ion-chevron-left"> \r\n      </ion-nav-back-button>\r\n    </ion-nav-bar>\r\n  --><ion-nav-view name="main" animation="slide-left-right"></ion-nav-view></ion-pane><ion-side-menu side="left" enable-menu-with-back-views="false"><header class="bar bar-header bar-assertive"><h1 class="title" ui-sref="app.court.list">小牛踢球</h1></header><ion-content class="has-header"><ion-list><ion-item class="item-icon-left" nav-clear menu-close ui-sref="app.court.list"><i class="icon ion-home"></i>主页</ion-item><ion-item class="item-icon-left" nav-clear menu-close ui-sref="app.help"><i class="icon ion-help"></i>帮助</ion-item><ion-item class="item-icon-left" nav-clear menu-close ui-sref="app.email"><i class="icon ion-email"></i>建议与投诉</ion-item><!--\r\n        <ion-item class="item-icon-left" nav-clear menu-close ui-sref="app.about">\r\n          <i class="icon ion-ios7-people"></i>关于我们\r\n        </ion-item>\r\n        --></ion-list></ion-content></ion-side-menu></ion-side-menus>'), 
    $templateCache.put("partials_phone/toolbox/menu.html", '<ion-view title="工具箱"><ion-nav-bar class="bar-assertive nav-title-slide-ios7"></ion-nav-bar><ion-content class="has-header"><div class="list"><a class="item item-icon-left" ui-sref="app.nosystempackagelist"><i class="icon ion-pizza"></i> 非系统应用管理</a> <a class="item item-icon-left" ui-sref="app.systempackagelist"><i class="icon ion-aperture"></i> 系统应用管理</a> <a class="item item-icon-left" ng-if="loginUser.expired"><i class="icon ion-chatbubble-working"></i> 历史数据</a> <a class="item item-icon-left" ui-sref="app.history" ng-if="!loginUser.expired"><i class="icon ion-chatbubble-working"></i> 历史数据</a> <a class="item item-icon-left" ui-sref="app.backup"><i class="icon ion-cube"></i> 备份</a><!--\r\n      <a class="item item-icon-left" ui-sref="app.processlist">\r\n        <i class="icon ion-chatbubble-working"></i>\r\n        进场管理\r\n        \r\n      </a>\r\n\r\n      <a class="item item-icon-left" ui-sref="app.resolvelist">\r\n        <i class="icon ion-chatbubble-working"></i>\r\n        resolve list\r\n        \r\n      </a>\r\n      --></div></ion-content></ion-view>'), 
    $templateCache.put("partials_phone/toolbox/packagelist.html", '<ion-view title="{{title}}:{{list.length}}个" cache-view="false"><ion-nav-bar class="bar-assertive nav-title-slide-ios7"><ion-nav-buttons side="left"><i class="button button-icon icon ion-chevron-left" ng-click="back()"></i></ion-nav-buttons><ion-nav-bar class="bar-assertive nav-title-slide-ios7"><!--\r\n  <ion-nav-buttons side="left">\r\n    <button menu-toggle="left" class="button button-icon icon ion-navicon"></button>\r\n  </ion-nav-buttons>\r\n  --></ion-nav-bar><ion-content class="has-header" delegate-handle="mainScroll"><div ng-if="list.length>0"><div bindonce class="list card" ng-repeat="item in list"><a class="item item-divider item-icon-right"><h2 bo-text="item.label"></h2><h4 bo-text="item.packageName"></h4><p bo-text="item.processLabel" ng-if="item.process.length>0"></p><i class="icon ion-ios-telephone-outline"></i></a><!--\r\n\r\n        <div ng-if="item.applicationInfo">\r\n        \r\n\r\n          <label class="item item-stacked-label">\r\n            <span class="input-label">className</span>\r\n            <span class="input-label" bo-text="item.applicationInfo.className"></span>\r\n          </label>\r\n\r\n          <label class="item item-stacked-label">\r\n            <span class="input-label">backupAgentName</span>\r\n            <span class="input-label" bo-text="item.applicationInfo.backupAgentName"></span>\r\n          </label>\r\n          <label class="item item-stacked-label">\r\n            <span class="input-label">dataDir</span>\r\n            <span class="input-label" bo-text="item.applicationInfo.dataDir"></span>\r\n          </label>\r\n          <label class="item item-stacked-label">\r\n            <span class="input-label">descriptionRes</span>\r\n            <span class="input-label" bo-text="item.applicationInfo.descriptionRes"></span>\r\n          </label>\r\n          <label class="item item-stacked-label">\r\n            <span class="input-label">flags</span>\r\n            <span class="input-label" bo-text="item.applicationInfo.flags"></span>\r\n          </label>\r\n          <label class="item item-stacked-label">\r\n            <span class="input-label">manageSpaceActivityName</span>\r\n            <span class="input-label" bo-text="item.applicationInfo.manageSpaceActivityName"></span>\r\n          </label>\r\n          <div class="item item-stacked-label">\r\n            <span class="input-label">nativeLibraryDir</span>\r\n            <span class="input-label" bo-text="item.applicationInfo.nativeLibraryDir"></span>\r\n          </div>\r\n          <label class="item item-input">\r\n            <span class="input-label">permission</span>\r\n            <span class="input-label" bo-text="item.applicationInfo.permission"></span>\r\n          </label>\r\n          <label class="item item-input">\r\n            <span class="input-label">processName</span>\r\n            <span class="input-label" bo-text="item.applicationInfo.processName"></span>\r\n          </label>\r\n          <div class="item item-input item-stacked-label">\r\n            <span class="input-label">publicSourceDir</span>\r\n            <span class="input-label" bo-text="item.applicationInfo.publicSourceDir"></span>\r\n          </div>\r\n          <label class="item item-input">\r\n            <span class="input-label">requiresSmallestWidthDp</span>\r\n            <span class="input-label" bo-text="item.applicationInfo.requiresSmallestWidthDp"></span>\r\n          </label>\r\n          <div class="item item-stacked-label">\r\n            <span class="input-label">sourceDir</span>\r\n            <span class="input-label" bo-text="item.applicationInfo.sourceDir"></span>\r\n          </div>\r\n          <label class="item item-input">\r\n            <span class="input-label">taskAffinity</span>\r\n            <span class="input-label" bo-text="item.applicationInfo.taskAffinity"></span>\r\n          </label>\r\n          <label class="item item-input">\r\n            <span class="input-label">uid</span>\r\n            <span class="input-label" bo-text="item.applicationInfo.uid"></span>\r\n          </label>\r\n        </div>\r\n        \r\n\r\n \r\n        <div class="item item-divider  item-button-right-me">\r\n          {{item.firstInstallTime | date:\'yyyy-MM-dd HH:mm:ss\'}}\r\n          \r\n        </div>\r\n        \r\n        <label class="item item-input">\r\n          <span class="input-label">sharedUserId</span>\r\n          <span class="input-label">{{ item.sharedUserId }}</span>\r\n        </label>\r\n        <label class="item item-input">\r\n          <span class="input-label">sharedUserLabel</span>\r\n          <span class="input-label">{{ item.sharedUserLabel }}</span>\r\n        </label>\r\n        <label class="item item-input">\r\n          <span class="input-label">versionCode</span>\r\n          <span class="input-label">{{ item.versionCode }}</span>\r\n        </label>\r\n        <label class="item item-input">\r\n          <span class="input-label">versionName</span>\r\n          <span class="input-label">{{ item.versionName }}</span>\r\n        </label>\r\n        --><div class="item tabs tabs-secondary tabs-icon-left"><a class="tab-item" ng-click="clear(item)" ng-disabled="loginUser.expired"><i class="icon ion-thumbsup"></i> 清除残留数据</a> <a class="tab-item" ng-click="killProcesses(item)" ng-disabled="item.process.length==0 || loginUser.expired"><i class="icon ion-chatbox"></i> 强制关闭</a> <a class="tab-item" ng-click="uninstall(item)" ng-if="!isSystem" ng-disabled="loginUser.expired"><i class="icon ion-chatbox"></i> 卸载</a></div></div></div></ion-content></ion-nav-bar></ion-view>'), 
    $templateCache.put("partials_phone/toolbox/processlist.html", '<ion-view title="进程管理:{{list.length}}个" cache-view="false"><ion-nav-bar class="bar-assertive nav-title-slide-ios7"><ion-nav-buttons side="left"><i class="button button-icon icon ion-chevron-left" ng-click="back()"></i></ion-nav-buttons><ion-nav-bar class="bar-assertive nav-title-slide-ios7"><!--\r\n  <ion-nav-buttons side="left">\r\n    <button menu-toggle="left" class="button button-icon icon ion-navicon"></button>\r\n  </ion-nav-buttons>\r\n  --></ion-nav-bar><ion-content class="has-header" delegate-handle="mainScroll"><div ng-if="list.length>0"><div class="card" ng-repeat="item in list"><pre>{{item | json}}</pre></div></div></ion-content></ion-nav-bar></ion-view>'), 
    $templateCache.put("partials_phone/toolbox/resolvelist.html", '<ion-view title="已安装的APP:{{list.length}}个"><ion-nav-bar class="bar-assertive nav-title-slide-ios7"><ion-nav-buttons side="left"><i class="button button-icon icon ion-chevron-left" ng-click="back()"></i></ion-nav-buttons><ion-nav-bar class="bar-assertive nav-title-slide-ios7"><!--\r\n  <ion-nav-buttons side="left">\r\n    <button menu-toggle="left" class="button button-icon icon ion-navicon"></button>\r\n  </ion-nav-buttons>\r\n  --></ion-nav-bar><ion-content class="has-header" delegate-handle="mainScroll"><div ng-if="list.length>0"><div bindonce nav-direction="forward" class="list card" ng-repeat="item in list"><div class="item item-divider"><span class="input-label" bo-text="item.resolvePackageName"></span> <span class="input-label" bo-text="item.label"></span> <span class="input-label" bo-text="item.priority"></span></div></div></div></ion-content></ion-nav-bar></ion-view>');
} ]);